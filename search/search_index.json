{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OSM Fieldwork","text":"<p> Processing field data from ODK to OpenStreetMap format, and other field utils. </p> <p> </p> <p>\ud83d\udcd6 Documentation: https://hotosm.github.io/osm-fieldwork/</p> <p>\ud83d\udda5\ufe0f Source Code: https://github.com/hotosm/osm-fieldwork</p>"},{"location":"#history","title":"History \ud83d\udcd6","text":"<p>The History of the OSM Fieldwork Project begins with Rob Savoye, Senior Technical Lead at Humanitarian OpenStreetMap Team.</p> <p>In 2010, Rob's rural volunteer fire department(he is also a long time free software developer for the GNU project, fire-fighter, climber, disaster tech support.) faced the challenge of outdated giant paper mapbooks with incomplete information. Despite Google having limited address and remote road coverage, the lack of cell service made it impossible to rely on it for verification. Determined to find a solution, Rob turned to OpenStreetMap (OSM).  His first step involved importing building footprints and addresses into OSM, greatly aiding the fire department in locating places quickly and easily. The response time was significantly reduced, nearly halved. Given that most of the roads were dirt jeep trails, Rob undertook ground-truthing the highway and trail data in OSM. Over the course of several years, he diligently added precise information about all the highways in his area, enabling the fire department to determine the appropriate response vehicles for each scenario. Once Rob had successfully improved the fire district maps, he expanded his efforts to map the remote regions of Colorado and a few neighboring states, proving invaluable during large wildland fires. Ground-truthing became an integral part of his work, conducted using mobile devices in the field. To streamline the data collection process, Rob heavily relied on ODK and eventually created additional software to facilitate data processing, which had previously been time-consuming and tedious. Now, transferring data seamlessly from his phone to OSM requires minimal effort. To this day, Rob continues his weekly field mapping every few months while continuously enhancing the software used in the project.</p>"},{"location":"#about-osm-fieldwork","title":"About OSM Fieldwork","text":"<p>Osm-Fieldwork is a project for processing data collection using ODK into OpenStreetMap format. It includes several utility programs that automate part of the data flow like creating satellite imagery basemaps and data extracts from OpenStreetMap so they can be used with ODK Collect. Many of these steps are currently a manual process.  All of the programs in osm-fieldwork are designed to function as the backend of a webpage, but to also work standalone and offline. The standalone functionality are simple command line programs run in a terminal. They were originally created for producing emergency response maps in the Western United States, which is explained in this talk from SOTM-US 2022 titled OSM For Firefighting. Much of the tech and usage is explained in these tech briefs. Currently these are now part of the backend for the Field Mapping Tasking Manager project at HOT.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install osm-fieldwork, you can use pip. Here are two options:</p> <ul> <li>Directly from the main branch:</li> </ul> <pre><code>pip install git+https://github.com/hotosm/osm-fieldwork.git\n</code></pre> <ul> <li>Latest on PyPi:</li> </ul> <pre><code>pip install osm-fieldwork\n</code></pre>"},{"location":"#configure","title":"Configure","text":"<p>Osm-Fieldwork can be configured using a simple config ($HOME/.osm-fieldwork)file in your home directory, or using environment variables.</p>"},{"location":"#config-file","title":"Config file","text":"<p>The config file is used to store the credentials to access an ODK Central server. You must have an account on the Central server of course for this to work. That file looks like this:</p> <pre><code>url=https://foo.org\nuser=foo@bar.org\npasswd=arfood\n</code></pre>"},{"location":"#environment-variables","title":"Environment Variables","text":"<ul> <li>LOG_LEVEL</li> </ul> <p>If present, will change the log level. Defaults to DEBUG.</p> <ul> <li>ODK_CENTRAL_URL</li> </ul> <p>The URL for an ODKCentral server to connect to.</p> <ul> <li>ODK_CENTRAL_USER</li> </ul> <p>The user for ODKCentral.</p> <ul> <li>ODK_CENTRAL_PASSWD</li> </ul> <p>The password for ODKCentral.</p> <ul> <li>ODK_CENTRAL_SECURE</li> </ul> <p>If set to False, will allow insecure connections to the ODKCentral API. Else defaults to True.</p>"},{"location":"#using-the-container-image","title":"Using the Container Image","text":"<ul> <li>osm-fieldwork scripts can be used via the pre-built container images.</li> <li>These images come with all dependencies bundled, so are simple to run.</li> </ul> <p>Run a specific command:</p> <pre><code>docker run --rm -v $PWD:/data ghcr.io/hotosm/osm-fieldwork:latest json2osm &lt;flags&gt;\n</code></pre> <p>Run interactively (to use multiple commands):</p> <pre><code>docker run --rm -it -v $PWD:/data ghcr.io/hotosm/osm-fieldwork:latest\n</code></pre> <p>Note: the output directory should always be /data/... to persist data.</p>"},{"location":"#utility-programs","title":"Utility Programs","text":"<p>These programs are more fully documented in this file. This is just a short overview.</p>"},{"location":"#csvdumppy","title":"CSVDump.py","text":"<p>This program converts the data collected from ODK Collect into the proper OpenStreetMap tagging schema. The conversion is controlled by a YAML file, so easy to modify for other projects. The output are two files, one is suitable for OSM,and is in OSM XML format. The other No converted data should ever be uploaded to OSM without validating the conversion in JOSM. To do efficient conversion from ODK to OSM, it's best to use the XLSForm library as templates, as everything is designed to work together.</p>"},{"location":"#basemapperpy","title":"basemapper.py","text":"<p>This program creates basemaps of satellite imagery, and produces files in mbtiles format for ODK Collect and sqlitedb files for Osmand. Imagery basemaps are very useful when the map data is lacking.or in ODK Collect, selecting the current location instead of where you are standing. The basemaps Osmand are very useful of navigation where the map data is lacking. Imagery can be downloaded from ERSI, Bing, USGS Topo maps, or Open Aerial Map</p>"},{"location":"#make_data_extractpy","title":"make_data_extract.py","text":"<p>This program makes data extracts from OpenStreetMap data. Multiple input sources are supported, a local postgresql database, or the HOT maintained Underpass database.</p>"},{"location":"#json2osm","title":"json2osm","text":""},{"location":"#odk2csvpy-odk2geojsonpy-odk2osmpy","title":"odk2csv.py, odk2geojson.py, odk2osm.py","text":"<p>These programs ER used when working offline for extended periods. This converts the ODK XML format on your mobile device into the same CSV format used for submissions downloaded from ODK Central, or the JSON format also from Central.</p>"},{"location":"#odk_clientpy","title":"odk_client.py","text":"<p>This program is a simple command line client to an ODK Central server. This allows you to list projects, appusers, tasks, and submissions. You can also delete projects, tasks, and appusers, but this should only be used by developers as it does direct database access, and you could lose all your data.</p>"},{"location":"#filter_datapy","title":"filter_data.py","text":"<p>This program is used to support humanitariam data models. It extracts the tags and values from the data models document developed by HOT, and compares those to the taginfo database to help fine tune what data goes into OSM or the private output data. This is to not flood OSM with obscure tags that aren't supported by the community. It also filters data extracts so they work with ODK Collect.</p>"},{"location":"#osm2favoritespy","title":"osm2favorites.py","text":"<p>This is a silly program, but it takes a GeoJson file, usually an OSM data extract and generates a GPX file with styling for OsmAnd. This is useful when ground-truthing map data, as it can be used for navigating to those areas.</p>"},{"location":"#best-practices-and-troubleshooting","title":"Best Practices and troubleshooting","text":"<p>To ensure the quality of your converted data, here are some best practices to follow:</p> <ul> <li>Always validate your conversion in JOSM before uploading to OpenStreetMap.</li> </ul> <ul> <li>Use the XLSForm library as templates to ensure that your ODK Collect   data is compatible with the conversion process.</li> </ul> <ul> <li>If you're having trouble with the conversion process, try using the   utility programs included with Osm-Fieldwork to troubleshoot common   issues.</li> </ul> <p>For more info visit the troubleshooting page.</p> <p>By following these best practices and using the utility programs included with Osm-Fieldwork, you can effectively process data collection from ODK into OpenStreetMap format. However, please note that while Osm-Fieldwork has been tested and used in various projects, it is still in active development and may have limitations or issues that need to be resolved.</p>"},{"location":"#xlsform-library","title":"XLSForm library","text":"<p>In the XForms directory is a collection of XLSForms that support the new HOT data models for humanitarian data collection. These cover many categories like healthcare, waterpoints, waste distribution, etc... All of these XLSForms are designed to have an efficient mapper data flow, edit existing OSM data, and support the data models.</p> <p></p> <p>The data models specify the preferred tag values for each data item, with a goal of both tag completeness and tag correctness. Each data item is broken down into a basic and extended survey questions when appropriate.</p>"},{"location":"#what-is-an-xlsform","title":"What is an XLSForm?","text":"<p>An XLSForm is a spreadsheet-based form design tool that allows you to create complex forms for data collection using a simple and intuitive user interface. With XLSForms, you can easily design and test forms on your computer, then deploy them to mobile devices for data collection using ODK Collect or other data collection tools. XLSForms use a simple and structured format, making it easy for you to share and collaborate on form designs with your team or other organizations.</p>"},{"location":"#using-the-xlsform-library-with-osm-fieldwork","title":"Using the XLSForm Library with Osm-Fieldwork","text":"<p>The XLSForms in the XForms directory of the XLSForm Library have been designed to support the HOT data models and have an efficient mapper data flow. These forms also allow for editing of existing OSM data and support the data models, specifying the preferred tag values for each data item with the goal of both tag completeness and tag correctness.</p>"},{"location":"#here-are-some-examples-of-how-to-use-the-xlsform-library-with-osm-fieldwork","title":"Here are some examples of how to use the XLSForm Library with Osm-Fieldwork","text":"<ul> <li>Download an XLSForm from the XForms directory:</li> </ul> <pre><code>wget https://github.com/hotosm/xlsform/raw/master/XForms/buildings.xls\n</code></pre> <ul> <li>Convert the XForm to OSM XML using CSVDump:</li> </ul> <ul> <li>Use the resulting OSM XML file with JOSM or other OSM editors to   validate and edit the data before uploading it to OpenStreetMap.</li> </ul>"},{"location":"#summary","title":"Summary","text":"<p>The XLSForm Library is a valuable resource for organizations involved in humanitarian data collection, as it provides a collection of pre-designed forms that are optimized for efficient mapper data flow and tag completeness/correctness. By using the XLSForm Library with Osm-Fieldwork, you can streamline your data collection process and ensure the quality of your data.</p> <p>Osm-Fieldwork is a powerful tool for processing data collection from ODK into OpenStreetMap format. By following the best practices outlined in this documentation and using the utility programs included with Osm-Fieldwork, you can streamline your data collection process and ensure the quality of your converted data. If you have any questions or issues with osm-fieldwork, please consult the project's documentation or seek support from the project's community.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#0211-2025-03-05","title":"0.21.1 (2025-03-05)","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>remove invalid Accept: \"odkcentral\" header (triggers ModSec 920600) (#348)</li> </ul>"},{"location":"CHANGELOG/#0210-2025-02-24","title":"0.21.0 (2025-02-24)","text":""},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>xlsform: replace form_category with simple form_name</li> </ul>"},{"location":"CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li>remove temp kivy ui (simplify this package)</li> </ul>"},{"location":"CHANGELOG/#0204-2025-02-18","title":"0.20.4 (2025-02-18)","text":""},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>xlsform: remove duplicate save_to field for new_feature + xlocation</li> </ul>"},{"location":"CHANGELOG/#0203-2025-02-17","title":"0.20.3 (2025-02-17)","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>OdkCentralAsync: return pre-signed S3 URLs instead of ODK URL or blob</li> <li>save new_feature geometry to 'geometry' entity field</li> <li>pt-br --&gt; pt-BR correct two letter iana code</li> </ul>"},{"location":"CHANGELOG/#0202-2025-02-14","title":"0.20.2 (2025-02-14)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>rename additional_geometry to be dynamic to allow multiple extra datasets</li> </ul>"},{"location":"CHANGELOG/#0201-2025-02-14","title":"0.20.1 (2025-02-14)","text":""},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>rename additional_geometry to be dynamic to allow multiple extra datasets</li> </ul>"},{"location":"CHANGELOG/#0200-2025-02-12","title":"0.20.0 (2025-02-12)","text":""},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>method to download submission attachment (S3) urls from ODK Central (#342)</li> </ul>"},{"location":"CHANGELOG/#0190-2025-02-11","title":"0.19.0 (2025-02-11)","text":""},{"location":"CHANGELOG/#feat_2","title":"Feat","text":"<ul> <li>add sync OdkForm.getXml to get raw form XML</li> </ul>"},{"location":"CHANGELOG/#0182-2025-01-21","title":"0.18.2 (2025-01-21)","text":""},{"location":"CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li>add default language in settings tab if not present (#336)</li> </ul>"},{"location":"CHANGELOG/#0181-2025-01-15","title":"0.18.1 (2025-01-15)","text":""},{"location":"CHANGELOG/#feat_3","title":"Feat","text":"<ul> <li>add brazilian portguese translation for mandatory fields (#332)</li> </ul>"},{"location":"CHANGELOG/#0180-2025-01-10","title":"0.18.0 (2025-01-10)","text":""},{"location":"CHANGELOG/#feat_4","title":"Feat","text":"<ul> <li>configurable XLSForm new_feature question geometry type (#329)</li> <li>add support for filters in OdkForm get submission media (#330)</li> </ul>"},{"location":"CHANGELOG/#0170-2024-12-25","title":"0.17.0 (2024-12-25)","text":""},{"location":"CHANGELOG/#feat_5","title":"Feat","text":"<ul> <li>add nepali translations to default building form</li> <li>add nepali translation to mandatory fields</li> <li>allow multiple submission ids in a single entity</li> <li>generate mandatory XLS forms programmatically</li> </ul>"},{"location":"CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>nepali yes no choice</li> </ul>"},{"location":"CHANGELOG/#refactor_1","title":"Refactor","text":"<ul> <li>cleanup ancient unused files (#325)</li> </ul>"},{"location":"CHANGELOG/#01612-2024-12-10","title":"0.16.12 (2024-12-10)","text":""},{"location":"CHANGELOG/#fix_7","title":"Fix","text":"<ul> <li>update mandatory xlsform fields logic</li> </ul>"},{"location":"CHANGELOG/#01611-2024-11-28","title":"0.16.11 (2024-11-28)","text":""},{"location":"CHANGELOG/#feat_6","title":"Feat","text":"<ul> <li>XLSForm move photo field outside verification group (#319)</li> <li>calculate coordinates of additional in xlsform entity (#312)</li> <li>sanitize column names to follow defined standards (#313)</li> </ul>"},{"location":"CHANGELOG/#fix_8","title":"Fix","text":"<ul> <li>update labels and entities name in test cases following recent changes in update_xls_form (#317)</li> </ul>"},{"location":"CHANGELOG/#01610-2024-11-06","title":"0.16.10 (2024-11-06)","text":""},{"location":"CHANGELOG/#0169-2024-10-18","title":"0.16.9 (2024-10-18)","text":""},{"location":"CHANGELOG/#fix_9","title":"Fix","text":"<ul> <li>create_if and update_if column in entity sheet (#307)</li> </ul>"},{"location":"CHANGELOG/#0168-2024-09-30","title":"0.16.8 (2024-09-30)","text":""},{"location":"CHANGELOG/#fix_10","title":"Fix","text":"<ul> <li>remove multiple duplicates in choice sheets</li> </ul>"},{"location":"CHANGELOG/#0167-2024-09-24","title":"0.16.7 (2024-09-24)","text":""},{"location":"CHANGELOG/#fix_11","title":"Fix","text":"<ul> <li>xlsform: do not filter duplicates from choices sheet</li> </ul>"},{"location":"CHANGELOG/#0166-2024-09-24","title":"0.16.6 (2024-09-24)","text":""},{"location":"CHANGELOG/#fix_12","title":"Fix","text":"<ul> <li>xlsform: remove 'does not exist' option from digitisation form</li> </ul>"},{"location":"CHANGELOG/#0165-2024-09-23","title":"0.16.5 (2024-09-23)","text":""},{"location":"CHANGELOG/#fix_13","title":"Fix","text":"<ul> <li>mandatory and digitisation xlsform logic</li> </ul>"},{"location":"CHANGELOG/#refactor_2","title":"Refactor","text":"<ul> <li>remove logic for appending task_ids to choices in xlsform</li> </ul>"},{"location":"CHANGELOG/#0165rc0-2024-09-23","title":"0.16.5rc0 (2024-09-23)","text":""},{"location":"CHANGELOG/#fix_14","title":"Fix","text":"<ul> <li>also return the xFormId from append_mandatory_fields, add logs</li> <li>mandatory-fields-xlsform: omit questions on entity preselect, make feature selection mandatory</li> </ul>"},{"location":"CHANGELOG/#refactor_3","title":"Refactor","text":"<ul> <li>small tweak to mandatory fields xlsform</li> </ul>"},{"location":"CHANGELOG/#0164-2024-09-20","title":"0.16.4 (2024-09-20)","text":""},{"location":"CHANGELOG/#fix_15","title":"Fix","text":"<ul> <li>start work matching xlsform translation columns</li> <li>minor fixes to xlsforms, add group to digitisation form</li> <li>append a dummy task_id entry to xlsform if not specified</li> </ul>"},{"location":"CHANGELOG/#refactor_4","title":"Refactor","text":"<ul> <li>refactor update_xlsform for readability + minor bugfixes</li> </ul>"},{"location":"CHANGELOG/#0163-2024-09-19","title":"0.16.3 (2024-09-19)","text":""},{"location":"CHANGELOG/#fix_16","title":"Fix","text":"<ul> <li>common field xlsforms + library combo fully working</li> </ul>"},{"location":"CHANGELOG/#refactor_5","title":"Refactor","text":"<ul> <li>rename fmtm forms --&gt; common forms</li> </ul>"},{"location":"CHANGELOG/#0162-2024-09-18","title":"0.16.2 (2024-09-18)","text":""},{"location":"CHANGELOG/#fix_17","title":"Fix","text":"<ul> <li>handle all XLSForm manuipulation in update_xlsform.py (#299)</li> </ul>"},{"location":"CHANGELOG/#0161-2024-09-16","title":"0.16.1 (2024-09-16)","text":""},{"location":"CHANGELOG/#fix_18","title":"Fix","text":"<ul> <li>made digitisation_correct read_only field (#297)</li> </ul>"},{"location":"CHANGELOG/#0160-2024-09-11","title":"0.16.0 (2024-09-11)","text":""},{"location":"CHANGELOG/#feat_7","title":"Feat","text":"<ul> <li>xlsforms: created separate group verification for digitisation form (#294)</li> </ul>"},{"location":"CHANGELOG/#0150-2024-08-27","title":"0.15.0 (2024-08-27)","text":""},{"location":"CHANGELOG/#feat_8","title":"Feat","text":"<ul> <li>function to append mandatory fields into fmtm custom xls form (#289)</li> <li>created a function to get submission photo by its submission id (#284)</li> </ul>"},{"location":"CHANGELOG/#fix_19","title":"Fix","text":"<ul> <li>Fix writing nodes with no tags, ie... what the way references, and only write the note for ways (#290)</li> <li>don't add the note about duplication, that should be done at a higher level (#287)</li> </ul>"},{"location":"CHANGELOG/#0143-2024-08-08","title":"0.14.3 (2024-08-08)","text":""},{"location":"CHANGELOG/#fix_20","title":"Fix","text":"<ul> <li>regex pattern to find spaces in placeholders of tms url (#283)</li> </ul>"},{"location":"CHANGELOG/#0142-2024-08-05","title":"0.14.2 (2024-08-05)","text":""},{"location":"CHANGELOG/#refactor_6","title":"Refactor","text":"<ul> <li>check if place holders in custom tms url contains any space within (#281)</li> </ul>"},{"location":"CHANGELOG/#0141-2024-07-30","title":"0.14.1 (2024-07-30)","text":""},{"location":"CHANGELOG/#fix_21","title":"Fix","text":"<ul> <li>generating pmtiles with different file extensions, update XLSForm ordering (#278)</li> <li>improve validation for OdkDataset.createDataset properties</li> </ul>"},{"location":"CHANGELOG/#refactor_7","title":"Refactor","text":"<ul> <li>clarify in logs the projectId is for ODK</li> </ul>"},{"location":"CHANGELOG/#0140-2024-07-29","title":"0.14.0 (2024-07-29)","text":""},{"location":"CHANGELOG/#feat_9","title":"Feat","text":"<ul> <li>endpoint to create dataset and bulk upload entities (#276)</li> <li>add support for moving tiles (#272)</li> </ul>"},{"location":"CHANGELOG/#fix_22","title":"Fix","text":"<ul> <li>Add support for ways when importing an OSM XML file (#275)</li> <li>Fix typo, usfs not usgs, add quering the relations table (#274)</li> </ul>"},{"location":"CHANGELOG/#0130-2024-07-12","title":"0.13.0 (2024-07-12)","text":""},{"location":"CHANGELOG/#fix_23","title":"Fix","text":"<ul> <li>update xlsforms to hide required choices tab values</li> <li>add minzoom and maxzoom params to basemapper to allow view past zoom 18 (#267)</li> <li>self.data is now a list to be consistent with the other parsers (#264)</li> </ul>"},{"location":"CHANGELOG/#refactor_8","title":"Refactor","text":"<ul> <li>delete unused scripts and update the docs (#269)</li> <li>remove test_conflation prior to odk_merge drop</li> </ul>"},{"location":"CHANGELOG/#0124-2024-06-20","title":"0.12.4 (2024-06-20)","text":""},{"location":"CHANGELOG/#fix_24","title":"Fix","text":"<ul> <li>final fix to xlsforms, remove 'essential' group for entity by intent</li> </ul>"},{"location":"CHANGELOG/#0123-2024-06-20","title":"0.12.3 (2024-06-20)","text":""},{"location":"CHANGELOG/#fix_25","title":"Fix","text":"<ul> <li>bug where task_id filter did not work on xlsforms</li> </ul>"},{"location":"CHANGELOG/#0122-2024-06-20","title":"0.12.2 (2024-06-20)","text":""},{"location":"CHANGELOG/#fix_26","title":"Fix","text":"<ul> <li>xlsform separate task_filter and task_id fields</li> </ul>"},{"location":"CHANGELOG/#0121-2024-06-19","title":"0.12.1 (2024-06-19)","text":""},{"location":"CHANGELOG/#fix_27","title":"Fix","text":"<ul> <li>update entity xlsforms with working save_to field for status</li> <li>json2osm invalid merge, fix syntax</li> </ul>"},{"location":"CHANGELOG/#0120-2024-06-19","title":"0.12.0 (2024-06-19)","text":""},{"location":"CHANGELOG/#feat_10","title":"Feat","text":"<ul> <li>in memory BytesIO GeoJSON for boundary param basemapper (#261)</li> </ul>"},{"location":"CHANGELOG/#fix_28","title":"Fix","text":"<ul> <li>remove groups from xlsforms (essential, verification), entity breakage</li> </ul>"},{"location":"CHANGELOG/#0112-2024-06-10","title":"0.11.2 (2024-06-10)","text":""},{"location":"CHANGELOG/#fix_29","title":"Fix","text":"<ul> <li>make digitization_correct question mandatory</li> </ul>"},{"location":"CHANGELOG/#0111-2024-06-07","title":"0.11.1 (2024-06-07)","text":""},{"location":"CHANGELOG/#fix_30","title":"Fix","text":"<ul> <li>rename healthcare.xls form to health.xls (osm tag = healthcare)</li> <li>bug in CSVDump where parsing fails if value is None</li> </ul>"},{"location":"CHANGELOG/#0110-2024-06-05","title":"0.11.0 (2024-06-05)","text":""},{"location":"CHANGELOG/#feat_11","title":"Feat","text":"<ul> <li>update buildings xlsform &amp; add healthcare entity form</li> <li>add support for select_multiple in XLSForms (#257)</li> </ul>"},{"location":"CHANGELOG/#fix_31","title":"Fix","text":"<ul> <li>improve Amenities XLSForm &amp; data model (#256)</li> </ul>"},{"location":"CHANGELOG/#0102-2024-05-24","title":"0.10.2 (2024-05-24)","text":""},{"location":"CHANGELOG/#fix_32","title":"Fix","text":"<ul> <li>add support to optionally append to the mbtiles file (#255)</li> </ul>"},{"location":"CHANGELOG/#0101-2024-05-24","title":"0.10.1 (2024-05-24)","text":""},{"location":"CHANGELOG/#fix_33","title":"Fix","text":"<ul> <li>replace entity buildings.xls to allow top level entity loading</li> </ul>"},{"location":"CHANGELOG/#0100-2024-05-22","title":"0.10.0 (2024-05-22)","text":""},{"location":"CHANGELOG/#feat_12","title":"Feat","text":"<ul> <li>add support for geotrace (#254)</li> </ul>"},{"location":"CHANGELOG/#fix_34","title":"Fix","text":"<ul> <li>tile id extraction for pmtiles correct x/y ordering</li> </ul>"},{"location":"CHANGELOG/#092-2024-04-29","title":"0.9.2 (2024-04-29)","text":""},{"location":"CHANGELOG/#fix_35","title":"Fix","text":"<ul> <li>remove notes column from entities sheet (pyxform error)</li> </ul>"},{"location":"CHANGELOG/#091-2024-04-26","title":"0.9.1 (2024-04-26)","text":""},{"location":"CHANGELOG/#fix_36","title":"Fix","text":"<ul> <li>update buildings form, show all features unless task selected</li> </ul>"},{"location":"CHANGELOG/#090-2024-04-23","title":"0.9.0 (2024-04-23)","text":""},{"location":"CHANGELOG/#feat_13","title":"Feat","text":"<ul> <li>create new entities-based xlsforms for registration/buildings</li> </ul>"},{"location":"CHANGELOG/#refactor_9","title":"Refactor","text":"<ul> <li>move existing xlsforms to archived dir (replace with entities)</li> </ul>"},{"location":"CHANGELOG/#082-2024-04-19","title":"0.8.2 (2024-04-19)","text":""},{"location":"CHANGELOG/#fix_37","title":"Fix","text":"<ul> <li>add error handling if connecting to OdkCentral fails</li> <li>improve handling if entities fail during bulk upload</li> </ul>"},{"location":"CHANGELOG/#081-2024-04-15","title":"0.8.1 (2024-04-15)","text":""},{"location":"CHANGELOG/#fix_38","title":"Fix","text":"<ul> <li>add missing OdkEntity.getEntity method for get by uuid</li> </ul>"},{"location":"CHANGELOG/#080-2024-04-12","title":"0.8.0 (2024-04-12)","text":""},{"location":"CHANGELOG/#feat_14","title":"Feat","text":"<ul> <li>support odata filters for OdkEntity.getEntityData</li> <li>add OdkEntity.getEntityCount method to get total entities</li> </ul>"},{"location":"CHANGELOG/#refactor_10","title":"Refactor","text":"<ul> <li>improve typing, docstrings, logging for OdkCentralAsync</li> <li>update logging during OdkCentral.OdkForm form creation</li> </ul>"},{"location":"CHANGELOG/#072-2024-04-11","title":"0.7.2 (2024-04-11)","text":""},{"location":"CHANGELOG/#fix_39","title":"Fix","text":"<ul> <li>revert broken basemapper.py and tests</li> </ul>"},{"location":"CHANGELOG/#071-2024-04-11","title":"0.7.1 (2024-04-11)","text":""},{"location":"CHANGELOG/#fix_40","title":"Fix","text":"<ul> <li>update entities registration form to include status field</li> <li>remove usage of requests from validate.py in prep for dep removal</li> </ul>"},{"location":"CHANGELOG/#refactor_11","title":"Refactor","text":"<ul> <li>remove missed print statements from OdkCentralAsync</li> </ul>"},{"location":"CHANGELOG/#070-2024-04-03","title":"0.7.0 (2024-04-03)","text":""},{"location":"CHANGELOG/#feat_15","title":"Feat","text":"<ul> <li>add OdkCentralAsync for async entities workflow (#253)</li> </ul>"},{"location":"CHANGELOG/#fix_41","title":"Fix","text":"<ul> <li>only get cpu cores in getAllSubmissions method</li> </ul>"},{"location":"CHANGELOG/#061-2024-03-25","title":"0.6.1 (2024-03-25)","text":""},{"location":"CHANGELOG/#fix_42","title":"Fix","text":"<ul> <li>add standardised entity registration form</li> </ul>"},{"location":"CHANGELOG/#060-2024-03-24","title":"0.6.0 (2024-03-24)","text":""},{"location":"CHANGELOG/#feat_16","title":"Feat","text":"<ul> <li>v1 entities implementation in OdkCentral.py (#245)</li> </ul>"},{"location":"CHANGELOG/#refactor_12","title":"Refactor","text":"<ul> <li>use logger.basicConfig for verbose flag (#244)</li> </ul>"},{"location":"CHANGELOG/#054-2024-03-19","title":"0.5.4 (2024-03-19)","text":""},{"location":"CHANGELOG/#fix_43","title":"Fix","text":"<ul> <li>updated the error message for invalid odk-credentials (#241)</li> <li>method to update review state of submission (#236)</li> </ul>"},{"location":"CHANGELOG/#053-2024-03-05","title":"0.5.3 (2024-03-05)","text":""},{"location":"CHANGELOG/#fix_44","title":"Fix","text":"<ul> <li>odk: upload media failing validation if extension stripped accidentally</li> <li>argparse parsing of bbox string</li> <li>default outdir to current working dir</li> <li>optional bbox as space separated and comma separated</li> <li>add correct typing for bbox var and return types</li> </ul>"},{"location":"CHANGELOG/#052-2024-03-04","title":"0.5.2 (2024-03-04)","text":""},{"location":"CHANGELOG/#fix_45","title":"Fix","text":"<ul> <li>regression: upload Media uploading test data instead of real data</li> </ul>"},{"location":"CHANGELOG/#051-2024-02-29","title":"0.5.1 (2024-02-29)","text":""},{"location":"CHANGELOG/#fix_46","title":"Fix","text":"<ul> <li>rename form_fields --&gt; formFields and handle all http errors (#230)</li> </ul>"},{"location":"CHANGELOG/#050-2024-02-28","title":"0.5.0 (2024-02-28)","text":""},{"location":"CHANGELOG/#feat_17","title":"Feat","text":"<ul> <li>add media upload filename validation against xform</li> <li>allow passing bytesio object for createForm &amp; uploadMedia</li> <li>add media upload filename validation against xform</li> <li>allow passing bytesio object for createForm &amp; uploadMedia</li> </ul>"},{"location":"CHANGELOG/#fix_47","title":"Fix","text":"<ul> <li>minor fixes to OdkForm</li> <li>mediaUpload for xform geojson</li> <li>return form name regardless of if exists or not</li> <li>minor fixes to OdkForm</li> <li>mediaUpload for xform geojson</li> <li>return form name regardless of if exists or not</li> </ul>"},{"location":"CHANGELOG/#044-2024-02-26","title":"0.4.4 (2024-02-26)","text":""},{"location":"CHANGELOG/#fix_48","title":"Fix","text":"<ul> <li>do not index xform path for form name</li> </ul>"},{"location":"CHANGELOG/#043-2024-02-26","title":"0.4.3 (2024-02-26)","text":""},{"location":"CHANGELOG/#fix_49","title":"Fix","text":"<ul> <li>more flexible parsing of xform name for uploadMedia</li> </ul>"},{"location":"CHANGELOG/#043rc0-2024-02-13","title":"0.4.3rc0 (2024-02-13)","text":""},{"location":"CHANGELOG/#fix_50","title":"Fix","text":"<ul> <li>error handling in submission downloadThread (#227)</li> </ul>"},{"location":"CHANGELOG/#042-2024-01-30","title":"0.4.2 (2024-01-30)","text":""},{"location":"CHANGELOG/#fix_51","title":"Fix","text":"<ul> <li>update OdkAppUser qrcode &amp; create methods</li> <li>replace HTTPBasicAuth with session tokens</li> <li>return types for OdkCentral submission methods</li> <li>work with wildcsrds with spaces</li> <li>Add tile filespec if it's an empty image</li> </ul>"},{"location":"CHANGELOG/#041-2024-01-18","title":"0.4.1 (2024-01-18)","text":""},{"location":"CHANGELOG/#fix_52","title":"Fix","text":"<ul> <li>For ODK, make sure there is always a label &amp; title</li> <li>Fix logging, and fix polygon vs centroid</li> <li>Be less verbose with debugging</li> <li>Improve the values for the tags so it actually works</li> <li>Add filter_data api doc</li> </ul>"},{"location":"CHANGELOG/#refactor_13","title":"Refactor","text":"<ul> <li>return full submissions detail</li> <li>add param debug log during basemap generation</li> </ul>"},{"location":"CHANGELOG/#040-2023-12-05","title":"0.4.0 (2023-12-05)","text":""},{"location":"CHANGELOG/#feat_18","title":"Feat","text":"<ul> <li>basic kivy ui to download basemaps</li> </ul>"},{"location":"CHANGELOG/#fix_53","title":"Fix","text":"<ul> <li>Fix merge conflict</li> <li>Make sure ref exists before trying to use it from a dict</li> <li>Add default variables</li> </ul>"},{"location":"CHANGELOG/#038-2023-11-18","title":"0.3.8 (2023-11-18)","text":""},{"location":"CHANGELOG/#fix_54","title":"Fix","text":"<ul> <li>Make less verbose</li> <li>Always escape the value for embedded quotes</li> <li>Fix bug with referencing an out of scope variable</li> <li>Use geojson instead of json to read in the boundary file</li> <li>Don't call OsmFile.footer, it's now handled by a destructor</li> <li>Add link to XLSForm design doc</li> </ul>"},{"location":"CHANGELOG/#037-2023-10-23","title":"0.3.7 (2023-10-23)","text":""},{"location":"CHANGELOG/#fix_55","title":"Fix","text":"<ul> <li>Add simple test case for creating imagery basemaps</li> <li>Accumulate all tiles for all zoom levels</li> <li>Use boundary file that is a single Feature in addition to a FeatureCollection</li> <li>Pass the config file to the YAML parser</li> <li>Add USGS reference numbers for highways</li> <li>custom tms download logic (tile ordering)</li> <li>bug pmtile generation if file exists in first dir</li> <li>create basemap directory automatically</li> </ul>"},{"location":"CHANGELOG/#036-2023-10-09","title":"0.3.6 (2023-10-09)","text":""},{"location":"CHANGELOG/#fix_56","title":"Fix","text":"<ul> <li>update all data-models to latest osm-rawdata syntax</li> <li>update indexes for xlsforms and data_models</li> <li>update xlsforms index</li> </ul>"},{"location":"CHANGELOG/#refactor_14","title":"Refactor","text":"<ul> <li>update rootdir refs to variables</li> </ul>"},{"location":"CHANGELOG/#036rc3-2023-10-09","title":"0.3.6rc3 (2023-10-09)","text":""},{"location":"CHANGELOG/#fix_57","title":"Fix","text":"<ul> <li>Merge in rawdata branch</li> <li>Drop extraneous parameter</li> <li>Set title and label always</li> <li>Use the right path to the xforms library</li> <li>Add name and name:em to keep</li> <li>xlocation accepted in the conflation if present</li> <li>Update for current reality, andd a few more programs</li> <li>Update doc to match code changes</li> <li>Add make_data_extract API doc</li> <li>Improve how the boundary gets parese dand passed as a parameter</li> <li>Use the new config class instead of parsing the YAML file</li> <li>ikport uriParser</li> <li>Enale logging</li> </ul>"},{"location":"CHANGELOG/#036rc2-2023-09-11","title":"0.3.6rc2 (2023-09-11)","text":""},{"location":"CHANGELOG/#fix_58","title":"Fix","text":"<ul> <li>json2osm handle polygons and points (#192)</li> <li>Update raw-osmdata to 0.1.1</li> <li>add osm-rawdata dependency</li> <li>Major refactoring to use the new osm-rawdata module</li> <li>Add join_or tag which is now required in the enhanced YAML format</li> <li>Use optional env variable for the raw data API</li> <li>initialize variable</li> <li>Arg, change the raw data URI again</li> <li>json2osm calling via api</li> <li>The URL for raw data has changed</li> <li>Add config file for waterways</li> </ul>"},{"location":"CHANGELOG/#036rc1-2023-09-07","title":"0.3.6rc1 (2023-09-07)","text":""},{"location":"CHANGELOG/#fix_59","title":"Fix","text":"<ul> <li>json2osm via cmdline + programatically</li> </ul>"},{"location":"CHANGELOG/#036rc0-2023-09-01","title":"0.3.6rc0 (2023-09-01)","text":""},{"location":"CHANGELOG/#feat_19","title":"Feat","text":"<ul> <li>complete overhaul of docs, mkdocstrings</li> </ul>"},{"location":"CHANGELOG/#fix_60","title":"Fix","text":"<ul> <li>csv parsing for test</li> <li>Delete the UML images for clean</li> <li>Generate PDFs from the primary markdown files in docs/about</li> <li>Drop unused main.py file</li> <li>Add support for doxygen API docs</li> <li>fix typo in url for data flow diagram</li> <li>Add new data flow charts</li> <li>Use new imagery.yaml file for sources instead of hardcoding them all</li> <li>Add USGS topo map as a source</li> <li>Improve parsing to cover more than one format</li> <li>Add support for a custom TMS URL</li> <li>Add missing test data file</li> <li>Improve processing of Rwanda submissions, capture OSM ID and improve the conversion config file</li> <li>list forms api</li> <li>filespec made optional in the filterdata class</li> <li>text 78 was present, it is now removed</li> <li>indentation on odk_merge</li> <li>typing issues and imports</li> <li>Fix listForms(), the parameter name changed</li> <li>Add trailing comma to all function parameter blocks</li> <li>Add the deep tech docs</li> <li>fix typo in parameter name</li> <li>Add the more obscure utilities to the API docs</li> <li>Add more API wrappers</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Fix broken indent in debugging code, it was only being executed with -v</li> <li>Add standalone script for osm2favorites</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Add mkdocs comments</li> <li>Add mkdocs code comments</li> <li>Add bash wrapper for basemapper.py</li> <li>Update a few mkdocs comments so mkdocs serve is happy</li> <li>Minor updates to mkdoc comment, fix indentation</li> <li>Add mkdocs code comments</li> <li>Add more docs, organize top level links</li> <li>Replace lines of code that got deleted by accident</li> <li>Add mkdoc strings</li> <li>creating a project that already exists</li> <li>Add pySmartDL</li> </ul>"},{"location":"CHANGELOG/#refactor_15","title":"Refactor","text":"<ul> <li>update refs logging --&gt; log</li> <li>remove mkgendocs config</li> </ul>"},{"location":"CHANGELOG/#035-2023-08-11","title":"0.3.5 (2023-08-11)","text":""},{"location":"CHANGELOG/#fix_61","title":"Fix","text":"<ul> <li>Add mercantile</li> <li>indentation error in basemapper</li> </ul>"},{"location":"CHANGELOG/#034-2023-08-06","title":"0.3.4 (2023-08-06)","text":""},{"location":"CHANGELOG/#feat_20","title":"Feat","text":"<ul> <li>get extended details of a project</li> <li>get form full details</li> <li>Handle geometries better in the other json variant from Central</li> </ul>"},{"location":"CHANGELOG/#fix_62","title":"Fix","text":"<ul> <li>Improve methods to test data contents for tags</li> <li>Add more real tests</li> <li>conflateThread() takes an additional argument now</li> <li>Add some real tests for conversion</li> <li>Add test data for JSON to OSM conversion</li> <li>disable warnings from depenancies when running pytest</li> <li>getAllSubmissions() now takes an optional argument, which is the list of XForms</li> <li>Use flatfic module instead of traversing it ourselves</li> <li>comment out debug message</li> <li>handle uid/user in attrs better</li> <li>add flatdict module</li> <li>use a flattened dictionary instead of traversing everything ourselves</li> <li>use lower case for string matching, it's faster than fuzzy matching</li> <li>Minor update</li> <li>all tags should be in lower case</li> <li>if node is not present, return False in loadFIle in osmfile class</li> <li>load file in osmfile class</li> <li>no of threads missing some data at the end</li> <li>Add comment on commented out code block</li> <li>Drop escaping - in regex</li> <li>Trap bad auth with the ODK Central server</li> <li>Add timer to see how long it takes to process the data</li> <li>Add support to download all submissions for all tasks in a project</li> <li>Remove large block of commented out code</li> <li>Add support to download all submissions for all tasks in a project</li> <li>main, not moon</li> <li>Add new XLSForm for highways</li> <li>chunk set to 1 when the chunk value is 1</li> <li>fix indenting mistake that prevented display forms</li> <li>Add support to the underpass query to return linestrings</li> <li>Add support for highways</li> <li>handle XLSForms that don't use a data extract</li> <li>Add support for highways</li> <li>highways use ways_line, not ways_poly</li> <li>Add config file for highway query</li> </ul>"},{"location":"CHANGELOG/#033-2023-07-25","title":"0.3.3 (2023-07-25)","text":""},{"location":"CHANGELOG/#fix_63","title":"Fix","text":"<ul> <li>uncomment my stupid mistakes</li> <li>Add the new conflatin doc to the sidebar</li> <li>Add doc on how this project does conflation</li> <li>fix minor type</li> <li>Add make_data_extract to scripts</li> <li>Add more content</li> <li>Now that there are multiple postgres connections, clip all of them</li> <li>Handle no data returned errors</li> <li>Addd main() so it can be called when run standalone</li> <li>Add standalone scripts so all programs can be run from the install package</li> <li>Fix type in maion</li> <li>make a main function to they can run standalone</li> <li>Add a main function to this can run standalone from the installed python package</li> <li>Add new user manual to the sidebar</li> <li>Add new user manual</li> <li>Refactor to use an array of database connections, one for each thread to avoid proble</li> <li>Not all data has a timestamp, and it gets set anyone to the current time</li> <li>Major refactoring to support conflation with either postgis or the data extract used for FMTM</li> <li>keep more tags for the output file</li> <li>add more tags to keep for the output file</li> <li>Add newline after writing </li> <li>Add government_menu to ignore</li> <li>Add tests for conflating with a database</li> <li>Add test prpoject boundary</li> <li>Improve test cases so they can find the test data files under pytest</li> <li>Update test data, and add test case for odk_merge</li> <li>Add section on importing the data into postgres</li> <li>use log so it works in FMTM, get the feature version in SQL queries</li> <li>Add support for using a GeoJson data extract as the conflation source</li> <li>Implement writing the OSM XML output file</li> <li>There are weird capitalization in the keywords</li> <li>Put the modified warning in a note instead of fixme</li> <li>Handle errors if there is no forms or project</li> <li>handle xlsfile better</li> <li>osmfile.footer() is now called by a destructor</li> <li>Don't escape spaces</li> <li>Implement conflating a POI against ways</li> <li>Add a destructor so the footer gets added when class is deleted</li> <li>Make output file optional</li> <li>Conversion from gdal is done, startin gto implement threads</li> <li>output files go into current dir, not /tmp</li> <li>escape is now a standalone function</li> <li>Make infile a required argument</li> <li>escape is now a standalone function so it can be used by other classes</li> <li>Update test cases since now data files get installed</li> <li>Add function for parsing database URIs, add test case for URI parser</li> <li>parse the OSM XML file if the data is in a dict</li> <li>THis gets processed lower down, so this is duplicate code</li> <li>Don't pass bogus config file</li> <li>Fix support to use Google imagery</li> <li>Fix support for bing imagery</li> <li>Update section on setting the default in Collect from OSM data</li> <li>Drop outfile from calling PostgresClient()</li> <li>Add roof:shape and roof:levels to keep</li> <li>Add shop to keep</li> </ul>"},{"location":"CHANGELOG/#032-2023-06-27","title":"0.3.2 (2023-06-27)","text":""},{"location":"CHANGELOG/#fix_64","title":"Fix","text":"<ul> <li>Convert the currt JSON format as downloaded from FMTM</li> <li>Fix processing of the ignore section</li> <li>Always write the value as a sting</li> <li>Remove the sldes.xls file</li> <li>Also use an optional user and password for database access</li> </ul>"},{"location":"CHANGELOG/#031-2023-06-21","title":"0.3.1 (2023-06-21)","text":""},{"location":"CHANGELOG/#fix_65","title":"Fix","text":"<ul> <li>For polygons in the data file, just use the centroids</li> <li>Add one to the ending zoom level so range() stops loosing the last zoom level</li> <li>Display usage() if no arguments are given</li> <li>Add qualifiers to limit the shops that get returned</li> </ul>"},{"location":"CHANGELOG/#031rc2-2023-06-01","title":"0.3.1rc2 (2023-06-01)","text":""},{"location":"CHANGELOG/#fix_66","title":"Fix","text":"<ul> <li>Add utility that generates a fovorites file for Osmand</li> <li>Trap error for no output file and print usage()</li> <li>Add accuracy to ignore section</li> <li>Fix message in usage</li> <li>Added Osmand extensions for styling the favorites</li> <li>Write GPX file with Osmand specific styling</li> <li>Convert a GeoJson file into a favorites.gpx file for Osmand complete with all the tags</li> <li>Delete geometry tag from input datata stream so it doesn't casue confusion later</li> <li>Add support for processing either GeoJson (usually from odk2geojson) or JSON from Central</li> <li>Make timestamp for filename longer</li> <li>Change gosm to osm-fieldwork. Oops</li> <li>New program that converts the ODK XML instance files off your phone and turns it into good GeoJson for JOSM</li> <li>Disable debug message</li> <li>Major refactoring, it actually works now</li> <li>Always grab all the submissions</li> </ul>"},{"location":"CHANGELOG/#refactor_16","title":"Refactor","text":"<ul> <li>improve logging for OdkCentral + createProject</li> </ul>"},{"location":"CHANGELOG/#031rc1-2023-05-18","title":"0.3.1rc1 (2023-05-18)","text":""},{"location":"CHANGELOG/#fix_67","title":"Fix","text":"<ul> <li>xform in getSubmissions function</li> <li>output file in osm extracts</li> <li>add a default value</li> <li>use type for parameters to methods</li> <li>Use type for all parameters to methods</li> <li>conversion now returns a dict</li> <li>Remove accidental map-icons submodule, use types with all method parameters</li> <li>Drop paren</li> <li>Use line not linestring as a type, turn data into a dict from queryRemote()</li> <li>Default to using the underpass database for raw OSM data</li> <li>Remove debug message</li> <li>Add XLSForms for camping and small town amenity mapping</li> <li>Changes made while camping, mostly minor tweaks</li> <li>Remove stamp file</li> <li>Extract the metadata from the XLSForm</li> <li>Use the warmup location if there isn't one for the geopoint</li> <li>Add json as an input source</li> <li>Download the josn file of submissions from Central</li> <li>add more tags to ignore</li> <li>Process the json file from Central and write OSM XML and Geojsaon files</li> <li>return a dict instead of a list</li> <li>Convert the JSON fike from ODATA into OSM</li> <li>Process the defaults from the XLSFile</li> <li>process all rows to get the fields, as not all files have the same ones</li> <li>COnvert openfire tpo leisure=firepit, which is more common</li> <li>If the extract would be empty, write dummy entry so ODK Collect will still launch</li> <li>Fix logging</li> <li>Write dummy geojson file if there ios nothing in the extract</li> <li>fix logging setup, readoing CSV file</li> <li>use yaml as the config file if it exists</li> <li>Add support for generating variants of an XLSForm</li> <li>Add new non humanitarian XLSForms</li> <li>add support for amenities XLSForm</li> <li>Update the column names in all XLSForms to use the same name so they can all be scanned for the title and ID</li> <li>Add config file for amenities</li> <li>Add XLSForm for historical sites</li> <li>When querying a local database, collect all results</li> <li>Add support for new camping form</li> <li>refactor the groups of survey questions</li> <li>Add OSM map-icons as submodule</li> <li>fix typo in comment</li> </ul>"},{"location":"CHANGELOG/#031rc0-2023-05-04","title":"0.3.1rc0 (2023-05-04)","text":""},{"location":"CHANGELOG/#fix_68","title":"Fix","text":"<ul> <li>got queryLocal(), get all the nodes and ways</li> <li>Process ODK_CENTRAL_SECURE correctly as the value from the end is a string, but the default is a bool</li> <li>Updates to layout, play with fancy colors</li> <li>Add method to extract the data extract filename, the XLSFOrm ID, and the XLSForm title from the spreadsheet</li> <li>Make default values work so we don't break the FMTM frontend</li> <li>Add content about name conflicts when using data extracts</li> <li>delete downloaded zip file after extracting the data file</li> <li>Implement uploading to Central</li> <li>minor changes</li> <li>Fix xform target and suffix rules to work with the name changes to avoid conflicts with OSM tags</li> <li>rename to avoid name conflict with OSM tag</li> <li>Fix typo in keyword</li> <li>Rename place to places to avoid a name conflict with an OSM tag</li> <li>when run standalone, the xform doesn't have to be changed, and fix wrong error message</li> <li>Updated so all the columns are in the same order, cleanup high lighting</li> <li>minor formatting changes</li> <li>rename t oplaces to avoid a conflict with the OSM place tag</li> <li>The yaml config filenane should match the xlsform, not the category</li> <li>rename file to avoid a nanme conflict with healthcare OSM tag</li> <li>Extract the XForm title and the name of the data extract from the XLSFoem</li> <li>Filter the types of waste amenities wanted, otherwise we get all amenities</li> <li>Rename to avoid naming conflicts with an OSM tag</li> <li>Rename natural to nature to avoid name conflicts with OSM</li> <li>Make the XLSForm for a category configurable via a YAML file to avoid name conflicts</li> <li>renamed to avoid a name conflict with the waste OSM tag</li> <li>rename landuse.yaml to landusage to avoid a name conflict with the landuse tag</li> <li>Add support to generate data extracts for all categories for testing</li> <li>rename landude.xls to landusage so the name doesn't conflict with the tag</li> <li>Update to support OSM data extracts, a few tewaks for the data models</li> <li>Add tag values to json file for remote database queries</li> <li>Improve command line for polygon vs centroid</li> <li>Enable reding tags to keep from yaml file</li> <li>Optionally output polygons instead of centroids when using a local postgres database</li> <li>Use python package to find xforms.yaml file</li> <li>Fix test cases to work with pythohn package</li> <li>add healthcare_type</li> <li>use list_name with an underbar instead of space</li> <li>Updated to support data extracts</li> <li>Make the OSM tags to keep configurable in the yaml file</li> <li>When reading an environment variable that is a boolean, convert the string to a bool</li> <li>Add nsupport to extract either polygons of centroids. Add boundary polygon to the extract</li> <li>Support a option to specify the path to the taginfo db and output csv</li> <li>Update file with YAML file syntax and examples</li> <li>Update docs, some content pulled into new files</li> <li>Refacor the programs.md file, move large detailed content into there own files</li> </ul>"},{"location":"CHANGELOG/#020-2023-03-31","title":"0.2.0 (2023-03-31)","text":""},{"location":"CHANGELOG/#feat_21","title":"Feat","text":"<ul> <li>rename repo odkconvert --&gt; osm-fieldwork</li> </ul>"},{"location":"CHANGELOG/#fix_69","title":"Fix","text":"<ul> <li>For querying Overpass, use either a file or a geojson dict</li> <li>fix merge conflicts</li> <li>Merge documentation changes from development branch</li> <li>modified all files, replacing odkconvert wth osm-fieldwork</li> <li>Add overpy</li> <li>Minor typo fix</li> <li>Refactor and update</li> </ul>"},{"location":"CHANGELOG/#011-2023-03-29","title":"0.1.1 (2023-03-29)","text":""},{"location":"CHANGELOG/#fix_70","title":"Fix","text":"<ul> <li>Refactor and update</li> </ul>"},{"location":"CHANGELOG/#010-2023-03-25","title":"0.1.0 (2023-03-25)","text":""},{"location":"CHANGELOG/#feat_22","title":"Feat","text":"<ul> <li>set ssl verify via environment variable, default true</li> <li>option to configure standalone odkconvert via env vars</li> <li>index for xform files, plus path</li> </ul>"},{"location":"CHANGELOG/#fix_71","title":"Fix","text":"<ul> <li>update logging</li> <li>listProjects and findAppUser methods for OdkCentral, update logging</li> <li>relative imports --&gt; absolute imports for packaging</li> <li>update verify=True for urllib to verify certs</li> <li>allow listProjects to fail gracefully if none exist</li> <li>typo for religious</li> <li>makefile zip bundle, pyproject version attr</li> <li>update paths for xforms.yaml, fix CSVDump.parse</li> </ul>"},{"location":"CHANGELOG/#refactor_17","title":"Refactor","text":"<ul> <li>rename xforms to xlsforms throughout code</li> <li>rename xform dir to xlsform, more descriptive</li> <li>rename xforms path var for clarity</li> <li>remove redundant csv output files from xforms</li> <li>update refs to xforms dir and odk_client.py</li> <li>rename XForms dir to lowercase xforms</li> <li>add includes to pyproject to bundle odkconvert dir</li> <li>missed yaml file for restructure</li> <li>rename test dir to pytest default (tests)</li> <li>restructure, move .py files to odkconvert dir</li> </ul>"},{"location":"Code-of-Conduct/","title":"Code of conduct","text":"<p>(The latest version can be found at https://www.hotosm.org/code-of-conduct)</p> <p>Welcome to Humanitarian OpenStreetMap Team. HOT is committed to providing a welcoming and safe environment for people of all races, gender identities, gender expressions, sexual orientations, physical abilities, physical appearances, socio-economic backgrounds, nationalities, ages, religions, and beliefs.</p> <p>The HOT community principles are:</p> <p>Be friendly and patient. Be generous and kind in both giving and accepting critique. Critique is a natural and important part of our culture. Good critiques are kind, respectful, clear, and constructive, focused on goals and requirements rather than personal preferences. You are expected to give and receive criticism with grace. Be considerate in speech and actions, and actively seek to acknowledge and respect the boundaries of fellow attendees.</p> <p>Be welcoming. We strive to be a community that welcomes and supports people of all backgrounds and identities. Some examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language.</li> </ul> <ul> <li>Being respectful of differing viewpoints and experiences.</li> </ul> <ul> <li>Gracefully accepting constructive criticism.</li> </ul> <ul> <li>Showing empathy towards other community members.</li> </ul> <ul> <li>Placing collective interest before your own interest.</li> </ul> <p>Be considerate. Your work will be used by other people, and you in turn will depend on the work of others. Any decision you take will affect users and colleagues, and you should take those consequences into account when making decisions. Remember that we're a world-wide community, so you might not be communicating in someone else's primary language.</p> <p>Be respectful. Not all of us will agree all the time, but disagreement is no excuse for poor behavior and poor manners. We might all experience some frustration now and then, but we cannot allow that frustration to turn into a personal attack. It\u2019s important to remember that a community where people feel uncomfortable or threatened is not a productive one. Members of the HOT community should be respectful when dealing with other members as well as with people outside the HOT community.</p> <p>Be careful in your word choice. We are a global community of professionals, and we conduct ourselves professionally. Be kind to others. Do not insult or put down other participants. Harassment and other exclusionary behavior aren't acceptable. This includes, but is not limited to:</p> <ul> <li>Violent threats or language directed against another person.</li> </ul> <ul> <li>Discriminatory jokes and language.</li> </ul> <ul> <li>Posting sexually explicit or violent material.</li> </ul> <ul> <li>Posting (or threatening to post) other people's personally identifying information (\"doxing\").</li> </ul> <ul> <li>Personal insults, especially those using racist or sexist terms.</li> </ul> <ul> <li>Unwelcome sexual attention.</li> </ul> <ul> <li>Advocating for, or encouraging, any of the above behavior.</li> </ul> <ul> <li>Repeated harassment of others. In general, if someone asks you to stop, then stop.</li> </ul> <p>Assume all communications are positive. Always remain polite, and assume good faith. It is surprisingly easy to misunderstand each other, be it online or in person, particularly in such a culturally diverse setting as ours. Misunderstandings are particularly easy to arise when we are in a rush, or otherwise distracted. Please ask clarifying questions before assuming that the communication was inappropriate.</p> <p>When we disagree, try to understand why. Disagreements, both social and technical, happen easily and often. It is important that we resolve such disagreements and differing views constructively. At times it can be hard to appreciate a viewpoint that contradicts your own perceptions. Instead of pushing back, try to understand where the other person is coming from, and don\u2019t be afraid to ask questions. You can be most helpful if your own replies serve to clarify, rather than to escalate an issue. Also don\u2019t forget that it can be easy to make mistakes, and allow for the possibility that the mistake may have been yours. When this happens it is better to resolve the issue together, and to learn from the experience together, than to place blame.</p> <p>Original text courtesy of the Speak Up! project.</p> <p>Further sources:</p> <ul> <li>Ada Initiative: HOWTO design a code of conduct for your community</li> </ul> <ul> <li>Algorithm Club Code of Conduct</li> </ul> <ul> <li>American Red Cross GIS Team Code of Conduct</li> </ul> <ul> <li>Contributor Covenant \u2013 A Code of Conduct for Open Source Projects</li> </ul> <ul> <li>Django Code of Conduct</li> </ul> <ul> <li>Mozilla Community Participation Guidelines</li> </ul> <ul> <li>Vox Media Code of Conduct</li> </ul>"},{"location":"Code-of-Conduct/#complaint-handling-process","title":"Complaint Handling Process","text":"<p>As a first measure, it is preferable to work out issues directly with the people involved or to work with other Community Members who can help you resolve the issue. This may take several forms:</p> <ul> <li>Talk with one another. Assume that communications are positive and that people are treating each other with respect. Cues about emotions are often lacking in digital communications. Many of our modes of digital communication tend towards brevity, which can be easier to interpret incorrectly as being negative.</li> </ul> <ul> <li>Contact a representative of the Community Working Group, which exists to support the HOT Community. Representatives are available to discuss any concerns about behaviour within the community, or ideas to promote positive behaviours. You can email them at community@hotosm.org.</li> </ul> <ul> <li>Contact a representative of the Governance Working Group, which drafted these recommendations and the CoC. Representatives are available to provide advice on particular scenarios, as well as on the processes around the CoC.</li> </ul> <ul> <li>Contact the HOT Chair of Voting Members.</li> </ul> <ul> <li>Contact a HOT Board Member. Board members are well-versed in the community and its management. They can offer advice on your particular situation, and know the resources of the organization that may be available to you.</li> </ul> <ul> <li>Contact the HOT Community Partnerships Manager.</li> </ul> <p>When these informal processes fail, or when a situation warrants an immediate response by HOT, you can evoke the HOT Policy and Code of Conduct Complaint Handling Process. This process was adopted by HOT Voting Members in 2016 to provide a more formal means of enforcement for our community standards. You start it by emailing complaints@hotosm.org with a description of your complaint, your name, and the name of the offending party. All complaints will be considered confidential. The full process is described here</p>"},{"location":"LICENSE/","title":"GNU AFFERO GENERAL PUBLIC LICENSE","text":"<p>Version 3, 19 November 2007</p> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/</p> <p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>"},{"location":"LICENSE/#preamble","title":"Preamble","text":"<p>The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.</p> <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software.</p> <p>A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public.</p> <p>The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version.</p> <p>An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p>"},{"location":"LICENSE/#terms-and-conditions","title":"TERMS AND CONDITIONS","text":""},{"location":"LICENSE/#0-definitions","title":"0. Definitions","text":"<p>\"This License\" refers to version 3 of the GNU Affero General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p>"},{"location":"LICENSE/#1-source-code","title":"1. Source Code","text":"<p>The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p>"},{"location":"LICENSE/#2-basic-permissions","title":"2. Basic Permissions","text":"<p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p>"},{"location":"LICENSE/#3-protecting-users-legal-rights-from-anti-circumvention-law","title":"3. Protecting Users' Legal Rights From Anti-Circumvention Law","text":"<p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p>"},{"location":"LICENSE/#4-conveying-verbatim-copies","title":"4. Conveying Verbatim Copies","text":"<p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p>"},{"location":"LICENSE/#5-conveying-modified-source-versions","title":"5. Conveying Modified Source Versions","text":"<p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <ul> <li>a) The work must carry prominent notices stating that you modified   it, and giving a relevant date.</li> <li>b) The work must carry prominent notices stating that it is   released under this License and any conditions added under   section 7. This requirement modifies the requirement in section 4   to \"keep intact all notices\".</li> <li>c) You must license the entire work, as a whole, under this   License to anyone who comes into possession of a copy. This   License will therefore apply, along with any applicable section 7   additional terms, to the whole of the work, and all its parts,   regardless of how they are packaged. This License gives no   permission to license the work in any other way, but it does not   invalidate such permission if you have separately received it.</li> <li>d) If the work has interactive user interfaces, each must display   Appropriate Legal Notices; however, if the Program has interactive   interfaces that do not display Appropriate Legal Notices, your   work need not make them do so.</li> </ul> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p>"},{"location":"LICENSE/#6-conveying-non-source-forms","title":"6. Conveying Non-Source Forms","text":"<p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <ul> <li>a) Convey the object code in, or embodied in, a physical product   (including a physical distribution medium), accompanied by the   Corresponding Source fixed on a durable physical medium   customarily used for software interchange.</li> <li>b) Convey the object code in, or embodied in, a physical product   (including a physical distribution medium), accompanied by a   written offer, valid for at least three years and valid for as   long as you offer spare parts or customer support for that product   model, to give anyone who possesses the object code either (1) a   copy of the Corresponding Source for all the software in the   product that is covered by this License, on a durable physical   medium customarily used for software interchange, for a price no   more than your reasonable cost of physically performing this   conveying of source, or (2) access to copy the Corresponding   Source from a network server at no charge.</li> <li>c) Convey individual copies of the object code with a copy of the   written offer to provide the Corresponding Source. This   alternative is allowed only occasionally and noncommercially, and   only if you received the object code with such an offer, in accord   with subsection 6b.</li> <li>d) Convey the object code by offering access from a designated   place (gratis or for a charge), and offer equivalent access to the   Corresponding Source in the same way through the same place at no   further charge. You need not require recipients to copy the   Corresponding Source along with the object code. If the place to   copy the object code is a network server, the Corresponding Source   may be on a different server (operated by you or a third party)   that supports equivalent copying facilities, provided you maintain   clear directions next to the object code saying where to find the   Corresponding Source. Regardless of what server hosts the   Corresponding Source, you remain obligated to ensure that it is   available for as long as needed to satisfy these requirements.</li> <li>e) Convey the object code using peer-to-peer transmission,   provided you inform other peers where the object code and   Corresponding Source of the work are being offered to the general   public at no charge under subsection 6d.</li> </ul> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p>"},{"location":"LICENSE/#7-additional-terms","title":"7. Additional Terms","text":"<p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <ul> <li>a) Disclaiming warranty or limiting liability differently from the   terms of sections 15 and 16 of this License; or</li> <li>b) Requiring preservation of specified reasonable legal notices or   author attributions in that material or in the Appropriate Legal   Notices displayed by works containing it; or</li> <li>c) Prohibiting misrepresentation of the origin of that material,   or requiring that modified versions of such material be marked in   reasonable ways as different from the original version; or</li> <li>d) Limiting the use for publicity purposes of names of licensors   or authors of the material; or</li> <li>e) Declining to grant rights under trademark law for use of some   trade names, trademarks, or service marks; or</li> <li>f) Requiring indemnification of licensors and authors of that   material by anyone who conveys the material (or modified versions   of it) with contractual assumptions of liability to the recipient,   for any liability that these contractual assumptions directly   impose on those licensors and authors.</li> </ul> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p>"},{"location":"LICENSE/#8-termination","title":"8. Termination","text":"<p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p>"},{"location":"LICENSE/#9-acceptance-not-required-for-having-copies","title":"9. Acceptance Not Required for Having Copies","text":"<p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p>"},{"location":"LICENSE/#10-automatic-licensing-of-downstream-recipients","title":"10. Automatic Licensing of Downstream Recipients","text":"<p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p>"},{"location":"LICENSE/#11-patents","title":"11. Patents","text":"<p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p>"},{"location":"LICENSE/#12-no-surrender-of-others-freedom","title":"12. No Surrender of Others' Freedom","text":"<p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p>"},{"location":"LICENSE/#13-remote-network-interaction-use-with-the-gnu-general-public-license","title":"13. Remote Network Interaction; Use with the GNU General Public License","text":"<p>Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph.</p> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License.</p>"},{"location":"LICENSE/#14-revised-versions-of-this-license","title":"14. Revised Versions of this License","text":"<p>The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p>"},{"location":"LICENSE/#15-disclaimer-of-warranty","title":"15. Disclaimer of Warranty","text":"<p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p>"},{"location":"LICENSE/#16-limitation-of-liability","title":"16. Limitation of Liability","text":"<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>"},{"location":"LICENSE/#17-interpretation-of-sections-15-and-16","title":"17. Interpretation of Sections 15 and 16","text":"<p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"LICENSE/#how-to-apply-these-terms-to-your-new-programs","title":"How to Apply These Terms to Your New Programs","text":"<p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>    &lt;one line to give the program's name and a brief idea of what it does.&gt;\n    Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as\n    published by the Free Software Foundation, either version 3 of the\n    License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If your software can interact with users remotely through a computer network, you should also make sure that it provides a way for users to get its source. For example, if your program is a web application, its interface could display a \"Source\" link that leads users to an archive of the code. There are many ways you could offer source, and different solutions will be better for different programs; see section 13 for the specific requirements.</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU AGPL, see https://www.gnu.org/licenses/.</p>"},{"location":"wiki_redirect/","title":"OSM Fieldwork","text":"<p>Please see the docs page at: https://hotosm.github.io/osm-fieldwork/</p>"},{"location":"about/About/","title":"About","text":""},{"location":"about/About/#osm-fieldwork-project","title":"OSM-Fieldwork Project","text":"<p>Osm_Fieldwork is a project that aims to simplify the process of processing data collected using ODK into OpenStreetMap format. It consists of several utility programs that automate different parts of the data flow. These include creating satellite imagery basemaps and data extracts from OpenStreetMap so they can be used with ODK Collect. It is maintained by the Humanitarian OpenStreetMap Team (HOT) and designed to work with ODK Collect, an Android app for data collection, and ODK Central, a web-based platform for managing and visualizing data.</p>"},{"location":"about/About/#osm_fieldwork","title":"osm_fieldwork","text":"<p>This program converts the data collected from ODK Collect into the proper OpenStreetMap tagging schema. The conversion is controlled by a YAML file, which makes it easy to modify for other projects. The output is an OSM XML formatted file for JOSM. However, it is important to note that no converted data should ever be uploaded to OSM without first validating the conversion in JOSM. To do high-quality conversion from ODK to OSM, it's best to use the XLSForm library as template, as everything is designed to work together.</p> <p>Osm_Fieldwork includes the following utilities:</p> <ul> <li><code>make_data_extract.py</code>: extracts OpenStreetMap data within a given boundary and category (e.g., buildings, amenities) using Overpass Turbo or a Postgres database.</li> <li><code>CSVDump.py</code>: converts a CSV file downloaded from ODK Central to OSM XML format.</li> <li><code>odk2csv.py</code>: converts an ODK XML instance file to the same CSV format used by ODK Central.</li> <li><code>ODKDump.py</code>: extracts data from an ODK Collect instance XML file and converts it to OSM XML format.</li> <li><code>ODKForm.py</code>: parses an ODK XML form file and extracts its fields and data types.</li> <li><code>ODKInstance.py</code>: parses an ODK Collect instance XML file and extracts its fields and data values.</li> </ul> <p>Osm_Fieldwork also includes support modules, such as convert.py for processing YAML config files and osmfile.py for writing OSM XML output files.</p>"},{"location":"about/About/#installation","title":"Installation","text":"<p>To install osm-fieldwork, you can use pip. Here are two options:</p> <ol> <li> <p>Directly from the main branch:    <code>pip install git+https://github.com/hotosm/osm-fieldwork.git</code></p> <p>-OR-</p> </li> <li> <p>Latest on PyPi:    <code>pip install Osm-Fieldwork</code></p> </li> </ol> <p>Note: installation requires GDAL &gt;3.4 installed on your system.</p>"},{"location":"about/About/#usage","title":"Usage","text":"<p>Each utility has its own command-line interface, with various options and arguments. You can find detailed instructions on how to use each utility by running it with the -h or --help option. For example, to extract OSM data within a boundary polygon from Overpass Turbo, run:</p> <p><code>./make_data_extract.py --overpass --boundary mycounty.geojson</code></p> <p>This will create a GeoJSON file with the extracted data.</p> <p>To convert a CSV file from ODK Central to OSM XML format, run:</p> <p><code>./CSVDump.py -i data.csv</code></p> <p>This will generate two output files - one OSM XML of public data, and the other a GeoJson file with all the data.</p>"},{"location":"about/About/#contributing","title":"Contributing","text":"<p>Osm_Fieldwork is an open-source project, and contributions are always welcome! If you want to contribute, please read the Contribution Guidelines and Code of Conduct first.</p>"},{"location":"about/About/#license","title":"License","text":"<p>Osm_Fieldwork is released under the AGPLv3.</p>"},{"location":"about/Contribution/","title":"Contribution","text":""},{"location":"about/Contribution/#hugs-welcome","title":":hugs: Welcome","text":"<p> First off, I'm really glad you're reading this, because we need volunteer developers to help improve the Osm_Fieldwork and it's integration with FMTM! </p> <p>We welcome and encourage contributors of all skill levels and we are committed to making sure your participation is inclusive, enjoyable and rewarding. If you have never contributed to an open source project before, we are a good place to start and will make sure you are supported every step of the way. If you have any questions, please ask!</p> <p>There are many ways to contribute to this repo:</p>"},{"location":"about/Contribution/#testing","title":"Testing","text":"<p>Adding test cases, or simply testing out existing functionality.</p>"},{"location":"about/Contribution/#report-bugs-and-suggest-improvements","title":"Report bugs and suggest improvements","text":"<p>The issue queue is the best way to get started. There are issue templates for BUGs and FEATURES that you can use, or you can create your own. Once you have submitted an issue, it will be assigned one label out of the following label categories. If you are wondering where to start, you can filter by the GoodFirstIssue label.</p>"},{"location":"about/Contribution/#code-contributions","title":"Code contributions","text":"<p>Create pull requests (PRs) for changes that you think are needed. We would really appreciate your help!</p>"},{"location":"about/Contribution/#useful-resources-for-contribution","title":"Useful Resources for Contribution","text":"<ul> <li>Troubleshooting</li> <li>FAQs</li> </ul>"},{"location":"about/Contribution/#thank-you","title":"Thank you","text":"<p>Thank you very much in advance for your contributions!! Please ensure you refer to our Code of Conduct. If you've read the guidelines, but you are still not sure how to contribute on Github, please reach out to us via our Slack #geospatial-tech-and-innovation.</p>"},{"location":"about/FAQ/","title":"\u2753 Frequently Asked Questions \u2753","text":"<p>Q: What is OSM Fieldwork?</p> <p>A: OSM Fieldwork is a project to support field data collection using ODK and OpenStreetMap. The primary functionality is the ability to convert data collected with ODK Collect into OSM XML. In addition it can also create satellite imagery basemaps for ODK Collect and Osmand. In addition there is a library of XLSForms focused on humanitarian data collection.</p> <p>Q: How do I install OSM Fieldwork ?</p> <p>A: To install osm-fieldwork, you can use pip. Here are two options:</p> <ol> <li> <p>Directly from the main branch:    <code>pip install git+https://github.com/hotosm/osm-fieldwork.git</code></p> <p>-OR-</p> </li> <li> <p>Latest on PyPi:    <code>pip install Osm-Fieldwork</code></p> </li> </ol> <p>Q: Where can I find the source code and the XLSForm library ?</p> <p>A: Check the osm-fieldwork git repo here</p> <p>Q: What language is Osm Fieldwork written in ?</p> <p>A: OSM Fieldwork is written in Python and uses other modules like shapely, pyxform, xmltodict, pandas</p> <p>Q: What is the XLSForm library ?</p> <p>A: The library of XLSForms are primarily focused on humanitarian data collection, and follow data models designed by the Humanitarian Openstreetmap Team with consultation with other humanitarian NGOs. These are designed for efficient data collection and conversion to OSM XML format to allow for easy and high quality contributions to the map.</p> <p>Q: Who can contribute to osm-fieldwork?</p> <p>A: It is an open-source project, and contributions from developers and technical writers are always welcome.</p> <p>Q: What kind of contributions can I make ?</p> <p>A: There are several ways you can contribute to osm-fieldwork, including:</p> <ul> <li>Development: If you have experience in development, you can contribute   by fixing bugs, adding new features, or improving the existing codebase.</li> </ul> <ul> <li>Documentation: If you have experience in technical writing, you can   contribute by writing documentation, tutorials, or other educational   materials.</li> </ul> <ul> <li>Testing: If you have experience in software testing, you can   contribute by testing the application and reporting bugs or suggesting   improvements.</li> </ul> <p>Q: How can I report a bug or suggest a new feature for OSM Fieldwork ?</p> <p>A: You can report bugs or suggest new features by opening an issue on the OSM Fieldwork repository on GitHub. Be sure to provide as much detail as possible, including steps to reproduce the bug and any relevant error messages. For more details visit Contributions Page.</p> <p>Q: Do I need to have prior experience with XLSForms or python to contribute to OSM Fieldwork ?</p> <p>A: While prior experience with the various data formats usd by OSM Fieldwork is helpful, it is not required to contribute to OSM Fieldwork. You can start by reviewing the documentation, exploring the codebase, and contributing to issues labeled as good first issue.</p> <p>Q: How can I get help or support for OSM Fieldwork ?</p> <p>A: If you need help or support with XLSForms, you can reach out to the ODK community on the ODK Forum. For questions on OSM Fieldwork you can open an issue on the OSM Fieldwork repository.</p> <p>Q: What are the benefits of contributing to OSM Fieldwork?</p> <p>A: Contributing to OSM Fieldwork allows you to help improve a widely used tools for data collection.</p> <p>Q: What is the license for OSM Fieldwork ?</p> <p>A: OSM Fieldwork is AGPLv3, because it encourages us to all work together. The XLSForms themselves are under the CC 4.0</p> <p>Q: How can I test my changes to OSM Fieldwork ?</p> <p>A: OSM Fieldwork has a suite of automated tests that you can run to ensure that your changes do not introduce new bugs or break existing functionality. You can run the tests locally on your computer using the command-line interface or by setting up a continuous integration environment on a platform like Travis CI.</p> <p>Q: Facing addititional problems?</p> <p>A: Visit Troubleshooting.</p>"},{"location":"about/Troubleshooting/","title":"Troubleshooting","text":""},{"location":"about/Troubleshooting/#unable-to-connect-to-the-odkcentral-server-over-http-ie-insecure","title":"Unable to connect to the ODKCentral server over http (i.e. insecure)","text":"<p>By default, ODKCentral API connections are verified with SSL certificates. However, sometimes, users may encounter issues connecting to ODK Central with self-signed certificates. This is common for developers if running ODK Central in a local subnet without a public domain name.</p> <p>Here are some steps to troubleshoot and resolve the issue:</p> <ul> <li>Add the certificate to your system trusted certificate store.</li> </ul> <p>If you are using a self-signed certificate, make sure to add it to your system's trusted certificate store. For Ubuntu/Debian users, follow the steps below:</p> <pre><code>In a terminal:\nsudo apt update &amp;&amp; sudo apt install ca-certificates\nsudo cp cert.crt /usr/local/share/ca-certificates/\nsudo update-ca-certificates\n</code></pre> <p>If running OSM Fieldwork within the Field Mapping Tasking Manager, this is handled for you.</p> <p>Q: Can I disable SSL verification (not recommended)</p> <p>A: If you have tried the above step and still cannot connect to ODK Central, you can disable SSL verification for the certificate. However, this is not recommended as it will connect to ODK Central insecurely. To do this, add the environment variable ODK_CENTRAL_SECURE=False to your system.</p>"},{"location":"about/Troubleshooting/#additional-troubleshooting-steps","title":"Additional Troubleshooting Steps","text":"<p>If you are still unable to connect to the ODKCentral server over HTTP:</p> <ul> <li> <p>Verify that the ODK Central API URL is correct</p> <p>Make sure that you have entered the correct ODK Central API URL in your OSM Fieldwork configuration file. You can check the URL by logging into ODK Central and navigating to the \"Site Configuration\" page.</p> </li> </ul> <ul> <li> <p>Check that the ODK Central server is running</p> <p>Make sure that the ODK Central server is running and accessible. You can check the server status by navigating to the ODK Central API URL in your web browser.</p> </li> </ul> <ul> <li> <p>Check that the ODK Central server is reachable from your network</p> <p>Make sure that your network is not blocking the connection to the ODK Central server. You can try pinging the server from your computer to see if there is a network issue.</p> </li> </ul> <ul> <li> <p>Check that your firewall is not blocking the connection</p> <p>Make sure that your firewall is not blocking the connection to the ODK Central server. You can try temporarily disabling your firewall to see if this resolves the issue.</p> </li> </ul> <ul> <li> <p>Check the ODK Central server logs</p> <p>Check the ODK Central server logs to see if there are any error messages related to the connection. This can help identify the root cause of the issue.</p> </li> </ul> <ul> <li> <p>Try using a different web browser</p> <p>If you are having trouble connecting to ODK Central through a web browser, try using a different browser to see if the issue persists. It is possible that the issue is related to the browser or its settings.</p> </li> </ul> <ul> <li> <p>Update OSM Fieldwork and ODK Central to the latest version</p> <p>Make sure that you are using the latest version of OSM Fieldwork and ODK Central. Check the OSM Fieldwork and ODK Central release notes to see if any updates address the issue you are experiencing.</p> </li> </ul>"},{"location":"about/basemapper/","title":"Basemapper.py","text":"<p>Basemapper is a program that creates basemaps for mobile apps in the mbtiles and sqlitedb formats. These formats are commonly used by mobile mapping applications like Osmand and ODK Collect. There are two primary formats:</p> <ul> <li>mbtiles, supported by many apps.</li> <li>sqlitedb, supported only by Osmand</li> </ul> <p>Both of these use formats use underlying sqlite3, with similar database schemas. The schema are a simple XYZ that stores a png or jpeg image. When the entire planet is chopped into squares, there is a relation between which map tile contains the GPS coordinates you want. Small zoom levels cover a large area, higher zoom levels a smaller area.</p> <p>Basemapper does not store anything in memory, all processing is done as a stream so large areas can be downloaded. Time to go buy a really large hard drive. You can also use this map tile cache for any program that supports a TMS data source like JOSM. Luckily once downloaded, you don't have to update the map tile cache very often, but it's also easy to do so when you need to. When I expect to be working offline, I commonly download a larger area, and then in the field produce the smaller files.</p> <p>Basemapper. downloads map tiles to a cache and uses them to generate the output files. It does not perform data conversion. The resulting output can be used for visualizing geographic data and analyzing survey responses in a spatial context. The script provides various command-line options for customizing the output, such as setting the zoom levels, boundary, tile cache, output file name, and more.</p>"},{"location":"about/basemapper/#database-schemas","title":"Database Schemas","text":"<p>Mbtiles are used by multiple mobile apps, but our usage is primarly for ODK Collect. Imagery basemaps are very useful for two reasons. One, the map data may be lacking, so the imagery helps one to naviagte. For ODK Collect the other advantage is you can select the location based on where the building is, instead of were you are standing. Mbtiles are pretty straight forward.</p> <p>The sqlitedb schema used by Osmand looks the same at first, but has one big difference. In this schema it tops out at zoom level 16, so instead of incrementing, it decrements the zoom level. This obscure detail took me a while to figure out, it isn't documented anywhere.</p>"},{"location":"about/basemapper/#mbtiles","title":"mbtiles","text":"<pre><code>CREATE TABLE tiles (zoom_level integer, tile_column integer, tile_row integer, tile_data blob);\nCREATE INDEX tiles_idx on tiles (zoom_level, tile_column, tile_row);\nCREATE TABLE metadata (name text, value text);\nCREATE UNIQUE INDEX metadata_idx  ON metadata (name);\n</code></pre>"},{"location":"about/basemapper/#sqlitedb","title":"sqlitedb","text":"<pre><code>CREATE TABLE tiles (x int, y int, z int, s int, image blob, PRIMARY KEY (x,y,z,s));\nCREATE INDEX IND on tiles (x,y,z,s);\nCREATE TABLE info (maxzoom Int, minzoom Int);\nCREATE TABLE android_metadata (en_US);\n</code></pre>"},{"location":"about/basemapper/#usage","title":"Usage","text":"<p>The basemapper.py script is run from the command line when running standalone, or the class can be imported into python programs. The Field Mapping Tasking Manager uses this as part of a (FastAPI])https://fastapi.tiangolo.com/) backend for the website.</p> <p>The first time you run basemapper.py, it'll start downloading map tiles, which may take a long time. Often the upstream source is slow. It is not unusual for downloading tiles, especially at higher zoom levels may tak an entire day. Once tiles are download, producing the outout tiles is quick as then it's just packaging. In areas where I work frequentely, I usually download a large area even if it takes a week or more so it's available when I need it. On my laptop I actually have a map tile cache for the entire state of Colorado, as well as many large areas of Nepal, Turkey, Kenya, Uganda, and Tanzania.</p>"},{"location":"about/basemapper/#options","title":"Options","text":"<p>The basic syntax is as follows:</p> <ul> <li>-h, --help show this help message and exit</li> <li>-v, --verbose verbose output</li> <li>-b BOUNDARY, --boundary BOUNDARY - The boundary for the area you want, as BBOX string or geojson file.</li> <li>-z ZOOMS, --zooms ZOOMS - The Zoom levels</li> <li>-o OUTFILE, --outfile - OUTFILE Output file name</li> <li>-d OUTDIR, --outdir OUTDIR -Output directory name for tile cache</li> <li>-s {ersi,bing,topo,google,oam}, --source {ersi,bing,topo,google,oam} - Imagery source</li> </ul> <p>The suffix of the output file is either mbtiles or sqlitedb, which is used to select the output format. The boundary file, if specified, must be in GeoJson format. If in BBOX string format, it must be comma separated: \"minX,minY,maxX,maxY\".</p>"},{"location":"about/basemapper/#imagery-sources","title":"Imagery Sources","text":"<ul> <li>ESRI - Environmental Systems Research Institute</li> <li>Bing - Microsoft Bing imagery</li> <li>Topo - USGS topographical maps (US only)</li> <li>OAM - OpenAerialMap</li> </ul> <p>The default output directory is /var/www/html. The actual subdirectory is the source name with tiles appended, so for example /var/www/html/oamtiles. Putting the map tiles into webroot lets JOSM or QGIS use them when working offline.</p>"},{"location":"about/basemapper/#examples","title":"Examples","text":""},{"location":"about/basemapper/#example-1","title":"Example 1:","text":"<p>Generate a basemap for Osmand using ERSI imagery, for an area specified by a geojson bounding box, and supporting zoom levels 12 through 19.</p> <pre><code>[path]/basemapper.py -z 12-19 -b test.geojson -o test.sqlitedb -s esri\n</code></pre>"},{"location":"about/basemapper/#example-2","title":"Example 2:","text":"<p>As above, but mbtiles format, and Bing imagery source. The <code>-v</code> option enables verbose output, which will show more details about the download and processing progress. Also only download a single zoon level.</p> <pre><code>[path]/basemapper.py -v -z 16 -b test.geojson -o test.mbtiles -s bing\n</code></pre>"},{"location":"about/configuring/","title":"Configuring the Data Conversion","text":"<p>Osm_Fieldwork uses a YAML-based configuration file that controls the conversion process. While ideally, the tags in the XForm are a match for OSM tags, some survey questions generate very different primary tags. All of the strings in this file are lowercase, as when processing the CSV file, everything is forced to be lowercase.</p> <p>YAML is a simple syntax, and most of the config options are simply lists. For example:</p> <pre><code># All of the data that goes in a different non-OSM file\nprivate:\n  - income\n  - age\n  - gender\n</code></pre> <p>There are 3 sections in the config file, ignore, convert, and private. Anything in the ignore section gets left out of all data processing and output files. Anything in the private section is kept out of the OXM output file, but included in a separate GeoJson formatted file. That file contains all the data from whoever is organizing this mapping campaign. There are often data items like gender that don't belong in OSM, but that information is useful to the organizers. Anything in the convert section is the real control of the conversion process.</p>"},{"location":"about/configuring/#here-is-an-example-of-a-configuration-file-with-explanations-of","title":"Here is an example of a configuration file with explanations of","text":"<p>its different sections and options expained in detail:</p> <pre><code>#ignore section\nignore:\n  - respondent_name\n  - survey_date\n\n#private section\nprivate:\n  - age\n  - gender\n\n#convert section\nconvert:\n  #example of a simple conversion\n  - waterpoint:\n    - well: man_made=water_well\n    - natural: natural=water\n  #example of a conversion with multiple OSM tags\n  - power:\n    - solar: generator::source=solar,power=generator\n    - wind: generator::source=wind,power=generator\n    - hydro: generator::source=hydro,power=generator\n    - geothermal: generator::source=geothermal,power=generator\n    - grid: generator::source=electricity_network,power=generator\n</code></pre> <p>The configuration file has three sections: <code>ignore</code>, <code>private</code>, and <code>convert</code>.</p> <p>The <code>ignore</code> section lists the names of data fields that should be ignored during the conversion process. These fields will not be included in any output files.</p> <p>The <code>private</code> section lists the names of data fields that are considered private and should not be included in the OSM output file. However, they will be included in a separate GeoJson formatted file. This file contains all the data from whoever is organizing the mapping campaign. An example of private data is gender, which is useful to the organizers but not relevant to OSM.</p> <p>The <code>convert</code> section is the real control of the conversion process. It lists the survey questions and their corresponding OSM tags and values. In this section, each survey question is represented by a tag name, and each answer to the survey question is represented by a value. If the answer matches the value, it returns both the tag and the value for OSM. An equal sign is used to delimit them.</p> <p>For example, in the configuration file above, the survey question about waterpoints has two possible answers: \"well\" and \"natural\". If the answer is \"well\", the corresponding OSM tag and value is \"man_made=water_well\". If the answer is \"natural\", the corresponding OSM tag and value is \"natural=water\".</p> <p>Another example in the same configuration file is the survey question about power sources. This survey question has five possible answers: \"solar\", \"wind\", \"hydro\", \"geothermal\", and \"grid\". Each answer corresponds to multiple OSM tags and values, which are separated by commas.</p> <p>For example, if the answer is \"solar\", the corresponding OSM tags and values are \"generator::source=solar\" and \"power=generator\". The double colon is used to represent a hierarchy in the OSM tags. In this example, the generator source is solar, and the power source is a generator.</p> <p>Both ODK and OSM use a tag/value pair. In OSM, the tags and values are documented, and the mapping community prefers people use the commonly accepted values. In ODK, the tags and values can be anything the developer of the XLSForm chooses. Depending on the answer to the survey question, that may be converted to a variety of OSM tags and values.</p> <p>For this example, the value used in the name column of the XLSForm survey sheet is waterpoint. It has several values listed underneath. Each of those is for the answer given to the waterpoint survey question. If the answer matches the value, it returns both the tag and the value for OSM. An equal sign is used to deliminate them.</p> <pre><code>- waterpoint:\n  - well: man_made=water_well\n  - natural: natural=water\n</code></pre> <p>Some features have multiple OSM tags for a single survey question answer. To handle this case, all entries are deliminated by a comma.</p> <pre><code>- power:\n  - solar: generator::source=solar,power=generator\n  - wind: generator::source=wind,power=generator\n  - hydro: generator::source=hydro,power=generator\n  - geothermal: generator::source=geothermal,power=generator\n  - grid: generator::source=electricity_network,power=generator\n</code></pre> <p>Overall, the configuration file is a powerful tool for customizing the conversion of ODK data into OSM tags and values. By carefully defining the <code>ignore</code>, <code>private</code>, and <code>convert</code> sections, you can control the output of the conversion process and ensure that it meets your needs.</p> <p>Here's a simple chart of the conversion Data Flow.</p>"},{"location":"about/conflation/","title":"Conflating With OpenStreetMap","text":"<p>Now that the data collected using ODK Collect has been converted to OSM XML, it needs to be conflated against the existing OpenStreetMap(OSM) data before validation by a human being. Due to the wonderful flexibility of the OpenStreetMap(OSM) data schema, this can be difficult to fully automate. At best it can assist the human mapper by identifying probable duplicates, and other conflation issues. Rather than delete the possible duplicates, instead a tag is added so the mapper can find them easily and decide.</p> <p>Conflation algorythms are not very elegant, they are usually slow and brute force. But they also save the mapper time doing this completely manually.</p> <p>This project's conflation software can use either a local postgres database, or a GeoJson file produced by the make_data_extracts program. This program is also used by FMTM, so you can use those as well. Obviously using postgres locally is much faster, especially for large areas.</p>"},{"location":"about/conflation/#setting-up-postgres","title":"Setting Up Postgres","text":"<p>For raw OSM data, the existing country data is downloaded from GeoFabrik, and imported using a modified schema for osm2pgsql.</p> <pre><code>osm2pgsql --create -d nepal --extra-attributes --output=flex --style raw.lua nepal-latest-internal.osm.pbf\n</code></pre> <p>The raw.lua script is available here. It's part of the Underpass project. It uses a more compressed and efficient data schema designed for data analysis. Once the data is imported, do this to improve query performance.</p> <pre><code>cluster ways_poly using ways_poly_geom_idx;\ncreate index on ways_poly using gin(tags);\n</code></pre> <p>The existing OSM database schema stores some tags in columns, and other tags in a hstore column. Much of this is historical. But this also makes it very complicated to query the database, as you need to know what is a column, and what is in the hstore column. The raw.lua schema is much more compact, as everything is in a single column.</p>"},{"location":"about/conflation/#using-postgres","title":"Using Postgres","text":"<p>If you use the OdkParsers program, you don't have to deal with accessing the database directly, but here's how if you want to.</p> <p>This would find all of the tags for a hotel:</p> <pre><code>SELECT osm_id, tags FROM nodes WHERE tags-&gt;&gt;'amenity'='hotel'\n</code></pre> <p>If you want to get more fancy, you can also use the geometry in the query. From python we setup a few values for the query, and note the ::geometry suffix, which uses meters instead of units. Meters are easier to work with than units of the planet's circumferance.</p> <p>self.tolerance = 2 wkt.wkt = \"Point\", \"coordinates\": [-107.911957, 40.037573] value = 'Meeker Hotel'</p> <p>query = f\"SELECT osm_id,tags,version,ST_AsText(ST_Centroid(geom)) FROM ways_POLY WHERE ST_Distance(geom::geography, ST_GeogFromText(\\'SRID=4326;{wkt.wkt}\\')) &lt; {self.tolerance} AND levenshtein(tags-&gt;&gt;'name', {value}) &lt;= 1\"</p> <p>This query finds any building polygon with 2 meters where the name matches. The levenstein function does a fuzzy string match, since minor differences in the name can still be a match. Minor typos in the ODK collected data or OSM often have minor typos.</p>"},{"location":"about/conflation/#using-a-geojson-file","title":"Using a GeoJson File","text":"<p>Using a data file also works the same way, only you can't really query the data file the same way. Instead the entire data file is loaded into a data structure so it can be queried by looping through all the data. While not very efficient, it works well.</p>"},{"location":"about/conflation/#conflating-the-data","title":"Conflating The Data","text":"<p>All data collected using Collect is a node, but we also want to check both nodes and ways. Many amenities in OSM are only a node, since adding data with a mobile app, POIs is all they support. Any data added by JOSM or the iD editors is often a polygon. Many buildings have been added to OSM using the HOT Tasking Manager, and were traced from satellite imagery.</p> <p>Buildings traced from imagery have only a single tag, which is building=yes. When field mapping, we now know that building is a resturant, a medical clinic, or a residence. Since OSM guidelines prefer the tags fo on the building polygon, and not be a separate POI within the building. If there are multiple businesses in the same building polygon, then they stay as a POI in the building.</p>"},{"location":"about/conflation/#conflating-with-postgres","title":"Conflating With Postgres","text":"<p>Since the database has 2 tables, one for nodes and the other for polygons, we have to query both. A possible duplicate is one that is within the desired distance and has a match in one of the tags and values. Names are fuzzy matched to handle minor spelling differences.</p> <p>The nodes table is queried first. If no possible duplicates are found, then the ways table is queried next. The query just looks for any nearby POI that has a match between any of the tags. Currently the distance is set to 2 meters. Often the GPS coordinates from Collect are where you are standing, usualy in front of the building. This distance threshold is configurable, but if it's too large, you get many false positives. As all mobile mapping apps only add a POI for an amenity, it's common it's in the nodes table.</p> <p>If nothing is found in the nodes table, then we check the polygons the same way, distance and a tag match. Often people working on a desktop or laptop may add more tags to an existing feature, and properly have all the tags be in the building way, and not a POI within the building. If there are miltiple small businesses in the same building, then each remains a POI within the building polygon.</p> <p>If a possible duplicate is found, the tags from the collected data and the tags from OSM are merged together. In the case of the name tag, the existing name is converted to an old_name tags, and the collected name value is used for the *name tag.</p>"},{"location":"about/conflation/#conflating-with-a-geojson-file","title":"Conflating with a GeoJson File","text":"<p>Since GeoJson supports multiple geometry types, unlike postgres, there is only one set of data to compare against. The same process as used for postgres is used for the data file, the only difference being the data file is loaded into a data structure, and then has to loop through all the existing features. This is slower than using postgres, but works the same. One advantage is this can use he data extract from FMTM, and not require the mapper to have a postgres database.</p>"},{"location":"about/conflation/#string-matching","title":"String Matching","text":"<p>There are more spelling mistakes, weird capitalization, embedded quotes, etc... in the values for the name tag than I can count. This makes matching on the name somewhat complicated even when using fuzzy string matching. Typing in names on one's smartphone also can add typos or do auto-correction. And of course those mistakes may also already be in OSM, and the feature you collected may be the correct one.</p> <p>For a potential match, the old value is placed in a old_name tag, in addition to the the fixme tag used to flag a possible duplicate. This enables the validator to decide and fix any minor differences in the value. This mostly only applies to the name tag, as most other tags have a more formalized value.</p> <p>When an amenity has changed names, for example when a restaurant gets new owners, this won't likely be caught as a duplicate unless the amenity tag values match.</p>"},{"location":"about/conflation/#validating-the-results","title":"Validating The Results","text":"<p>Conflation does not generate perfect results. It's necessary to have a validator go through the reults and decide. The output file from conflation does not remove anything from the collected data. Instead it adds custom tags on what it finds. This way the validator can search for those tags when getting started, and delete the duplicate and validate the tag merging.</p> <p>The primary tag added is a fixme tag for possible duplicates. If there is more than a difference in the string values used for the name tag, the existing tag is renamed to be old_name. While this is not an actual OSM tag, the alt_name tag is currrently used to avoid conflicts. It's up to the validator to decide what the apppropriate value is.</p> <p>I often notice when collecting data in the field on my smartphone, typos are common. Missing capitalization on names or sometimes the wrong character is common.</p> <p>Here's a simple chart of the conversion Data Flow.</p>"},{"location":"about/convert/","title":"Convert.py","text":"<p>The convert.py module is part of the osm_fieldwork package and provides functionality for converting ODK forms to OSM XML using a YAML configuration file.</p> <p>Even if an XLSForm is carefully designed to have a one to one match between ODK and OSM, this is not always possible, as not all survey questions are for OSM.</p>"},{"location":"about/convert/#the-config-file-sections","title":"The Config File Sections","text":"<p>There are several sections the config file. The default one is called xforms.yaml, and is included in the sources and the python package. It is possible to use a different config file.</p>"},{"location":"about/convert/#convert","title":"convert","text":"<p>This section supports one to one conversion of tags, as well as one to many. This example shows all poossible conversion types. The simple ones like altitude just change the tag, and the value is used unchanged. A more complicated conversion is changing the value in addition to the tag. Anything with an equals sign is split into the appropriate tag and value for OSM. The final one is where a singe survey question creates multiple tahg and value pairs, deliminated by a comma. Each of the pairs is handled as a separate tag and value in OSM. convert: - latitude: lat - longitude: lon - altitude: ele - cemetery_services: - cemetery: amenity=grave_yard - cremation: amenity=crematorium - amenity: - coffee: amenity=cafe,cuisine=coffee_shop ...</p>"},{"location":"about/convert/#private","title":"private","text":"<p>Not all collected data is suitable for OSM. This may include data that has no equivalant tag in OSM, or personal data.</p> <pre><code>private:\n - income\n - age\n - gender\n - education\n</code></pre>"},{"location":"about/convert/#ignore","title":"ignore","text":"<p>ODK supports many tags useful only internally. These go into the ignore section of the config file. Any tag in this section gets removed from from all output files. An example would be this:</p> <pre><code>ignore:\n - attachmentsexpected\n - attachmentspresent\n - reviewstate\n - edits\n - gps_type\n - accuracy\n - deviceid\n...\n</code></pre>"},{"location":"about/convert/#multiple","title":"multiple","text":"<p>Not all survey questions have a single answer. Anything using select_multiple may have more than one value. As the default assumes one answer per question, this specifies the questions with multiple answers since they have to be processed seperately. The normal conversion process is applied to these too.</p> <pre><code>multiple:\n - healthcare\n - amenity_type\n - specialty\n</code></pre>"},{"location":"about/externaldata/","title":"Dealing with External Data in ODK","text":""},{"location":"about/externaldata/#external-datasets","title":"External Datasets","text":"<p>ODK Collect has recently gained the ability to load an external data file in GeoJson format of existing data. It's now possible to select existing data and then import its values into the XForm as default values. This lets the mapper use the XForm to change the existing data, or add to it. Any changes will need to be conflated later, that'll be another document.</p> <p>Why do I want to use ODK Collect to edit map data? Much of what is currently in OpenStreetMap is lacking metadata, or the data has changed, like when a restaurant changes owners and gets a new name. Also most all remote mapping using satellite imagery lacks tags beyond building=yes. When we are doing a ground data collection project, we want to add useful tags like the building material, or whether it's a cafe or a hospital.</p> <p>Old imports also bring in problems, for example the infamous TIGER import. Mappers have been cleaning that mess in North America up for over a decade. But an old import may have a weird value for an OSM tag, and it's usually better to update to a more community approved data model. The beauty and the curse of OSM data is its wonderful flexibility. People do invent new tags for a specific mapping campaign or import that doesn't get reviewed. Sometimes values have embedded quote marks or weird capitalization, and other strange formatting worth correcting.</p>"},{"location":"about/externaldata/#creating-the-geojson-file","title":"Creating the GeoJson file","text":"<p>When working with OSM data, there are multiple sources to obtain the required data. One option is to download a daily database dump from GeoFabrik, which can be used as a flat file or imported into a database. The Humanitarian OpenStreetMap Team(HOT) maintains two projects that can also be used for data extracts. The primary one has a web based user interface, and is called the HOT Export Tool. The other option runs in a terminal and is part of OSM Fieldwork project, and is also used as part of the Field Mapping Tasking Manager backend. That program is available here. Alternatively, Overpass Turbo can also be used to query the data but you have to understand the Overpass query syntax.</p> <p>It's important to keep in mind that there is a translation between the column names obtained from querying the data and how ODK Collect views it. There is also a translation from ODK to OSM, and it's important to ensure that all translations work together seamlessly for a smooth data flow. To maintain clarity, it's best to keep all tags and values as similar as possible, with unique names. When using ogr2ogr for data extraction from a Postgres database, there is more control than when using Overpass, and larger datasets can be processed. You can clean up all the tag names later if you add a custom config file for the conversion.</p> <p>As the GeoJson file gets turned into an XPATH components when converted to an XForm, the actual filename without the suffix becomes a node in the XPATH, so you can't have a survey question using the same name as the filename. It is prefered to have the name using the actual OSM tag instead of the file. If you get this error, you need to rename the GeoJson file.</p> <pre><code>Duplicate type: 'choice', Duplicate URI: 'None', Duplicate context: 'survey'.\n</code></pre>"},{"location":"about/externaldata/#naming-conflicts","title":"Naming Conflicts","text":"<p>If you do want to use an OSM tag name in a calculate field, a technique for maintaining consistency is to prefix an x to the start of each column name, so healthcare becomes xhealthcare. Then, in the XLSForm, healthcare can be used for the instance, and xhealthcare can be used for the value in the calculation column in the survey sheet. The name column in the survey sheet can then be just healthcare, which will translate directly into its OSM tag equivalent. For this example note that the GeoJson file must not be named healthcare.geojson, because it'll conflict with _healthcare. You can also avoid this by having the calculation in the same row as the survey question and avoiding the variable. If you do that, add a trigger for the geojson file, and it'll populate the default value for the question.</p> <p>It's possible to support almost any value using a text type in the XLSForm, but it's better to have an approved value for tag validation and completeness. If using a data model, the list of choices for a tag is defined, and anything outside of that will cause an error. Therefore, it's important to adhere to validated data models to avoid introducing errors or inconsistencies into the dataset. If the SQL query returns columns that aren't compatible with the XLSForm, XPATH errors will occur in ODK Collect.</p> <p>Something else to consider is the frequency of the tags and values. Since almost anything can be added to OSM, there are a lot of obscure ones. It's strongly suggested to use more common tags and values. A resource for this is the Taginfo website, which lists everything every used in OSM. There are two columns of interest, one is whether the tag is on the OSM wiki, and the other is how many times that tag is used. I try to use tags that are on the wiki whenever possible, or at least have high frequency counts.</p>"},{"location":"about/externaldata/#data-filtering","title":"Data filtering","text":"<p>For the external file to load properly in ODK Collect, any tags and values in the data extract must be in the choices sheet. Otherwise ODK Collect will fail to launch. The OSM Fieldwork project has a utility program which can be imported into other python programs that scans the XLSForm choices sheet, and removes anything in the data extract that isn't supported as a choice.</p>"},{"location":"about/externaldata/#debugging-select_from-file-with-geojson","title":"Debugging select_from file with GeoJson","text":"<p>Debugging complex interactions between the XLSForm, external data files, and ODK Collect can be a challenging task. Here are a few tricks to help debug what is going on. I strongly suggest developing your XLSForm initially without the data extracts. That way you can use Enketo, which you can access using the Preview button in ODK Central. Get all the survey questions, grouping, conditional, etc... so it's easy to test with Enketo. Enketo doesn't work with the GeoJson based data extract. Then add the data extract, and the calculation column entries to use the OSM data to set the survey question default value.</p>"},{"location":"about/externaldata/#disable-the-map-appearance","title":"Disable the map appearance","text":"<p>When working with external data, the map value in the appearance column of the survey sheet is often used. However, this can slow down the debugging process. To make it more efficient, you can turn off the map values and use the select menu instead. That works especially well if you have a small data file for testing, because then it's easy to cycle between them.</p> <p>To use the placement map, here's an example.</p> type name label appearance select_one_from_file camp_sites.geojson existing Existing Campsites map <p>And an example where the values in the data file are an inline select menu instead.</p> type name label appearance select_one_from_file camp_sites.geojson existing Existing Campsites minimal"},{"location":"about/externaldata/#display-calculated-values","title":"Display calculated values","text":"<p>Often the bug you are trying to find is obscure, and you may not see any of the data file values being propagated into ODK Collect, even if it was working previously. In such cases, you can add a text survey question to display any of the values. Here's an example:</p> type name label calculation trigger calculate xid OSM ID instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/id calculate xlabel Get the label instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/title calculate xref Reference number instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/ref calculate xlocation Location instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/geometry calculate xtourism camping type instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/tourism calculate xleisure leisure type instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/leisure text debug1 Leisure ${xleisure} ${existing} text debug2 OSM ID ${xid} ${existing} text debug3 Ref number ${xref} ${existing} text debug4 Tourism ${xtourism} ${existing} text name Business Name ${xlabel} ${existing} <p>For a value that is only used once to set the default value in Collect, you can also reference it in the same row. This saves potential naming conflicts, although is why I use an x prefix for gobal values.</p> type name label calculation trigger text name Business Name instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/name ${existing}"},{"location":"about/externaldata/#error-dialog","title":"Error Dialog","text":"<p>Assuming xls2xform is happy, sometimes you get this error message in ODK Collect when switching screens. You'll see this when you have a value in your data file for a select_one survey question, but that value is not in the list of values in the choices sheet for that tag. In this example, there is no doctor value in the healthcare selection in the choices sheet. If you use the data filtering utility program mentioned above, you'll never see this error.</p> <p></p>"},{"location":"about/make_data_extract/","title":"make_data_extract","text":""},{"location":"about/make_data_extract/#make_data_extractpy","title":"make_data_extract.py","text":"<p>The <code>make_data_extract.py</code> program is used to extract OpenStreetMap (OSM) data for use with the <code>select_one_from_file</code> function in ODK Collect. This function allows users to select from a list of options generated from an external file. The <code>make_data_extract.py</code> program creates a data extract that can be used as an external file with the XLSForm. The data extract can be created using local Postgres database, or the remote Underpass database.</p> <p>To use the new <code>select_one_from_file</code> for editing existing OSM data you need to produce a data extract from OSM. This can be done several ways, but needed to be automated to be used for FMTM.</p> <pre><code>options:\n --help (-h)               show this help message and exit\n --verbose (-v)            verbose output\n --geojson (-g) GEOJSON    Name of the GeoJson output file\n --boundary (-b) BOUNDARY  Boundary polygon to limit the data size\n --category (-c) CATEGORY  Which category to extract\n --uri (-u) URI            Database URI\n --xlsfile (-x) XLSFILE    An XLSForm in the library\n --list (-l) List          List all XLSForms in the library\n</code></pre>"},{"location":"about/make_data_extract/#examples","title":"Examples","text":"<p>Make*data*extract uses a Postgres database to extract OSM data. By default, the program uses localhost as the database host. If you use *underpassas the data base name, this will remotely access the Humanitarian OpenStreetMap Team(HOT) maintained OSM database that covers the entire planet, and is updated every minute. The name of the database can be specified using the *--uri** option. The program extracts the buildings category of OSM data by default. The size of the extracted data can be limited using the _--boundary* option. The program outputs the data in GeoJSON format.</p> <p>For raw OSM data, the existing country data is downloaded from GeoFabrik, and imported using a modified schema for osm2pgsql. First create the database and install two postgres extensions:</p> <pre><code># createdb nigeria\npsql -d nigeria -c \"CREATE EXTENSION postgis\"\npsql -d nigeria -c \"CREATE EXTENSION hstore\"\n</code></pre> <p>And then import the OSM data.</p> <p>osm2pgsql --create -d nigeria --extra-attributes --output=flex --style raw.lua nigeria-latest-internal.osm.pbf</p> <p>The raw.lua script is available here. It's part of the Underpass project. It uses a more compressed and efficient data schema.</p>"},{"location":"about/make_data_extract/#example","title":"Example","text":"<pre><code>./make_data_extract.py -u colorado --boundary mycounty.geojson -g mycounty_buildings.geojson\n</code></pre> <p>This example extracts the <code>buildings</code> category of OSM data from a Postgres database named <code>colorado</code>. The program limits the size of the extracted data to the boundary specified in the <code>mycounty.geojson</code> file. The program outputs the data in GeoJSON format to a file named <code>mycounty_buildings.geojson</code>.</p>"},{"location":"about/make_data_extract/#boundary","title":"Boundary","text":"<p>The <code>--boundary</code> option can be used to specify a polygon boundary to limit the size of the extracted data. The boundary has to be in GeoJSON format, both multipolygons and polygons are supported.</p> <p>Example:</p> <pre><code>./make_data_extract.py -u foo@colorado --category healthcare --boundary mycounty.geojson -g mycounty_healthcare.geojson\n</code></pre> <p>This example extracts the <code>healthcare</code> category of OSM data from a Postgres database named <code>colorado</code> with e user foo. The program limits the size of the extracted data to the boundary specified in the <code>mycounty.geojson</code> file. The program outputs the data in GeoJSON format to a file named <code>mycounty_healtcare.geojson</code>.</p>"},{"location":"about/make_data_extract/#category","title":"Category","text":"<p>The <code>--category</code> option can be used to specify which category of OSM data to extract. The program supports any category in the xlsform library</p>"},{"location":"about/make_data_extract/#example_1","title":"Example","text":"<pre><code>./make_data_extract.py -u underpass --boundary mycounty.geojson --category amenities -g mycounty_amenities.geojson\n</code></pre> <p>This example uses Overpass Turbo to extract the <code>amenities</code> category of OSM data within the boundary specified in the <code>mycounty.geojson</code> file. The program outputs the data in GeoJSON format to a file named <code>mycounty_amenities.geojson</code>.</p>"},{"location":"about/make_data_extract/#output-file-format","title":"Output File Format","text":"<p>The program outputs the extracted OSM data in GeoJSON format. The name of the output file can be specified using the <code>--geojson option</code>. If the option is not specified, the program uses the input file name with <code>_buildings.geojson</code> appended to it.</p> <pre><code>./make_data_extract.py -u colorado --boundary mycounty.geojson -g mycounty_buildings.geojson\n</code></pre>"},{"location":"about/make_data_extract/#file-formats","title":"File Formats","text":"<p>ODK has 3 file formats. The primary one is the source file, which is in XLSX format, and follows the XLSXForm specification. This file is edited using a spreadsheet program, and convert using the xls2xform program. That conversion products an ODK XML file. That file is used by ODK Collect to create the input forms for the mobile app. When using ODK Collect, the output file is another XML format, unique to ODK Collect. These are the data collection instances.</p> <p>The ODK server, ODK Central supports the downloading of XForms to the mobile app, and also supports downloading the collected data. The only output format is CSV.</p>"},{"location":"about/odk-entities/","title":"ODK Entities","text":"<p>Entities are a concept introduced into ODK around 2022. The basic goal of them is to allow updating of data using ODK, specifically by revisiting specific things (features, people, whatever) and adding new data attached to the same entity (data people refer to this as \"longitudinal data\"). For example, revisiting the same patient in a clinical study, such that the patient ID is constant and the new data from each visit is referenced to the same person. For field mapping, the use-case is obvious: visit a previously digitized building and add data from in-person observation or surveying the people in it.</p> <p>As of time of writing (March 2024), Entities in ODK are working and more or less implemented, but not yet in wide use or well debugged.</p>"},{"location":"about/odk-entities/#use-of-entities-with-fmtm","title":"Use of Entities with FMTM","text":"<p>In osm-fieldwork / FMTM, we want to:</p> <ul> <li>Be aware of features that have already been mapped<ul> <li>the ODK map views don't yet support styling features differently   based on attributes like \"already_field_mapped\", so we're actually   working on a navigation app within FMTM external to ODK, but we still   hope that ODK Collect may support styling in the future, which will   almost certainly be based on Entity attributes.</li> </ul> </li> <li>Pre-fill questions in the form when features already have data attached   to them (for example, if a building already has a \"name\" tag, the field   mapper should see this pre-filled in the form, to be overwritted if wrong   but otherwise swiped past).</li> </ul> <p>The ODK core development team has strongly suggested that the FMTM team use the Entities to achieve the above goals.</p>"},{"location":"about/odk-entities/#workflow-using-entities","title":"Workflow Using Entities","text":"<p>UPDATE 29/07/2023 ODK Central now supports creating the Entity List / Dataset via API instead of registration form.</p> <p>The basic workflow would probably resemble:</p> <ul> <li>Create an Entity registration form.<ul> <li>In standard ODK settings, this simply means adding an <code>entities</code>   tab to the XLSForm (as per   the example Entities form created by the ODK team.   This seems to create what ODK refers to as a Dataset (in developer-facing   documenation only; they avoid this word in user-facing documentation).</li> </ul> </li> <li>Upload the Entities via the API:<ul> <li>There is currenltly no way to bulk upload Entities to a Dataset via the API.</li> <li>Instead we must upload each Entity individually, including a geometry field   in JavaRosa geometry format.</li> <li>Until time of writing, FMTM creates geography attachments in GeoJSON,   which does not work for Entities, which require a CSV file with a   <code>geography</code> column (which must be in JavaRosa format, which no self-respecting   GIS utility can export).</li> </ul> </li> <li>Create a form for the data collection, referencing the <code>{dataset_name}.csv</code> for   the <code>select_one_from_file</code> field.</li> <li>Dynamically insert the <code>task_id</code> field on the <code>choices</code> sheet, with <code>name</code> and   <code>label</code> set to the task id (for filtering later).</li> <li>Create a field <code>task_id</code> in the survey, prior to the <code>select_one_from_file</code> field.</li> <li>Set <code>choice_filter</code> column to task_id=${task_id}, which links the selected task   ID in the survey with the task_id field in the Entities (used for filtering).</li> <li>Load the form via intent, with <code>task_id</code> and <code>entity_id</code> fields in query params.</li> <li>On form completion we can update the Entity label and fields.<ul> <li>Set the field <code>status</code> to COMPLETE, IN_PROGRESS, INVALID.</li> <li>Update the entity label to be prefixed with \u2705 \u274c for a nicer visual cue.   https://docs.getodk.org/central-entities/#building-a-form-that-updates-an-entity</li> </ul> </li> </ul>"},{"location":"about/odk-entities/#resources","title":"Resources","text":"<ul> <li>Here's the introductory page from ODK.   discussing the rationale for and use of Entities.   It has some example forms you can use to get started figuring out how to use Entities.</li> <li>Here's the specification for Entities in the XForms language.</li> <li>Here's the ODK Central API documentation for dealing with Entities</li> <li>Here's the ODK Central API documentation for dealing with the \"Datasets\" they are part of</li> <li>Here's a discussion of how you can attach a draft form to an entity \"dataset\"</li> <li>OSM Diary Detailing Entity Usage</li> </ul>"},{"location":"about/odk2osm/","title":"odk2osm","text":"<p>This programs reads the various data formats used with OpenDataKit, and converts them to an OSM XML file, and a GeoJson file. The two formats loaded from ODK Central are a CSV file downloaded from the submissions page, or a JSON file downloaded using ODATA</p> <p>In addition for working offline, this can also parse the ODK XML format used for the instances files in ODK Collect. When working in the field, I use adb to pull files off my smartphone using a USB cable.</p> <p>The options for this program are:</p> <p>Convert ODK XML instance file to OSM XML format</p> <p>options:    -h, --help            show this help message and exit    -v [VERBOSE], --verbose [VERBOSE]        verbose output    -y YAML, --yaml YAML  Alternate YAML file    -x XLSFILE, --xlsfile XLSFILE        Source XLSFile    -i INFILE, --infile INFILE        The input file By default, the xforms.yaml file is used when converting to OSM XML format. Using the --yaml option allows you to have a custom conversion of the data collected by your XLSForm. This only applies to the OSM XML output, when processing the GeoJson file, no conversion is done.</p> <p>The input file is the CSV or JSON file downloaded from ODK Central. ODK Collect stores the instance files in a collection of sub-directories that are timestamped and have a unique instance number as part of the file name. The primary part of the filename is the same as the title of the XLSForm.</p> <p>For example:</p> <p>instances/Buildings_3_2024-05-28_18-34-38/Buildings_3_2024-05-28_18-34-38.xml  instances/Buildings_2_2024-01-24_13-36-20/Buildings_2_2024-01-24_13-36-20.xml  instances/Buildings_3_2024-05-31_11-08-22/Buildings_3_2024-05-31_11-08-22.xml  instances/Buildings_2_2024-01-26_15-16-53/Buildings_2_2024-01-26_15-16-53.xml  instances/Buildings_2_2024-01-26_15-07-17/Buildings_2_2024-01-26_15-07-17.xml  instances/Buildings_3_2024-05-29_11-46-53/Buildings_3_2024-05-29_11-46-53.xml  instances/Buildings_3_2024-06-03_11-14-02/Buildings_3_2024-06-03_11-14-02.xml  instances/Buildings_3_2024-06-03_10-33-27/Buildings_3_2024-06-03_10-33-27.xml  instances/Buildings_2_2024-01-26_11-42-38/Buildings_2_2024-01-26_11-42-38.xml  instances/Buildings_3_2024-05-29_12-13-37/Buildings_3_2024-05-29_12-13-37.xml  ...</p> <p>In this case the parameter passed to odk2osm can contain a regular expression to process multiple files, as each time you open Collect, it creates a new directory and file. The output is a single file. So in this case, run odk2osm like this:</p> <p>odk2osm -v -i Buildings_3* -x Buildings.xls</p> <p>The --xlsfile is used to specigy the XLSForm that was used for this mapping session. This is used to supply the correct data type of each entry collected.</p>"},{"location":"about/odk_client/","title":"ODK Client","text":"<p>odk_client.py is a command line utility for interacting with the ODK Central server. It exposes many of the REST API calls supported by the server and allows users to perform various tasks, such as uploading and downloading attachments and submissions.</p>"},{"location":"about/odk_client/#usage","title":"Usage","text":"<p><code>[-h] [-v] [-s {projects,users,delete}] [-p {forms,app-users,assignments,delete}] [-i ID] [-f FORM] [-u UUID]</code></p> <p><code>[-x {attachments,csv,submissions,upload,download,create,assignments,delete,publish}] [-a {create,delete,update,qrcode,access}] [-d DATA] [-t TIMESTAMP]</code></p> <p><code>[-b {qrcodes,update}]</code></p>"},{"location":"about/odk_client/#command-line-client-for-odk-central","title":"command line client for ODK Central","text":""},{"location":"about/odk_client/#options","title":"Options","text":"<pre><code>  -h, --help            show this help message and exit\n  -v, --verbose         verbose output\n  -s {projects,users,delete}, --server {projects,users,delete}\n                        project operations\n  -p {forms,app-users,assignments,delete}, --project {forms,app-users,assignments,delete}\n                        project operations\n  -i ID, --id ID        Project ID number\n  -f FORM, --form FORM  XForm name\n  -u UUID, --uuid UUID  Submission UUID, needed to download the data\n  -x {attachments,csv,submissions,upload,download,create,assignments,delete,publish}, --xform {attachments,csv,submissions,upload,download,create,assignments,delete,publish}\n                        XForm ID for operations with data files\n  -a {create,delete,update,qrcode,access}, --appuser {create,delete,update,qrcode,access}\n                        App-User operations\n  -d DATA, --data DATA  Data files for upload or download\n  -t TIMESTAMP, --timestamp TIMESTAMP\n                        Timestamp for submissions\n  -b {qrcodes,update}, --bulk {qrcodes,update}\n                        Bulk operations\n</code></pre>"},{"location":"about/odk_client/#server-requests","title":"Server requests","text":"<p>Server requests allow users to access global data about projects and users.</p>"},{"location":"about/odk_client/#usage_1","title":"Usage","text":"<p>The following server-specific commands are supported by ODK Client:</p> <ul> <li> <p><code>--server projects</code></p> <p>This command returns a list of project IDs and their corresponding project names.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage","title":"Example usage","text":"<pre><code>  python odk_client.py --server projects\n</code></pre> <ul> <li> <p><code>--server users</code></p> <p>This command returns a list of user IDs and their corresponding usernames.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_1","title":"Example usage","text":"<pre><code>  python odk_client.py --server users\n</code></pre>"},{"location":"about/odk_client/#project-requests","title":"Project Requests","text":"<p>Project requests allow users to access data for a specific project, such as XForms, attachments, and app users. Projects contain all the Xforms and attachments for that project. To access the data for a project, it is necessary to supply the project ID. That can be retrieved using the above server command. In this example, 1 is used.</p>"},{"location":"about/odk_client/#usage_2","title":"Usage","text":"<p>The following are the project-specific commands supported by ODK Client:</p> <ul> <li> <p><code>--id &lt;project_id&gt; --project forms</code></p> <p>This command returns a list of all the XForms contained in the specified project. Replace <code>\"&lt;project_id&gt;\"</code> with the actual ID of the project you want to retrieve the forms for.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_2","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --project forms\n</code></pre> <ul> <li> <p><code>--id &lt;project_id&gt; --project app-users</code></p> <p>This command returns a list of all the app users who have access to the specified project. Replace <code>\"&lt;project_id&gt;\"</code> with the actual ID of the project you want to retrieve the list of app users for.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_3","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --project app-users\n</code></pre> <p>Note: Replace \"1\" with the actual ID of the project you want to access.</p>"},{"location":"about/odk_client/#xform-requests","title":"XForm Requests","text":"<p>XForm requests allow users to access data for a specific XForm within a project, such as attachments, submissions, and CSV data. An XForm has several components. The primary one is the XForm description itself. In addition to that, there may be additional attachments, usually a CSV file of external data to be used by the XForm. If an XForm has been used to collect data, then it has submissions for that XForm. These can be downloaded as CSV files.</p> <p>To access the data for an XForm, it is necessary to supply the project ID and the XForm ID. The XForm ID can be retrieved using the above project command.</p>"},{"location":"about/odk_client/#usage_3","title":"Usage","text":"<p>The following are the XForm-specific commands supported by ODK Client:</p> <ul> <li> <p><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform attachments</code></p> <p>This command returns a list of all the attachments for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, and \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to retrieve the attachments for.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_4","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --form 1 --xform attachments\n</code></pre> <ul> <li> <p><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform download &lt;attachment_1&gt;,&lt;attachment_2&gt;,...</code></p> <p>This command downloads the specified attachments for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to download the attachments for, and \"<code>&lt;attachment_1&gt;</code>,<code>&lt;attachment_2&gt;</code>,<code>etc...</code>\" with the actual names of the attachments you want to download.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_5","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --form 1 --xform download file1.csv,file2.pdf\n</code></pre> <ul> <li> <p><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform submissions</code></p> <p>This command returns a list of all the submissions for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, and \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to retrieve the submissions for.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_6","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --form 1 --xform submissions\n</code></pre> <ul> <li> <p><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform csv</code></p> <p>This command returns the data for the submissions for the specified XForm in CSV format. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, and \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to retrieve the submission data for.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_7","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --form 1 --xform csv\n</code></pre> <ul> <li> <p><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform upload &lt;attachment_1&gt;,&lt;attachment_2&gt;,...</code></p> <p>This command uploads the specified attachments for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to upload the attachments for, and \"<code>&lt;attachment_1&gt;,&lt;attachment_2&gt;,...</code>\" with the actual names of the attachments you want to upload.</p> </li> </ul>"},{"location":"about/odk_client/#example-usage_8","title":"Example usage","text":"<pre><code>  python odk_client.py --id 1 --form 1 --xform upload file1.csv,file2.pdf\n</code></pre> <p>Note: Replace \"1\" with the actual IDs of the project and XForm you want to access.</p>"},{"location":"about/odk_client/#create-a-new-xform-and-upload-these-two-attachments","title":"Create a new XForm, and upload these two attachments","text":"<p>These two attachments are input for select_from_file in the survey sheet. For osm_fieldwork, they are usually a list of municipalities and towns.</p> <pre><code>./osm_fieldwork/odk_client.py --id 4 --form waterpoints --xform create osm_fieldwork/xlsforms/waterpoints.xml osm_fieldwork/xlsforms/towns.csv osm_fieldwork/xlsforms/municipality.csv\n</code></pre>"},{"location":"about/odk_client/#to-create-a-new-xform-and-upload-two-attachments-follow-these-steps","title":"To create a new XForm and upload two attachments, follow these steps","text":"<ul> <li>Create a new XForm using the ODK XLSForm syntax. You can use any tool that supports this syntax, such as ODK Build or Excel. Save the XLSForm file as \"<code>waterpoints.xml</code>\".</li> </ul> <ul> <li>Next, prepare two CSV files: \"<code>towns.csv</code>\" and \"<code>municipality.csv</code>\". These CSV files should contain the list of municipalities and towns, respectively, that will be used as input for the \"<code>select_from_file</code>\" function in the survey sheet.</li> </ul> <ul> <li>Once you have these files ready, use the osm-fieldwork tool to convert the XLSForm and CSV files into an ODK form. To do this, open a terminal or command prompt and navigate to the \"<code>osm-fieldwork</code>\" directory. Then, run the following command:<pre><code>./osm-fieldwork/odk_client.py --id 4 --form waterpoints --xform create osm-fieldwork/xlsforms/waterpoints.xml osm-fieldwork/xlsforms/towns.csv osm-fieldwork/xlsforms/municipality.csv\n</code></pre> </li> </ul> <p>This command will create a new form with the ID \"4\" and the name \"waterpoints\", using the XLSForm file and the two CSV files as input. The resulting ODK form can be uploaded to an ODK server for use in data collection.</p> <p>Make sure to update the file paths in the command to match the actual location of your XLSForm and CSV files. Additionally, ensure that your CSV files are properly formatted according to the ODK specifications.</p>"},{"location":"about/odk_client/#project-requests_1","title":"Project Requests","text":""},{"location":"about/odk_client/#list-all-the-projects-on-an-odk-central-server","title":"List all the projects on an ODK Central server","text":"<pre><code>./osm_fieldwork/odk_client.py --server projects\n</code></pre>"},{"location":"about/odk_client/#delete-a-project-from-odk-central","title":"Delete a project from ODK Central","text":"<pre><code>./osm_fieldwork/odk_client.py --server delete --id 2\n</code></pre>"},{"location":"about/odk_client/#app-user-requests","title":"App-user Requests","text":""},{"location":"about/odk_client/#create-a-new-app-user-for-a-project","title":"Create a new app-user for a project","text":"<pre><code>./osm_fieldwork/odk_client.py --appuser create --id 4 foobar\n</code></pre>"},{"location":"about/odk_client/#create-a-qr-code-for-the-app-user-to-access-odk-central","title":"Create a QR code for the app-user to access ODK Central","text":"<pre><code>./osm_fieldwork/odk_client.py -i 4 -f waterpoints -a qrcode -u 'jhAbIwHmYCBObnR45l!I3yi$LbCL$q$saJHkDvgwgtKs2F6sso3eepySJ5tyyyAX'\n</code></pre>"},{"location":"about/odk_client/#delete-an-app-user-from-a-project","title":"Delete an app-user from a project","text":"<pre><code>./osm_fieldwork/odk_client.py --appuser delete --id 4 378\n</code></pre>"},{"location":"about/odk_client/#list-all-app-users-for-a-project","title":"List all app-users for a project","text":"<pre><code>./osm_fieldwork/odk_client.py  --id 4 --project app-users\n</code></pre>"},{"location":"about/odk_client/#bulk-operations","title":"Bulk operations","text":"<p>Some commands require multiple queries to ODK Central. As FMTM creates many, many app-users and xforms, it's necessary to be able to clean up the database sometimes, rather than go through Central for hundreds, or thousands of app-users.</p>"},{"location":"about/odk_client/#delete-multiple-app-users-from-a-project","title":"Delete multiple app-users from a project","text":"<pre><code>./osm_fieldwork/odk_client.py --appuser delete --id 4 22-95\n</code></pre>"},{"location":"about/odk_client/#generate-qrcodes-for-all-registered-app-users","title":"Generate QRcodes for all registered app-users","text":"<pre><code>./osm_fieldwork/odk_client.py --id 4 --bulk qrcodes --form waterpoints\n</code></pre> <p>which generates a png file for each app-user, limited to that project.</p>"},{"location":"about/osmfile/","title":"Osmfile.py","text":"<p>Osmfile.py is a Python module that provides functionality for writing OpenStreetMap (OSM) XML format output files. It is used as part of the osm-fieldwork toolset, and can be used as part of a larger Python application. Currently it is only used by the CSVDump.py program.</p> <p>When used, osmfile.py takes a Python data structure containing OSM data as input and generates an OSM XML format output file. The data structure consists of nested Python dictionaries and lists, with each dictionary representing an OSM node, way or relation, and each list representing a set of nodes, ways or relations.</p> <p>For example, consider the following Python data structure representing a single OSM node:</p> <pre><code>node = {\n    'id': 1234,\n    'lat': 51.5074,\n    'lon': -0.1278,\n    'tags': {\n        'name': 'Big Ben',\n        'amenity': 'clock'\n    }\n}\n</code></pre> <p>To write this node to an OSM XML format output file using osmfile.py, you would first create a new osmfile.OsmWriter object, and then call the <code>write()</code> method, passing in the node dictionary as an argument:</p> <pre><code>from osmfile import OsmFile\n\nwriter = OsmFile('output.osm')\nnode_xml = writer.createNode(node)\nway_xml = writer.createWay(way)\nrelation_xml = writer.createRelation(relation)\nwriter.add_tag('1234', 'amenity', 'post_office')\nwriter.write(node_xml)\nwriter.write(way_xml)\nwriter.write(relation_xml)\nwriter.close()\n</code></pre> <p>This would create XML code for the node, way, and relation using createNode(), createWay(), and createRelation() respectively. These methods return a string of XML code which is then written to the output file using writer.write(). The add_tag() method can be used to add additional tags to any of the elements being written to the file.</p> <pre><code>&lt;node id=\"1234\" lat=\"51.5074\" lon=\"-0.1278\"&gt;\n&lt;tag k=\"name\" v=\"Big Ben\"/&gt;\n&lt;tag k=\"amenity\" v=\"clock\"/&gt;\n&lt;/node&gt;\n</code></pre> <p>Osmfile.py also provides methods for writing OSM ways and relations to output files, and for adding tags to existing OSM nodes, ways and relations.</p> <p>To write an OSM way to an output file, you would create a dictionary representing the way, with a <code>nodes</code> key containing a list of the node IDs that make up the way. For example:</p> <pre><code>way = {\n    'id': 5678,\n    'nodes': [1234, 5678, 9012],\n    'tags': {\n        'name': 'Oxford Street',\n        'highway': 'primary'\n    }\n}\n\nwriter.write_way(way)\n</code></pre> <p>This would write the following XML code to the output file:</p> <pre><code>&lt;way id=\"5678\"&gt;\n    &lt;nd ref=\"1234\"/&gt;\n    &lt;nd ref=\"5678\"/&gt;\n    &lt;nd ref=\"9012\"/&gt;\n    &lt;tag k=\"name\" v=\"Oxford Street\"/&gt;\n    &lt;tag k=\"highway\" v=\"primary\"/&gt;\n&lt;/way&gt;\n</code></pre> <p>To write an OSM relation to an output file, you would create a dictionary representing the relation, with a <code>members</code> key containing a list of dictionaries representing the members of the relation. Each member dictionary should have <code>type</code>, <code>ref</code> and <code>role</code> keys, specifying the type of OSM object (node, way or relation), the ID of the object, and the role of the object in the relation. For example:</p> <pre><code>relation = {\n    'id': 7890,\n    'members': [\n        {'type': 'way', 'ref': 5678, 'role': 'outer'},\n        {'type': 'node', 'ref': 1234, 'role': 'admin_centre'}\n    ],\n    'tags': {\n        'name': 'London Borough of Westminster',\n        'type': 'boundary'\n    }\n}\n\nwriter.write_relation(relation)\n</code></pre> <p>This would write the following XML code to the output file:</p> <pre><code>&lt;relation id=\"7890\"&gt;\n    &lt;member type=\"way\" ref=\"5678\" role=\"outer\"/&gt;\n    &lt;member type=\"node\" ref=\"1234\" role=\"admin_centre\"/&gt;\n    &lt;tag k=\"name\" v=\"London Borough of Westminster\"/&gt;\n    &lt;tag k=\"type\" v=\"boundary\"/&gt;\n&lt;/relation&gt;\n</code></pre> <p>In addition to writing new OSM objects to an output file, osmfile.py also provides methods for adding tags to existing objects. To add a tag to an OSM object, you would call the <code>add_tag()</code> method, passing in the object's ID, the tag key and the tag value:</p> <pre><code>writer.add_tag('1234', 'amenity', 'post_office')\n</code></pre> <p>This would add the following XML code to the output file, as a child of the existing <code>node</code> element with ID <code>1234</code>:</p> <pre><code>&lt;tag k=\"amenity\" v=\"post_office\"/&gt;\n</code></pre> <p>Note that the <code>OsmWriter</code> class also provides methods for closing the output file and flushing any buffered data to disk. You should call the <code>close()</code> method once you have finished writing all of your OSM data to the output file.</p>"},{"location":"about/programs/","title":"OSM Fieldwork Programs","text":"<p>OSM Fieldwork contains a few standalone utility programs for converting data from ODK Collect and the ODK Central server, and a few support modules. You can install from the source tree using: pip install .</p> <p>or you can install the package from PyPi.org:</p> <pre><code>pip install osm-fieldwork\n</code></pre>"},{"location":"about/programs/#make_data_extractpy","title":"make_data_extract.py","text":"<p>The <code>make_data_extract.py</code> program is used to extract OpenStreetMap (OSM) data for use with the <code>select_one_from_file</code> function in ODK Collect. This function allows users to select from a list of options generated from an external file. The <code>make_data_extract.py</code> program creates a data extract that can be used as an external file with the <code>select_one_from_file</code> function. There is more detailed information on the program for making data extracts here.</p>"},{"location":"about/programs/#csvdumppy","title":"CSVDump.py","text":"<p>CSVDump.py is program converts a CSV file downloaded from ODK Central to OpenStreetMap (OSM) XML format. The tool can be useful for users who want to work with OpenStreetMap data and want to convert ODK Central data into a compatible format. There is more detailed information on the program for converting ODK to OSM here</p>"},{"location":"about/programs/#parserspy","title":"parsers.py","text":"<p>parsers.py is a program for conflating the OSM XML file produced from CSVDump.py into with the data extract. This merges tags that have been added or changed by ODK Collect with exiting OSM data, The result can be loaded into JOSM and after validation, uploaded to OSM.</p>"},{"location":"about/programs/#osm-fieldwork-modules","title":"OSM Fieldwork Modules","text":""},{"location":"about/programs/#sqlitepy","title":"sqlite.py","text":"<p>This module creates mbtiles or sqlitedb files for basemaps. It's just a wrapper around the existing sqlite3 module to create the output files.</p>"},{"location":"about/programs/#osmfilepy","title":"osmfile.py","text":"<p>Osmfile.py is a module that writes OSM XML files for JOSM. It assumes the data has already been converted using CSVDump. This module is only used from within CSVDump.py. OSM XML format is needed as it's the only format that supports conflation with upstream OSM data. More on writing OSM XML is here.</p>"},{"location":"about/programs/#filter_datapy","title":"filter_data.py","text":"<p>filter_data.py is a program for filtering data extracts. Since an extract can only include tags and values in the XLSform, thuis scans the XLSForm, and is used to remove anything not included in the choices sheet. While usually used as a module, if run standalone it can also compare an XLSForm with the taginfo database to help modify the data models.</p>"},{"location":"about/programs/#convertpy","title":"convert.py","text":"<p>The convert.py module is part of the osm_fieldwork package and provides functionality for converting ODK forms between different formats using a YAML configuration file. More detailed information on this module is here</p>"},{"location":"about/programs/#yamlfilepy","title":"yamlfile.py","text":"<p>This reads in the yaml config file with all the conversion information into a data structure that can be used when processing the data conversion. More detail on this module is here.</p>"},{"location":"about/programs/#odk2csvpy","title":"odk2csv.py","text":"<p>Odk2csv.py is a command-line tool that is part of the osm-fieldwork package. Its main purpose is to convert an ODK XML instance file to CSV format, which can be easily imported into ODK Central for analysis. This is primarily only used when working offline, as it removes the need to access ODK Central.</p> <pre><code>options:\n -h, --help                       - show this help message and exit\n -v, --verbose                    - verbose output\n -i INSTANCE, --instance INSTANCE - The instance file from ODK Collect\n</code></pre>"},{"location":"about/programs/#works-in-progress","title":"Works In Progress","text":""},{"location":"about/programs/#odkdumppy","title":"ODKDump.py","text":"<p>ODKDump.py is a Python module that is part of the OSM-Fieldwork toolset for converting ODK data into various formats. It is used to parse the contents of an ODK Collect Instance file into a readable format. This module currently is not finished, instead use the CSVDump.py utility instead.</p>"},{"location":"about/programs/#odkformpy","title":"ODKForm.py","text":"<p>ODKForm.py parses the XLSXForm, and creates a data structure so any code using this class can access the data types of each input field. This module currently is not finished. It turns out know the input data types is not probably neccesary if we stick to processing the CSV files.</p>"},{"location":"about/programs/#odkinstancepy","title":"ODKInstance.py","text":"<p>ODKInstance.py parses the ODK Collect instanceXML file, and creates a data structure so any code using this class can access the collected data values. This module currently is not finished, instead use the odk2csv.py utility instead.</p>"},{"location":"about/user-manual/","title":"Osm-Fieldwork User Manual","text":"<p>The osm-fieldwork project is a collection of utilities useful for field data collection, focused on OpenStreetMap (OSM) and ODK. Both of these are used heavily for humanitarian and emergency response by many organizations. The problem is these two projects were never designed to work together, so this project was born to fill the gaps. Included are a few other useful utilities for field mapping.</p> <p>This project is also currently part of the backend for the FMTM project, but all of the data processing can also be run standalone, and also works fully offline. All the standalone programs run in a terminal, and are written in Python.</p>"},{"location":"about/user-manual/#odk","title":"ODK","text":"<p>ODK is a format for collecting data on mobile devices, including the spatial coordinates of that data item. The primary source file is a spreadsheet called an XLSForm, which gets converted to an XForm using the xls2xform program. An XForm is is in XML format. All collected data is stored as an instance file, also in XML format on the mobile device, but of course is a different schema than the XForm. Once the data is collected it gets uploaded to an ODK Central server. From there you can download the collected data, called submissions, in CSV or JSON format. The JSON format works better. Here's where the conversion project starts, how to process the downloaded data into something we can upload to OpenStreetMap efficiently.</p> <p>All of the XLSForms included in this project have all been carefully edited to enable a good clean conversion to OSM XML. More information on how to modify the conversion is here. If you base any custom XLSForms from this library, you can also update the conversion criteria. These XLSForms can also be downloaded from FMTM.</p>"},{"location":"about/user-manual/#field-mapping-tasking-manager-fmtm","title":"Field Mapping Tasking Manager (FMTM)","text":"<p>The FMTM is a project to coordinate field data collection in a similar way as the HOT Tasking Manager. But other than the ability to break up a big area into tasks, the rest works very differently. Often mangaing a group doing field mapping is a bit like herding cats. Plus the mappers often aren't sure where they should be mapping, or when they are finished. In addition, it is now possible to load a data extract from OSM into ODK Collect, and use that data to set the default values when collecting the data so the mapper doesn't have to do it. FMTM handles the creation of the data extract, as well as processing the data into a format suitable to edit with JOSM or QGIS. The FMTM backend is a FastAPI wrapped around this project.</p>"},{"location":"about/user-manual/#getting-started","title":"Getting Started","text":"<p>This project is available from PyPi.org, and can be installed like this:</p> <pre><code>pip install osm-fieldwork\n</code></pre> <p>It contains multiple programs, each one that handles a specific part of the conversion process. Each program is a single class so it can be used as part of a FastAPI backend, but also runs standalone for debugging, and working offline. These are all terminal based, as the website frontend is the actual GUI.</p> <ul> <li>json2osm<ul> <li>Convert JSON from Central to OSM XML</li> </ul> </li> <li>csv2osm<ul> <li>Convert CSV from Central to OSM XML</li> </ul> </li> <li>odk2csv<ul> <li>Convert the ODK Instance to CSV</li> </ul> </li> <li>odk2geojson<ul> <li>Convert the ODK Instance to GeoJson</li> </ul> </li> <li>parsers<ul> <li>Conflate POIs from Collect with existing OSM data</li> </ul> </li> <li>odk_client<ul> <li>Remotely control an ODK Central server</li> </ul> </li> </ul> <p>You can also to run the terminal based programs from the source tree, which can be gotten from here:</p> <pre><code>git clone git@github.com:hotosm/osm-fieldwork.git\n</code></pre>"},{"location":"about/user-manual/#processing-submissions","title":"Processing Submissions","text":"<p>This section will focus on converting the JSON format, but the process for converting the CSV submissions is the same. The JSON format seems to be more complete for some XLSForms, so it's preferred. The first step is converting it to OSM XML format, so it can be loaded into JOSM and edited. A YAML based config file is used to convert the JSON format you just downloaded into the OSM XML format.</p> <p>The initial problem is neither the CSV or the JSON format stores the coordinates in a way any editing program wants them. So that's the most important part of the conversion process, generating a data file with spatial coordinates in the right syntax. The conversion process generates two output files, one in OSM XML format, the other in GeoJson format. The OSM XML one has had the data filtered, not everything collected is for OSM. But all the data goes in the GeoJson file, so nothing is lost. Since the GeoJson format does not have to follow OSM syntax, not all the tags and values may be similar to what OSM expects, but that's not a problem for our use case.</p> <p>The config file for conversion has 3 sections, one for all the conversion data, one for data to ignore completely, and a private section for the GeoJson file. The stuff to ignore is extraneous fields added by ODK Collect, like deviceID. Modifying the conversion is straight forward as it's mostly just replacing one set of strings with another.</p> <p>For any of the XLSForms in this project's library, the configuration is already done, but any custom XLSForms will need to modify it to get a good conversion, or fix it in JOSM later. For a one-off project, like an import, I usually get lazy and fix it in JOSM. But for anything used several times, that gets old, so it's better to improve the config file.</p> <p>To convert the JSON format file downloaded for ODK Central, run this program:</p> <p>json2osm.py -i Submissions.json json2osm.py -i Submissions.json -y custom.yaml</p> <p>or for the CSVfile:</p> <pre><code>CSVDump.py -i Submissions.csv\nCSVDump.py -i Submissions.csv -u custom.yaml\n</code></pre> <p>which produces a Submissions.osm and Submissions.geojson files from that data. The OSM XML file may have tags that got missed by the conversion process, but the advantage is now all the data can be viewed and edited by JOSM. If you want a clean conversion, edit the config file and use that as an alternate for converting the data.</p> <pre><code>json2osm -i Submissions.json -x custom.yaml\n</code></pre>"},{"location":"about/user-manual/#data-conflation","title":"Data Conflation","text":"<p>Now you have a file that can be viewed or edited, but it's all collected, but some of the features may already exist in OSM. This can be done manually in JOSM, which is ok for small datasets, but it's easier to apply a little automated help. It's possible to find similar features in OSM that are near the data we just collected for a building, but has the same business name. How to conflate the collected data with existing OSM data is another document.</p> <p>To just use the conflation software requires setting up a postgres database containing the OSM data for the county, region, state, country, ect... You can also use the data extract from FMTM, as it covers the same area the data was collected in. FMTM allow you to download the data extract used for this task. Postgres works much faster, but the GeoJson data extract works too as the files per task are relativly small.</p> <pre><code>odk_merge.py Submissions.osm PG:\"nepal\" -b kathmanu.geojson\nor\nodk_merge.py Submissions.osm kathmandu.geojson\n</code></pre> <p>In this example, the OSM XML file from the conversion process uses a local postgres data with the country of Nepal loaded into it. You can also specify an alternate boundary so the conflation will use a subset of the entire database to limit the amount of data that has to be queried.</p> <p>Each feature in the submission is queried to find any other features with 2 meters where any tags match. Both POIs and buildings are checked for a possible match. Often the building has \"building=yes\" from remote mapping, so we'd also want to merge the tags from the collected data into the building way. Multiple shops within the same building remain as a POI in that building.</p> <p>There is much more detail on this program here.</p>"},{"location":"about/user-manual/#utility-programs","title":"Utility Programs","text":""},{"location":"about/user-manual/#making-basemaps","title":"Making basemaps","text":"<p>Basemaps are very useful when using ODK Collect in areas where the map data is poor. Imagery is particular is very useful, as you can use that to select a location other than where you are standing. This project has a utility that makes basemaps from several sources. It builds a local tile store, so larger areas can be downloaded and in the field when offline, smaller basemaps can be made from the tile store. Since downloading map tiles is very time consuming, I usually download larger areas and let it download for a few days.</p> <pre><code>basemapper -s esri -b Pokara.geojson -z 8-15 -o pokara.mbtiles\n</code></pre> <p>This command will download all the map tiles from ESRI into an XYZ tile store for zoom levels 8 to 15. Since downloading imagery is slow, I often download larger areas, and then use a subset of the tiles to make smaller basemaps. The mbtiles file can be manually loaded into ODK Collect as a layer, and used to adjust the location of the POI when mapping.</p> <p>Since it often useful for navigation, basemapper can also produce a basemap from the same map tiles for Osmand. This is very useful when in areas with little map data, for example during a remote backcountry trip. This example downloads Bing imagery for Pokara, Nepal.</p> <p>basemapper -s bing -b Pokara.geojson -z 8-19 -o pokara.sqlitedb</p> <p>There is much more detail on this program here.</p>"},{"location":"about/user-manual/#converting-for-an-instance-file","title":"Converting for an Instance File","text":""},{"location":"about/user-manual/#odk2osmpy-odk2geojsonpy-odk2csvpy","title":"odk2osm.py, odk2geojson.py, odk2csv.py","text":"<p>These programs read the XML format used by ODK Collect for Instance files. Since each submission has a separate Instance file, this takes a regular expression, and produces a single output file. This is only used when working offline, so it's possible to edit the recently collected data and update the map data. Very useful when working offline during big disasters.</p> <pre><code>odk2osm -i Highways Paths_2023-07-17\\*\n</code></pre> <p>On your phone, you can find the instance files here:</p> <p>/sdcard/Android/data/org.odk.collect.android/files/projects/[UUID]/instances</p> <p>You can also manually update your data extracts by copying them to /sdcard/Android/data/org.odk.collect.android/files/projects/[UUID]/forms/[Form name]-media/</p> <p>And manually update the XForm by copying them to /sdcard/Android/data/org.odk.collect.android/files/projects/[UUID]/forms/</p>"},{"location":"about/user-manual/#managing-odk-central","title":"Managing ODK Central","text":"<p>[ODK Central](https://docs.getodk.org/central-intro/ is the server side of ODK Collect. It's where XForms are downloaded from, and where submissions go after being sent by Collect. As there are a lot of options, this program is not very user friendly as it's primarily used as part of the backend for the FMTM project, and most people would just use the Central website.</p> <p>However, this can be useful for scripting the server. For example to list all the projects on a remote Central server:</p> <pre><code>odk_client -s projects\n</code></pre> <p>And this lets you download all the submissions to project number 19 and using the XLSForm for buildings.</p> <p>odk_client -v -i 19 -f buildings -x json</p> <p>There is much more detail on this program here.</p>"},{"location":"about/xlsforms/","title":"Improving XLSXForms","text":""},{"location":"about/xlsforms/#document-summary","title":"Document Summary","text":"<p>This documents the process of improving XLSXForms for better mapper efficiency and stability.</p>"},{"location":"about/xlsforms/#background","title":"Background","text":"<p>XLSXForms provides a way to define input fields, their data types, and any constraints or validation rules that apply. It uses the XLSX file format and allows users to create forms by editing spreadsheets. It is compatible with ODK and other data collection platforms.</p> <p>XLSForm is a powerful tool that allows users to create complex forms with advanced functionality, such as conditional questions, complex calculations, and multimedia inputs. However, it has a complex syntax, and it can be difficult for new users to learn. There are a few web-based front-ends for creating and editing XLSForms, but they don't support all of the advanced features of the format.</p> <p>To use an XLSForm with a mobile app, it needs to be converted to the XML-based XForm format used by the apps. This conversion is done using a utility program called xls2xform which is part of the pyxform python package. Once the XLSForm has been converted to an XForm, it can be loaded onto a mobile device and used to collect data in the field.</p> <p>XLSForms are widely used in the humanitarian and development sectors for data collection, monitoring, and evaluation. It is particularly popular for its flexibility and the ease with which it can be customized to meet specific needs. XLSForm has also been adopted by other platforms, such as Kobo Toolbox and SurveyCTO, making it a widely used standard for creating forms for mobile data collection.</p> <p>The two primary mobile apps used at HOT that use XLSForms are OpenMapKit(OMK), and ODK Collect. OMK uses the same XLSX format as ODK Collect or Kobo Collect, so any comments about improving XLSXForms apply all of them. Using OMK has been depreciated as it's functionality has been incorporated into ODK Collect. It is unmaintained, and no longer works on newer phones.</p> <p>Improving XLSXForm design can lead to more efficient data collection, allowing more good quality data to be collected in less time. Also for those of us use ODK based apps to collect data for OpenStreetMap(OSM), a well designed XLSForm is easier to convert and upload to OSM.</p>"},{"location":"about/xlsforms/#odk","title":"ODK","text":"<p>ODK is a software suite that includes a mobile app called ODK Collect and a server called ODK Central. ODK Collect is designed to run on Android devices and enables users to collect data in the field using forms created in the XLSXForms format. ODK Central is a server application that enables users to manage forms, data, and users, as well as to visualize and export collected data.</p> <p>ODK Collect offers a wide range of functionality, including the ability to capture photos, videos, and audio recordings, and to collect GPS coordinates and other metadata. It also supports complex data types, such as repeat groups and geoshapes, and can be customized with the use of various add-ons.</p> <p>While OMK was an earlier version of the ODK Collect app, most of its functionality has been migrated to ODK Collect. However, this document also provides information on how to modify old XForms from the OMK app to work with ODK Collect. ODK Collect is actively maintained, with regular updates and support services provided by the organization behind it.</p>"},{"location":"about/xlsforms/#openmapkit","title":"OpenMapKit","text":"<p>OpenMapKit (OMK) is an extension of ODK that allows users to create professional quality mobile data collection surveys for field data collection. The tool was designed to simplify the process of collecting data for OpenStreetMap (OSM) in the field.</p> <p>It was sponsored by the Red Cross and included a server and a mobile app that rans on Android operating system. However, the use of OMK is no longer recommended as it has not been maintained for several years and its functionality has been incorporated into ODK. It no longer runs on most newer phones.</p> <p>One of the unique features of OMK was the use of a special field called osm in the survey sheet, which is the first page of the XLSX file. Additionally, OMK looked at another sheet called osm which replaced the existing choices sheet. The values in the osm sheet were designed to closely match the tagging scheme used by OpenStreetMap (OSM).</p> <p>Because it is important to get collected data into OSM, the Humanitarian OpenStreetMap Team has developed a project called OSM Fieldwork, which can handle the conversion from ODK formats into OSM.</p> <p>Overall, while OMK has been a useful tool in the past for data collection, it is no longer actively maintained, and users are encouraged to use ODK instead which offers more advanced functionality and support services.</p>"},{"location":"about/xlsforms/#xlsxform-syntax","title":"XLSXForm Syntax","text":"<p>An XLSXForm is the source file for ODK based tools. This is edited in a spreadsheet program like LibreCalc, Excel, or Google Forms. There are also online build tools, but they fail to utilize the full functionality of XLSXForms. The program xls2xform, which is in the pyxform python package converts the spreadsheet to the format used by ODK Collect. You can also upload the spreadsheet to the ODK Central server, and it will convert it there.</p> <p>This document is just a subset of all of syntax, and focuses on the most commonly used ones. To really dig deep into the XLSForm syntax go that documentation page.</p>"},{"location":"about/xlsforms/#sheet-names","title":"Sheet Names","text":"<p>The sheet names are predefined to have specific functionality as follows, and the column headers are used to determine the functionality of the value in the cells of the spreadsheet. The sheets are Survey, Choices, and Settings. A few columns are required to exist in each sheet, the rest are optional.</p>"},{"location":"about/xlsforms/#survey-sheet","title":"Survey Sheet","text":"<ul> <li>This sheet contains all the questions used for collecting data,   and refers to the actual values for each question which are on the   choices sheet.</li> </ul> <p>These are the mandatory column headers in the survey sheet:</p> <ul> <li>Type - The type of question, the most common ones are text,   select_one, select_multiple., and select_from_file The   second argument in the type column is the keyword used as the   list_name in the choices sheet for selection menus</li> <li>Name - Refers to the name of the choice keyword that would be   the tag in the output OSM file</li> <li> <p>Label - Refers to the question the user sees</p> <p>The name and label column headers also support different languages by using a postfix of ::language appended to it, for example label::Nepali(np).</p> <p>These are the optional column headers in the survey sheet:</p> </li> </ul> <ul> <li>Hint - Optional value display with   the question with further information<ul> <li>The hint column also supports different languages by using a   postfix of::languageappended to it, for   example hint::Nepali(np).</li> </ul> </li> <li>Default - Optional default value   for a selection.</li> <li>Required - If the value is 1 or   yes, this field must have an answer. If the value is 0 or no or   blank, then it\u2019s optional.</li> <li>Relevant - Allows to set up   conditional display of questions based on other fields.</li> <li>Appearance - This changes how   input fields are displayed on the screen.</li> <li>Calculation - Do a   calculation, used for dynamic values.</li> <li>Choice_filter - Filters choices based on other surbay answers.</li> <li>Parameters - Change the behaviour of input data, or example the size   of images.</li> </ul>"},{"location":"about/xlsforms/#input-types","title":"Input Types","text":"<p>The Survey sheet has several forms of selecting answers. These allow the mapper to enter an interger, text, or select one or multiple items from a menu.</p>"},{"location":"about/xlsforms/#choices-sheet","title":"Choices Sheet","text":"<p>The choices sheet is used to define the values used for the select_one and select_multiple questions on the survey sheet.</p> <p>The mandatory column headers are:</p> <ul> <li>List_name - This is the name of the list as specified in the   select type in the survey sheet.</li> <li>Name - This becomes the value of the tag in the OSM output file.</li> <li>Label - Refers to what is displayed in the select menu.</li> <li>The label column header also supports different languages by   using a postfix of ::language appended to it, for   example label::Nepali(np).</li> </ul>"},{"location":"about/xlsforms/#settings-sheet","title":"Settings Sheet","text":"<p>For the settings sheet, there are 1 mandatory ones, but I usually always add 2 of the optional ones. This is a simple sheet that contains the version of the sheet, and the title of the input form. The version is used by the server and the mobile apps to track changes in the data format, so it should always be updated after changes are made.</p> <ul> <li>form_title - This is what is displayed in ODK Central</li> <li>form_id - This is a unique ID to identify this XForm.</li> <li>version - This is mandatory, and needs to change after major   change. During development when I make many changes I usually use   NOW() which is the current data. Use the date format with no   spaces.</li> </ul>"},{"location":"about/xlsforms/#mapping-answers-to-osm","title":"Mapping Answers to OSM","text":"<p>When designing an XForm whose data is for OSM, the two key columns that determine the tag &amp; value scheme used in the OSM XML format are name in the survey sheet, which becomes the tag, and name in the choices sheet, which becomes the value. If you are using the OSM Fieldwork project, anything that isn't a one to one match with OSM syntax can be specified in the config file for that project. When using OSM Fieldwork, tags &amp; values can also be specified as private data, which goes into a GeoJson file, and anything that is for OSM goes into an OSM XML file. That file can be edited in JOSM.</p>"},{"location":"about/xlsforms/#screen-layout","title":"Screen Layout","text":"<p>ODK supports multiple options to change the layout of the input fields on the screen. In the XLSXForm, this is under the appearance column. There\u2019s many possible options available to change the layout, but here\u2019s a summary of the primary ones.</p> <ul> <li>Minimal - Answer choices appear in a pull-down menu.</li> <li>Field-list - Entire group of questions appear on one screen</li> <li>Parameter-map - Use a basemap to pick the location</li> <li>Quick - Auto-advances the form to the next question after an   answer is selected</li> </ul> <ul> <li>All fields are grouped together to maximize screen space.</li> <li>When the field-list attribute is set for begin_group, then   multiple questions are on the same screen.</li> <li>The screen can be scrolled if there are more input fields than fit.</li> </ul> type name label appearance begin_group agroup Amenity Details field-list select_one text name Amenity Name minimal select_one amenity amenity Type of Amenity minimal end_group"},{"location":"about/xlsforms/#conditionals","title":"Conditionals","text":"<p>ODK can optionally display input fields for questions based on a selection. Using conditionals allows for a more guided user interface, than just presenting many questions, some of which aren\u2019t relevant to the current mapping task.</p>"},{"location":"about/xlsforms/#using-conditionals","title":"Using Conditionals","text":"<ul> <li>Conditionals go in the relevant column on the survey sheet.</li> <li>A conditional has two parts, the variable from the name column   of a question, and the value to test against, which is one of the   select values.</li> </ul> <p>In the XLSXForm, the spreadsheet should look like this. The amenity menu is only displayed if the answer to the \u201cwhat type of building is this\u201d is \u201ccommercial\u201d.</p> type name label relevant select_one amenity amenity Type of Amenity ${building}=\u2019commercial\u2019 <p>Using conditionals allows for a more dynamic interface, as only relevant questions are displayed. Some questions may have answers that only require a few more questions before being complete. Other answers may generate more questions, for example a commercial building instead of a residence.</p>"},{"location":"about/xlsforms/#grouping","title":"Grouping","text":"<p>ODK supports grouping survey questions together, which when used with conditionals in the relevant column, and attributes from the appearance column, creates a more dynamic user interface. Groups allow more than one question on the screen, which is more efficient than one question per screen, which is the default.</p>"},{"location":"about/xlsforms/#using-grouping","title":"Using Grouping","text":"<ul> <li>Groups are defined in the survey sheet.</li> <li>Using the appearance column can display multiple questions on   each screen, minimizing the actions required to enter data.</li> </ul> <p>Sub groups are also supported. When implemented this way, when the top level group is displayed on the screen, other questions can be dynamically added to the screen display based on what is selected, further minimizing required actions. Using the appearance column settings with grouping can create a more efficient user experience. Ungrouped questions appear one on each screen of the mobile data collection app, requiring one to swipe to the next page for each question.</p> <ul> <li>Begin_group<ul> <li>Can use the relevant column to conditionally display the entire group of questions</li> </ul> </li> <li>End_group<ul> <li>End the group of survey questions</li> </ul> </li> </ul> <p>An example grouping would look like this, and the conditional says to only display this group for commercial buildings.</p> type name label relevant select_one type building What type of building ? begin_group amenity ${building}=\u2019commercial\u2019 select_one amenity amenity Type of Amenity text name What is the name ? end_group <p>In this example, the conditional is applied to the entire group of questions, and not just any individual question. Different questions in the group may have different conditionals.</p>"},{"location":"about/xlsforms/#external-datasets","title":"External Datasets","text":"<p>XLSForms support external datasets, which is useful for common choices that can be shared between multiple XLSForms. CSV, XML, or GeoJson files are supported. The one downside is currently external datasets of choices do not support translations, one language only. Each CSV file needs a header that defines at least the name and label columns. The name becomes the tag in OSM, and the label is what ODK Collect displays in the select menu. An id column is also required. Anything else becomes a column in the XLSForm.</p> <p>An example CSV data file would look like this:</p> label name backcountry id ref tourism openfire Test 1 Site 1 yes 5483233147 1 camp_pitch yes Test 2 Site 35 no 6764555904 35 camp_pitch yes <p>For example, these rows in the survey sheet will load the data from the CSV file. The instance is the name of the data file, minus the suffix. The item is what the XForm has in the name column for the select_one_from_file. Then the last part is the column from the OSM data. Whenever the value of test is changed, the trigger goes off, and the value is recalculated and becomes the default value for the survey question.</p> type name label calculation trigger choice select_one_from_file test.csv test CSV test true() calculate xname Name instance('test')/root/item[name=${test}]/label ${test} text debug Name is ${xname} ${test}"},{"location":"about/xlsforms/#geojson-files","title":"GeoJson Files","text":"<p>An external file in GeoJson format works slightly differently, as it also contains GPS coordinates. This allows ODK Collect to display data on the map as an overlay that can be selected. This lets us make a data extract from OSM data and edit it. In OSM, many buildings are tagged building=yes, as that\u2019s about all you can do when doing remote mapping off satellite imagery. ODK Collect can\u2019t handle polygons yet, so a data extract has to use only POIs. To use a GeoJson file, just change the file name in this example. The only other difference is that since the GeoJson data file contains GPS coordinates, you can get either a map or a normal selection menu. To get the map view, put map in the appearance column.</p> <p>When using a GeoJson data file, after opening the XForm, you\u2019ll get a button to select an existing POI. That\u2019ll open either the menu, or the map. For the map view, you\u2019ll see blue markers where the existing features are, Touching an icon loads that data into ODK Collect. You can access the values in the OSM data the same as the above example.</p>"},{"location":"about/xlsforms/#openstreetmap-data","title":"OpenStreetMap Data","text":"<p>OpenStreetMap (OSM) is a popular tool for mapping and collecting geographic data, and many OSM mappers have wanted the ability to edit data in the field. While mobile apps like StreetComplete or Vespucci allow for this, they don't focus on humanitarian data collection, which can lead to incomplete tags on many features. Until recently, OSM mappers collected a new point of interest (POI) in the field and merged the data manually later on using an editor like JOSM. However, with the addition of functionality to ODK Collect, it's now possible to load data from OSM into the app and use XForms to improve feature data, achieving tag completeness and limiting tag values to accepted values.</p> <p>In the past, if a mapper collected a new point of interest (POI) in the field, they would have to manually merge the data later using an editor like JOSM because OSM data typically had few tags beyond building=yes due to the majority of features being added by remote mapping. However, with the recent addition of functionality in ODK Collect, it is now possible to load data from OSM into ODK Collect. This allows for the use of an XForm to improve feature data, which achieves tag completeness for a feature and limits the tag values to accepted values.</p> <p>To create a data extract from OSM, one can use Overpass Turbo or Postgres. Each tag in OSM becomes a column in an XForm, and the column names are used to reference the data from within the XForm. If you are using the OSM data to set the default value for a select_one_from_file, then every possible value used for that tag needs to be in the choices sheet. Otherwise, you will get an error such as doctor is not in the choices for healthcare.</p> <p>Using OSM in ODK Collect requires two data conversion processes. The first step is to produce the data extract. Since the goal is to convert the data from ODK into OSM, OSM standard tags should be used in the name column in the survey and choices sheets. When doing a query to Overpass or Postgres, the column name will conflict with what is in the survey sheet, so the data extract needs to use something else. For Postgres, this is easy as you can use the AS command in the query to rename the column to whatever you want. Abbreviations or the OSM tag's name are often used as variable names internally, but the important thing is to ensure that they are unique and do not conflict with other names in the XForm. There is a much more detailed document on using OSM data extracts in this Dealing with External Data in ODK document.</p> <p></p>"},{"location":"about/xlsforms/#converting-from-omk-to-odk","title":"Converting from OMK to ODK","text":"<p>The OMK mobile app was used for collecting location data using the GPS on the device, or tapping on a basemap. Because that functionality is now in ODK, the usage of the OMK mobile app is not required, and is not maintained and may be unreliable. This section is only useful if you find yourself with an old XForm that you want to edit and reuse, as none of it applies to ODK or Kobo Collect.</p>"},{"location":"about/xlsforms/#step-1-prepare-data","title":"Step 1 - Prepare Data","text":"<p>The first step is to copy the contents of the osm sheet into the choices sheet, The other option is to delete the choices sheet, and then rename the osm sheet to choices.</p>"},{"location":"about/xlsforms/#step-2-migrate-questions","title":"Step 2 - Migrate Questions","text":"<p>The next step is to migrate the questions. The osm keyword in the survey sheet is followed by a variable name, for example in this table, building_tags is the variable. When looking at the choices sheet, every row using the building_tag keyword now has to become a question on the survey sheet.</p> type name label required osm building_tags osm_building Building Form yes <p>In the choices sheet, we see this existing data.</p> list_name name label building_tags name Name of this building building_tags building:material What is it made from ? building_tags building:roof What is the roof made of ? <p>Cut &amp; paste these rows from the choices sheet, and paste them into the survey sheet. Then prefix the variable with selct_one or select_multiple. Drop the prefix used in the choices sheet and simplify it.</p> type name label text name Name of this building select_one building:material material What is it made from ? select_one building:roof roof What is the roof made of ?"},{"location":"about/xlsforms/#step-3-get-coordinates","title":"Step 3 - Get Coordinates","text":"<p>The last step is replacing the keyword that used to start OMK, with the ODK way. There are three ODK keywords that can be used to get a location.</p> <ul> <li>Geopoint - Collect a single location</li> <li>Geoshape - Collect at least 3 points and the ends are closed</li> <li>Geotrace - Collect a trace of a line</li> </ul> <p>By default these keywords only allow you to get the location of where the user is located. If you want to use a basemap and tap on the screen where you want to get the location, add placement-map into the appearances column.</p> <p>After doing these three steps, your XLSXForm is converted to not use the OMK app anymore.</p>"},{"location":"about/xlsforms/#xlsxform-suggestions","title":"XLSXForm Suggestions","text":"<p>Since mobile data collection often involves gathering many of the same types of data, setting defaults helps reduce the number of user actions needed to collect data. When collecting multiples of the same type of data,good defaults can record data even when only the location has changed.</p>"},{"location":"about/yamlfile/","title":"Yamlfile","text":""},{"location":"about/yamlfile/#yamlfilepy","title":"yamlfile.py","text":"<p>This reads in the yaml config file with all the conversion information into a data structure that can be used when processing the data conversion.</p> <p><code>yamlfile.py</code> is a module that reads in a YAML config file containing information about how to convert data between different formats. The config file contains a list of conversion rules, where each rule specifies the source format, the target format, and any additional information needed to perform the conversion. The module parses the YAML file and creates a Python object representing the conversion rules, which can be used by other code in the conversion process.</p> <p>To use <code>yamlfile.py</code>, you first need to create a YAML config file containing the conversion rules. Here's an example of a simple YAML config file that converts CSV files to ODK Collect forms:</p> <pre><code>- source: csv\ntarget: odk\nsettings:\n    form_id: my_form\n    form_title: My Form\n    form_version: 1.0\n    csv_delimiter: \",\"\n</code></pre> <p>This rule specifies that CSV files should be converted to ODK Collect forms, with the specified settings. The <code>settings</code> dictionary contains additional information needed to perform the conversion, such as the form ID, form title, form version, and the delimiter used in the CSV file.</p> <p>Once you have created the YAML config file, you can use <code>yamlfile.py</code> to read it into a Python object. Here's an example of how to use the <code>read_yaml_file()</code> function to read the YAML config file:</p> <pre><code>import yamlfile\n\nconfig_file = 'my_config.yaml'\nconversion_rules = yamlfile.read_yaml_file(config_file)\n</code></pre> <p>This will read the <code>my_config.yaml</code> file and return a Python list containing the conversion rules.</p> <p>You can then use the conversion rules to perform the actual data conversion. Here's an example of how to use the <code>get_conversion_rule()</code> function to get the conversion rule for a specific source and target format:</p> <pre><code>import yamlfile\n\nconfig_file = 'my_config.yaml'\nconversion_rules = yamlfile.read_yaml_file(config_file)\n\nsource_format = 'csv'\ntarget_format = 'odk'\nconversion_rule = yamlfile.get_conversion_rule(conversion_rules, source_format, target_format)\n\n# Perform the conversion using the conversion rule\n</code></pre> <p>This will search through the list of conversion rules for a rule that matches the specified source and target format, and return the matching rule. You can then use the conversion rule to perform the actual data conversion.</p> <p>Note that <code>yamlfile.py</code> relies on the PyYAML library to parse the YAML file. If you don't have PyYAML installed, you will need to install it using a package manager like <code>pip</code> before you can use <code>yamlfile.py</code>.</p> <p>To handle errors when reading the YAML config file, <code>yamlfile.py</code> raises a <code>YamlFileError</code> exception. This exception is raised if the YAML file is not found, if the YAML file is malformed, or if a required field is missing from the conversion rule. You can catch this exception and handle it appropriately in your code.</p> <p>Here's an example of how to catch the <code>YamlFileError</code> exception:</p> <pre><code>import yamlfile\n\nconfig_file = 'my_config.yaml'\n\ntry:\n    conversion_rules = yamlfile.read_yaml_file(config_file)\nexcept yamlfile.YamlFileError as e:\n    print(f\"Error reading YAML file: {str(e)}\")\n</code></pre> <p>This will catch any YamlFileError exceptions raised by <code>read_yaml_file()</code> and print an error message.</p> <p>In summary, <code>yamlfile.py</code> is a module that reads in a YAML config file containing conversion rules and creates a Python object representing the rules. This object can be used by other code in the data conversion process. To use <code>yamlfile.py</code>, you need to create a YAML config file containing conversion rules, and then use the <code>read_yaml_file()</code> function to read the file into a Python object. You can then use the object to get the conversion rule for a specific source and target format, and perform the actual data conversion.</p>"},{"location":"api/OdkCentral/","title":"OdkCentral","text":"<p>Download a list of submissions from ODK Central.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xforms</code> <code>list</code> <p>A list of the XForms to down the submissions from</p> required <code>odk_credentials</code> <code>dict</code> <p>The authentication credentials for ODK Collect</p> required <p>Returns:</p> Type Description <code>list</code> <p>The submissions in JSON format</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def downloadThread(project_id: int, xforms: list, odk_credentials: dict, filters: dict = None):\n    \"\"\"Download a list of submissions from ODK Central.\n\n    Args:\n        project_id (int): The ID of the project on ODK Central\n        xforms (list): A list of the XForms to down the submissions from\n        odk_credentials (dict): The authentication credentials for ODK Collect\n\n    Returns:\n        (list): The submissions in JSON format\n    \"\"\"\n    timer = Timer(text=\"downloadThread() took {seconds:.0f}s\")\n    timer.start()\n    data = list()\n    # log.debug(f\"downloadThread() called! {len(xforms)} xforms\")\n    for task in xforms:\n        form = OdkForm(odk_credentials[\"url\"], odk_credentials[\"user\"], odk_credentials[\"passwd\"])\n        # submissions = form.getSubmissions(project_id, task, 0, False, True)\n        subs = form.listSubmissions(project_id, task, filters)\n        if not subs:\n            log.error(f\"Failed to get submissions for project ({project_id}) task ({task})\")\n            continue\n        # log.debug(f\"There are {len(subs)} submissions for {task}\")\n        if len(subs[\"value\"]) &gt; 0:\n            data += subs[\"value\"]\n    # log.debug(f\"There are {len(xforms)} Xforms, and {len(submissions)} submissions total\")\n    timer.stop()\n    return data\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>OdkCentral</code> <p>An instance of this class</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"A Class for accessing an ODK Central server via it's REST API.\n\n    Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central\n\n    Returns:\n        (OdkCentral): An instance of this class\n    \"\"\"\n    if not url:\n        url = os.getenv(\"ODK_CENTRAL_URL\", default=None)\n    self.url = url\n    if not user:\n        user = os.getenv(\"ODK_CENTRAL_USER\", default=None)\n    self.user = user\n    if not passwd:\n        passwd = os.getenv(\"ODK_CENTRAL_PASSWD\", default=None)\n    self.passwd = passwd\n    verify = os.getenv(\"ODK_CENTRAL_SECURE\", default=True)\n    if type(verify) == str:\n        self.verify = verify.lower() in (\"true\", \"1\", \"t\")\n    else:\n        self.verify = verify\n    # Set cert bundle path for requests in environment\n    if self.verify:\n        os.environ[\"REQUESTS_CA_BUNDLE\"] = \"/etc/ssl/certs/ca-certificates.crt\"\n    # These are settings used by ODK Collect\n    self.general = {\n        \"form_update_mode\": \"match_exactly\",\n        \"autosend\": \"wifi_and_cellular\",\n    }\n    # If there is a config file with authentication setting, use that\n    # so we don't have to supply this all the time. This is only used\n    # when odk_client is used, and no parameters are passed in.\n    if not self.url:\n        # log.debug(\"Configuring ODKCentral from file .odkcentral\")\n        home = os.getenv(\"HOME\")\n        config = \".odkcentral\"\n        filespec = home + \"/\" + config\n        if os.path.exists(filespec):\n            file = open(filespec, \"r\")\n            for line in file:\n                # Support embedded comments\n                if line[0] == \"#\":\n                    continue\n                # Read the config file for authentication settings\n                tmp = line.split(\"=\")\n                if tmp[0] == \"url\":\n                    self.url = tmp[1].strip(\"\\n\")\n                if tmp[0] == \"user\":\n                    self.user = tmp[1].strip(\"\\n\")\n                if tmp[0] == \"passwd\":\n                    self.passwd = tmp[1].strip(\"\\n\")\n        else:\n            log.warning(f\"Authentication settings missing from {filespec}\")\n    else:\n        log.debug(f\"ODKCentral configuration parsed: {self.url}\")\n    # Base URL for the REST API\n    self.version = \"v1\"\n    # log.debug(f\"Using {self.version} API\")\n    self.base = self.url + \"/\" + self.version + \"/\"\n\n    # Use a persistant connect, better for multiple requests\n    self.session = requests.Session()\n\n    # Authentication with session token\n    self.authenticate()\n\n    # These are just cached data from the queries\n    self.projects = dict()\n    self.users = list()\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>OdkCentral</code></p> <p>Class to manipulate a project on an ODK Central server.</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central.\n</code></pre> <p>Returns:</p> Type Description <code>OdkProject</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central.\n\n    Returns:\n        (OdkProject): An instance of this object\n    \"\"\"\n    super().__init__(url, user, passwd)\n    self.forms = list()\n    self.submissions = list()\n    self.data = None\n    self.appusers = None\n    self.id = None\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>OdkCentral</code></p> <p>Class to manipulate a form on an ODK Central server.</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central.\n</code></pre> <p>Returns:</p> Type Description <code>OdkForm</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central.\n\n    Returns:\n        (OdkForm): An instance of this object\n    \"\"\"\n    super().__init__(url, user, passwd)\n    self.name = None\n    # Draft is for a form that isn't published yet\n    self.draft = False\n    self.published = False\n    # this is only populated if self.getDetails() is called first.\n    self.data = {}\n    self.attach = []\n    self.media = {}\n    self.xml = None\n    self.submissions = []\n    self.appusers = {}\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.authenticate","title":"authenticate","text":"<pre><code>authenticate(url=None, user=None, passwd=None)\n</code></pre> <p>Setup authenticate to an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A response from ODK Central after auth</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def authenticate(\n    self,\n    url: str = None,\n    user: str = None,\n    passwd: str = None,\n):\n    \"\"\"Setup authenticate to an ODK Central server.\n\n    Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central\n\n    Returns:\n        (requests.Response): A response from ODK Central after auth\n    \"\"\"\n    if not self.url:\n        self.url = url\n    if not self.user:\n        self.user = user\n    if not self.passwd:\n        self.passwd = passwd\n\n    # Get a session token\n    try:\n        response = self.session.post(\n            f\"{self.base}sessions\",\n            json={\n                \"email\": self.user,\n                \"password\": self.passwd,\n            },\n        )\n    except requests.exceptions.ConnectionError as request_error:\n        # URL does not exist\n        raise ConnectionError(\"Failed to connect to Central. Is the URL valid?\") from request_error\n\n    if response.status_code == 401:\n        # Unauthorized, invalid credentials\n        raise ConnectionError(\"ODK credentials are invalid, or may have changed. Please update them.\") from None\n    elif not response.ok:\n        # Handle other errors\n        response.raise_for_status()\n\n    self.session.headers.update({\"Authorization\": f\"Bearer {response.json().get('token')}\"})\n\n    # Connect to the server\n    return self.session.get(self.url, verify=self.verify)\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.listProjects","title":"listProjects","text":"<pre><code>listProjects()\n</code></pre> <p>Fetch a list of projects from an ODK Central server, and store it as an indexed list.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of projects on a ODK Central server</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listProjects(self):\n    \"\"\"Fetch a list of projects from an ODK Central server, and\n    store it as an indexed list.\n\n    Returns:\n        (list): A list of projects on a ODK Central server\n    \"\"\"\n    log.info(\"Getting a list of projects from %s\" % self.url)\n    url = f\"{self.base}projects\"\n    result = self.session.get(url, verify=self.verify)\n    projects = result.json()\n    for project in projects:\n        if isinstance(project, dict):\n            if project.get(\"id\") is not None:\n                self.projects[project[\"id\"]] = project\n        else:\n            log.info(\"No projects returned. Is this a first run?\")\n    return projects\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.createProject","title":"createProject","text":"<pre><code>createProject(name)\n</code></pre> <p>Create a new project on an ODK Central server if it doesn't already exist.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the new project</p> required <p>Returns:</p> Type Description <code>json</code> <p>The response from ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def createProject(\n    self,\n    name: str,\n) -&gt; dict:\n    \"\"\"Create a new project on an ODK Central server if it doesn't\n    already exist.\n\n    Args:\n        name (str): The name for the new project\n\n    Returns:\n        (json): The response from ODK Central\n    \"\"\"\n    log.debug(f\"Checking if project named {name} exists already\")\n    exists = self.findProject(name=name)\n    if exists:\n        log.debug(f\"Project named {name} already exists.\")\n        return exists\n    else:\n        url = f\"{self.base}projects\"\n        log.debug(f\"POSTing project {name} to {url} with verify={self.verify}\")\n        try:\n            result = self.session.post(url, json={\"name\": name}, verify=self.verify, timeout=4)\n            result.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            log.error(e)\n            log.error(\"Failed to submit to ODKCentral\")\n        json_response = result.json()\n        log.debug(f\"Returned: {json_response}\")\n        # update the internal list of projects\n        self.listProjects()\n        return json_response\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.deleteProject","title":"deleteProject","text":"<pre><code>deleteProject(project_id)\n</code></pre> <p>Delete a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>str</code> <p>The project name</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def deleteProject(\n    self,\n    project_id: int,\n):\n    \"\"\"Delete a project on an ODK Central server.\n\n    Args:\n        project_id (int): The ID of the project on ODK Central\n\n    Returns:\n        (str): The project name\n    \"\"\"\n    url = f\"{self.base}projects/{project_id}\"\n    self.session.delete(url, verify=self.verify)\n    # update the internal list of projects\n    self.listProjects()\n    return self.findProject(project_id=project_id)\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.findProject","title":"findProject","text":"<pre><code>findProject(name=None, project_id=None)\n</code></pre> <p>Get the project data from Central.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>the project data from ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def findProject(\n    self,\n    name: str = None,\n    project_id: int = None,\n):\n    \"\"\"Get the project data from Central.\n\n    Args:\n        name (str): The name of the project\n\n    Returns:\n        (dict): the project data from ODK Central\n    \"\"\"\n    # First, populate self.projects\n    self.listProjects()\n\n    if self.projects:\n        if name:\n            log.debug(f\"Finding project by name: {name}\")\n            for _key, value in self.projects.items():\n                if name == value[\"name\"]:\n                    log.info(f\"ODK project found: {name}\")\n                    return value\n        if project_id:\n            log.debug(f\"Finding project by id: {project_id}\")\n            for _key, value in self.projects.items():\n                if project_id == value[\"id\"]:\n                    log.info(f\"ODK project found: {project_id}\")\n                    return value\n    return None\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.findAppUser","title":"findAppUser","text":"<pre><code>findAppUser(user_id, name=None)\n</code></pre> <p>Get the data for an app user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID of the app-user on ODK Central</p> required <code>name</code> <code>str</code> <p>The name of the app-user on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The data for an app-user on ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def findAppUser(\n    self,\n    user_id: int,\n    name: str = None,\n):\n    \"\"\"Get the data for an app user.\n\n    Args:\n        user_id (int): The user ID of the app-user on ODK Central\n        name (str): The name of the app-user on ODK Central\n\n    Returns:\n        (dict): The data for an app-user on ODK Central\n    \"\"\"\n    if self.appusers:\n        if name is not None:\n            result = [d for d in self.appusers if d[\"displayName\"] == name]\n            if result:\n                return result[0]\n            else:\n                log.debug(f\"No user found with name: {name}\")\n                return None\n        if user_id is not None:\n            result = [d for d in self.appusers if d[\"id\"] == user_id]\n            if result:\n                return result[0]\n            else:\n                log.debug(f\"No user found with id: {user_id}\")\n                return None\n    return None\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.listUsers","title":"listUsers","text":"<pre><code>listUsers()\n</code></pre> <p>Fetch a list of users on the ODK Central server.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of users on ODK Central, not app-users</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listUsers(self):\n    \"\"\"Fetch a list of users on the ODK Central server.\n\n    Returns:\n        (list): A list of users on ODK Central, not app-users\n    \"\"\"\n    log.info(\"Getting a list of users from %s\" % self.url)\n    url = self.base + \"users\"\n    result = self.session.get(url, verify=self.verify)\n    self.users = result.json()\n    return self.users\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    # print(\"URL: %s\" % self.url)\n    # print(\"User: %s\" % self.user)\n    # print(\"Passwd: %s\" % self.passwd)\n    print(\"REST URL: %s\" % self.base)\n\n    print(\"There are %d projects on this server\" % len(self.projects))\n    for id, data in self.projects.items():\n        print(\"\\t %s: %s\" % (id, data[\"name\"]))\n    if self.users:\n        print(\"There are %d users on this server\" % len(self.users))\n        for data in self.users:\n            print(\"\\t %s: %s\" % (data[\"id\"], data[\"email\"]))\n    else:\n        print(\"There are no users on this server\")\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getData","title":"getData","text":"<pre><code>getData(keyword)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for the keyword</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getData(\n    self,\n    keyword: str,\n):\n    \"\"\"Args:\n        keyword (str): The keyword to search for.\n\n    Returns:\n        (json): The data for the keyword\n    \"\"\"\n    return self.data[keyword]\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.listForms","title":"listForms","text":"<pre><code>listForms(project_id, metadata=False)\n</code></pre> <p>Fetch a list of forms in a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of XForms in this project</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listForms(self, project_id: int, metadata: bool = False):\n    \"\"\"Fetch a list of forms in a project on an ODK Central server.\n\n    Args:\n        project_id (int): The ID of the project on ODK Central\n\n    Returns:\n        (list): The list of XForms in this project\n    \"\"\"\n    url = f\"{self.base}projects/{project_id}/forms\"\n    if metadata:\n        self.session.headers.update({\"X-Extended-Metadata\": \"true\"})\n    result = self.session.get(url, verify=self.verify)\n    self.forms = result.json()\n    return self.forms\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getAllSubmissions","title":"getAllSubmissions","text":"<pre><code>getAllSubmissions(project_id, xforms=None, filters=None)\n</code></pre> <p>Fetch a list of submissions in a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xforms</code> <code>list</code> <p>The list of XForms to get the submissions of</p> <code>None</code> <p>Returns:</p> Type Description <code>json</code> <p>All of the submissions for all of the XForm in a project</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getAllSubmissions(self, project_id: int, xforms: list = None, filters: dict = None):\n    \"\"\"Fetch a list of submissions in a project on an ODK Central server.\n\n    Args:\n        project_id (int): The ID of the project on ODK Central\n        xforms (list): The list of XForms to get the submissions of\n\n    Returns:\n        (json): All of the submissions for all of the XForm in a project\n    \"\"\"\n    # The number of threads is based on the CPU cores\n    info = get_cpu_info()\n    self.cores = info[\"count\"]\n\n    timer = Timer(text=\"getAllSubmissions() took {seconds:.0f}s\")\n    timer.start()\n    if not xforms:\n        xforms_data = self.listForms(project_id)\n        xforms = [d[\"xmlFormId\"] for d in xforms_data]\n\n    chunk = round(len(xforms) / self.cores) if round(len(xforms) / self.cores) &gt; 0 else 1\n    last_slice = len(xforms) if len(xforms) % chunk == 0 else len(xforms) - 1\n    cycle = range(0, (last_slice + chunk) + 1, chunk)\n    future = None\n    result = None\n    previous = 0\n    newdata = list()\n\n    # single threaded for easier debugging\n    # for current in cycle:\n    #     if previous == current:\n    #         continue\n    #     result = downloadThread(project_id, xforms[previous:current])\n    #     previous = current\n    #     newdata += result\n\n    odk_credentials = {\"url\": self.url, \"user\": self.user, \"passwd\": self.passwd}\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=self.cores) as executor:\n        futures = list()\n        for current in cycle:\n            if previous == current:\n                continue\n            result = executor.submit(downloadThread, project_id, xforms[previous:current], odk_credentials, filters)\n            previous = current\n            futures.append(result)\n        for future in concurrent.futures.as_completed(futures):\n            log.debug(\"Waiting for thread to complete..\")\n            data = future.result(timeout=10)\n            if len(data) &gt; 0:\n                newdata += data\n    timer.stop()\n    return newdata\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.listAppUsers","title":"listAppUsers","text":"<pre><code>listAppUsers(projectId)\n</code></pre> <p>Fetch a list of app users for a project from an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of app-users on ODK Central for this project</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listAppUsers(\n    self,\n    projectId: int,\n):\n    \"\"\"Fetch a list of app users for a project from an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n\n    Returns:\n        (list): A list of app-users on ODK Central for this project\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/app-users\"\n    result = self.session.get(url, verify=self.verify)\n    self.appusers = result.json()\n    return self.appusers\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.listAssignments","title":"listAssignments","text":"<pre><code>listAssignments(projectId)\n</code></pre> <p>List the Role &amp; Actor assignments for users on a project.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The list of assignments</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listAssignments(\n    self,\n    projectId: int,\n):\n    \"\"\"List the Role &amp; Actor assignments for users on a project.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n\n    Returns:\n        (json): The list of assignments\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/assignments\"\n    result = self.session.get(url, verify=self.verify)\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getDetails","title":"getDetails","text":"<pre><code>getDetails(projectId)\n</code></pre> <p>Get all the details for a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>Get the data about a project on ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getDetails(\n    self,\n    projectId: int,\n):\n    \"\"\"Get all the details for a project on an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n\n    Returns:\n        (json): Get the data about a project on ODK Central\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}\"\n    result = self.session.get(url, verify=self.verify)\n    self.data = result.json()\n    return self.data\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getFullDetails","title":"getFullDetails","text":"<pre><code>getFullDetails(projectId)\n</code></pre> <p>Get extended details for a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>Get the data about a project on ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getFullDetails(\n    self,\n    projectId: int,\n):\n    \"\"\"Get extended details for a project on an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n\n    Returns:\n        (json): Get the data about a project on ODK Central\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}\"\n    self.session.headers.update({\"X-Extended-Metadata\": \"true\"})\n    result = self.session.get(url, verify=self.verify)\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    super().dump()\n    if self.forms:\n        print(\"There are %d forms in this project\" % len(self.forms))\n        for data in self.forms:\n            print(\"\\t %s(%s): %s\" % (data[\"xmlFormId\"], data[\"version\"], data[\"name\"]))\n    if self.data:\n        print(\"Project ID: %s\" % self.data[\"id\"])\n    print(\"There are %d submissions in this project\" % len(self.submissions))\n    for data in self.submissions:\n        print(\"\\t%s: %s\" % (data[\"instanceId\"], data[\"createdAt\"]))\n    print(\"There are %d app users in this project\" % len(self.appusers))\n    for data in self.appusers:\n        print(\"\\t%s: %s\" % (data[\"id\"], data[\"displayName\"]))\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.updateReviewState","title":"updateReviewState","text":"<pre><code>updateReviewState(projectId, xmlFormId, instanceId, review_state)\n</code></pre> <p>Updates the review state of a submission in ODK Central.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the odk project.</p> required <code>xmlFormId</code> <code>str</code> <p>The ID of the form.</p> required <code>instanceId</code> <code>str</code> <p>The ID of the submission instance.</p> required <code>review_state</code> <code>dict</code> <p>The updated review state.</p> required Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def updateReviewState(self, projectId: int, xmlFormId: str, instanceId: str, review_state: dict) -&gt; dict:\n    \"\"\"Updates the review state of a submission in ODK Central.\n\n    Args:\n        projectId (int): The ID of the odk project.\n        xmlFormId (str): The ID of the form.\n        instanceId (str): The ID of the submission instance.\n        review_state (dict): The updated review state.\n    \"\"\"\n    try:\n        url = f\"{self.base}projects/{projectId}/forms/{xmlFormId}/submissions/{instanceId}\"\n        result = self.session.patch(url, json=review_state)\n        result.raise_for_status()\n        return result.json()\n    except Exception as e:\n        log.error(f\"Error updating review state: {e}\")\n        return {}\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getDetails","title":"getDetails","text":"<pre><code>getDetails(projectId, xform)\n</code></pre> <p>Get all the details for a form on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getDetails(\n    self,\n    projectId: int,\n    xform: str,\n) -&gt; dict:\n    \"\"\"Get all the details for a form on an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (json): The data for this XForm\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}\"\n    result = self.session.get(url, verify=self.verify)\n    self.data = result.json()\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getFullDetails","title":"getFullDetails","text":"<pre><code>getFullDetails(projectId, xform)\n</code></pre> <p>Get the full details for a form on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getFullDetails(\n    self,\n    projectId: int,\n    xform: str,\n):\n    \"\"\"Get the full details for a form on an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (json): The data for this XForm\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}\"\n    self.session.headers.update({\"X-Extended-Metadata\": \"true\"})\n    result = self.session.get(url, verify=self.verify)\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getXml","title":"getXml","text":"<pre><code>getXml(projectId, xform)\n</code></pre> <p>Get the form XML from the ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw XML form.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getXml(\n    self,\n    projectId: int,\n    xform: str,\n):\n    \"\"\"Get the form XML from the ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        xform (str): The XForm to get the details of from ODK Central.\n\n    Returns:\n        (str): The raw XML form.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}.xml\"\n    result = self.session.get(url, verify=self.verify)\n\n    if result.status_code != 200:\n        result.raise_for_status()\n\n    return result.text\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listSubmissionBasicInfo","title":"listSubmissionBasicInfo","text":"<pre><code>listSubmissionBasicInfo(projectId, xform)\n</code></pre> <p>Fetch a list of submission instances basic information for a given form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listSubmissionBasicInfo(\n    self,\n    projectId: int,\n    xform: str,\n):\n    \"\"\"Fetch a list of submission instances basic information for a given form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (json): The data for this XForm\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/submissions\"\n    result = self.session.get(url, verify=self.verify)\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listSubmissions","title":"listSubmissions","text":"<pre><code>listSubmissions(projectId, xform, filters=None)\n</code></pre> <p>Fetch a list of submission instances for a given form.</p> <p>Returns data in format:</p> <p>{     \"value\":[],     \"@odata.context\": \"URL/v1/projects/52/forms/103.svc/$metadata#Submissions\",     \"@odata.count\":0 }</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The JSON of Submissions.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listSubmissions(self, projectId: int, xform: str, filters: dict = None):\n    \"\"\"Fetch a list of submission instances for a given form.\n\n    Returns data in format:\n\n    {\n        \"value\":[],\n        \"@odata.context\": \"URL/v1/projects/52/forms/103.svc/$metadata#Submissions\",\n        \"@odata.count\":0\n    }\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (json): The JSON of Submissions.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}.svc/Submissions\"\n    try:\n        result = self.session.get(url, params=filters, verify=self.verify)\n        result.raise_for_status()  # Raise an error for non-2xx status codes\n        self.submissions = result.json()\n        return self.submissions\n    except Exception as e:\n        log.error(f\"Error fetching submissions: {e}\")\n        return {}\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listAssignments","title":"listAssignments","text":"<pre><code>listAssignments(projectId, xform)\n</code></pre> <p>List the Role &amp; Actor assignments for users on a project.</p> <p>Fetch a list of submission instances basic information for a given form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listAssignments(\n    self,\n    projectId: int,\n    xform: str,\n):\n    \"\"\"List the Role &amp; Actor assignments for users on a project.\n\n    Fetch a list of submission instances basic information for a given form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (json): The data for this XForm\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/assignments\"\n    result = self.session.get(url, verify=self.verify)\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getSubmissions","title":"getSubmissions","text":"<pre><code>getSubmissions(projectId, xform, submission_id, disk=False, json=True)\n</code></pre> <p>Fetch a CSV or JSON file of the submissions without media to a survey form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>submission_id</code> <code>int</code> <p>The ID of the submissions to download</p> required <code>disk</code> <code>bool</code> <p>Whether to write the downloaded file to disk</p> <code>False</code> <code>json</code> <code>bool</code> <p>Download JSON or CSV format</p> <code>True</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The list of submissions as JSON or CSV bytes object.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getSubmissions(\n    self,\n    projectId: int,\n    xform: str,\n    submission_id: int,\n    disk: bool = False,\n    json: bool = True,\n):\n    \"\"\"Fetch a CSV or JSON file of the submissions without media to a survey form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n        submission_id (int): The ID of the submissions to download\n        disk (bool): Whether to write the downloaded file to disk\n        json (bool): Download JSON or CSV format\n\n    Returns:\n        (bytes): The list of submissions as JSON or CSV bytes object.\n    \"\"\"\n    now = datetime.now()\n    timestamp = f\"{now.year}_{now.hour}_{now.minute}\"\n\n    if json:\n        url = self.base + f\"projects/{projectId}/forms/{xform}.svc/Submissions\"\n        filespec = f\"{xform}_{timestamp}.json\"\n    else:\n        url = self.base + f\"projects/{projectId}/forms/{xform}/submissions\"\n        filespec = f\"{xform}_{timestamp}.csv\"\n\n    if submission_id:\n        url = url + f\"('{submission_id}')\"\n\n    # log.debug(f'Getting submissions for {projectId}, Form {xform}')\n    result = self.session.get(\n        url,\n        headers=dict({\"Content-Type\": \"application/json\"}, **self.session.headers),\n        verify=self.verify,\n    )\n    if result.status_code == 200:\n        if disk:\n            # id = self.forms[0]['xmlFormId']\n            try:\n                file = open(filespec, \"xb\")\n                file.write(result.content)\n            except FileExistsError:\n                file = open(filespec, \"wb\")\n                file.write(result.content)\n            log.info(\"Wrote output file %s\" % filespec)\n            file.close()\n        return result.content\n    else:\n        log.error(f\"Submissions for {projectId}, Form {xform}\" + \" doesn't exist\")\n        return bytes()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getSubmissionMedia","title":"getSubmissionMedia","text":"<pre><code>getSubmissionMedia(projectId, xform, filters={})\n</code></pre> <p>Fetch a ZIP file of the submissions with media to a survey form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>The media file</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getSubmissionMedia(\n    self,\n    projectId: int,\n    xform: str,\n    filters: dict = {},\n):\n    \"\"\"Fetch a ZIP file of the submissions with media to a survey form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (list): The media file\n    \"\"\"\n    url = self.base + f\"projects/{projectId}/forms/{xform}/submissions.csv.zip\"\n    result = self.session.get(url, params=filters, verify=self.verify)\n    return result\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getSubmissionPhoto","title":"getSubmissionPhoto","text":"<pre><code>getSubmissionPhoto(projectId, instanceID, xform, filename)\n</code></pre> <p>Fetch a specific attachment by filename from a submission to a form.</p> <p>NOTE this function expects the user has not configured external S3 storage. NOTE if S3 storage is configured, the response does not contain the NOTE photo content, but instead an S3 pre-signed URL. NOTE see OdkCentralAsync.OdkForm.getSubmissionAttachmentUrl</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>instanceID(str)</code> <p>The ID of the submission on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>filename</code> <code>str</code> <p>The name of the attachment for the XForm on ODK Central</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The media data</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getSubmissionPhoto(\n    self,\n    projectId: int,\n    instanceID: str,\n    xform: str,\n    filename: str,\n):\n    \"\"\"Fetch a specific attachment by filename from a submission to a form.\n\n    NOTE this function expects the user has not configured external S3 storage.\n    NOTE if S3 storage is configured, the response does not contain the\n    NOTE photo content, but instead an S3 pre-signed URL.\n    NOTE see OdkCentralAsync.OdkForm.getSubmissionAttachmentUrl\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        instanceID(str): The ID of the submission on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n        filename (str): The name of the attachment for the XForm on ODK Central\n\n    Returns:\n        (bytes): The media data\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/submissions/{instanceID}/attachments/{filename}\"\n    result = self.session.get(url, verify=self.verify)\n    if result.status_code == 200:\n        log.debug(f\"fetched {filename} from Central\")\n    else:\n        status = result.json()\n        log.error(f\"Couldn't fetch {filename} from Central: {status['message']}\")\n    return result.content\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.addMedia","title":"addMedia","text":"<pre><code>addMedia(media, filespec)\n</code></pre> <p>Add a data file to this form.</p> <p>Parameters:</p> Name Type Description Default <code>media</code> <code>str</code> <p>The media file</p> required <code>filespec</code> <code>str</code> <p>the name of the media</p> required Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def addMedia(\n    self,\n    media: bytes,\n    filespec: str,\n):\n    \"\"\"Add a data file to this form.\n\n    Args:\n        media (str): The media file\n        filespec (str): the name of the media\n    \"\"\"\n    # FIXME: this also needs the data\n    self.media[filespec] = media\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.addXMLForm","title":"addXMLForm","text":"<pre><code>addXMLForm(projectId, xmlFormId, xform)\n</code></pre> <p>Add an XML file to this form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def addXMLForm(\n    self,\n    projectId: int,\n    xmlFormId: int,\n    xform: str,\n):\n    \"\"\"Add an XML file to this form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n    \"\"\"\n    self.xml = xform\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listMedia","title":"listMedia","text":"<pre><code>listMedia(projectId, xform)\n</code></pre> <p>List all the attchements for this form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of al the media files for this project</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listMedia(\n    self,\n    projectId: int,\n    xform: str,\n):\n    \"\"\"List all the attchements for this form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (list): A list of al the media files for this project\n    \"\"\"\n    if self.draft:\n        url = f\"{self.base}projects/{projectId}/forms/{xform}/draft/attachments\"\n    else:\n        url = f\"{self.base}projects/{projectId}/forms/{xform}/attachments\"\n    result = self.session.get(url, verify=self.verify)\n    self.media = result.json()\n    return self.media\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.validateMedia","title":"validateMedia","text":"<pre><code>validateMedia(filename)\n</code></pre> <p>Validate the specified filename is present in the XForm.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def validateMedia(self, filename: str):\n    \"\"\"Validate the specified filename is present in the XForm.\"\"\"\n    if not self.xml:\n        return\n    xform_filenames = []\n    namespaces = {\n        \"h\": \"http://www.w3.org/1999/xhtml\",\n        \"odk\": \"http://www.opendatakit.org/xforms\",\n        \"xforms\": \"http://www.w3.org/2002/xforms\",\n    }\n\n    root = ElementTree.fromstring(self.xml)\n    instances = root.findall(\".//xforms:model/xforms:instance[@src]\", namespaces)\n\n    for inst in instances:\n        src_value = inst.attrib.get(\"src\", \"\")\n        if src_value.startswith(\"jr://\"):\n            src_value = src_value[len(\"jr://\") :]  # Remove jr:// prefix\n        if src_value.startswith(\"file/\"):\n            src_value = src_value[len(\"file/\") :]  # Remove file/ prefix\n        xform_filenames.append(src_value)\n\n    if filename not in xform_filenames:\n        log.error(f\"Filename ({filename}) is not present in XForm media: {xform_filenames}\")\n        return False\n\n    return True\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.uploadMedia","title":"uploadMedia","text":"<pre><code>uploadMedia(projectId, form_name, data, filename=None)\n</code></pre> <p>Upload an attachement to the ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>form_name</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>data</code> <code>(str, Path, BytesIO)</code> <p>The file path or BytesIO media file</p> required <code>filename</code> <code>str</code> <p>If BytesIO object used, provide a file name.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>result</code> <code>Response</code> <p>The response object.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def uploadMedia(\n    self,\n    projectId: int,\n    form_name: str,\n    data: Union[str, Path, BytesIO],\n    filename: Optional[str] = None,\n) -&gt; Optional[requests.Response]:\n    \"\"\"Upload an attachement to the ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        form_name (str): The XForm to get the details of from ODK Central\n        data (str, Path, BytesIO): The file path or BytesIO media file\n        filename (str): If BytesIO object used, provide a file name.\n\n    Returns:\n        result (requests.Response): The response object.\n    \"\"\"\n    # BytesIO memory object\n    if isinstance(data, BytesIO):\n        if filename is None:\n            log.error(\"Cannot pass BytesIO object and not include the filename arg\")\n            return None\n        media = data.getvalue()\n    # Filepath\n    elif isinstance(data, str) or isinstance(data, Path):\n        media_file_path = Path(data)\n        if not media_file_path.exists():\n            log.error(f\"File does not exist on disk: {data}\")\n            return None\n        with open(media_file_path, \"rb\") as file:\n            media = file.read()\n        filename = str(Path(data).name)\n\n    # Validate filename present in XForm\n    if self.xml:\n        if not self.validateMedia(filename):\n            return None\n\n    # Must first convert to draft if already published\n    if not self.draft or self.published:\n        # TODO should this use self.createForm ?\n        log.debug(f\"Updating form ({form_name}) to draft\")\n        url = f\"{self.base}projects/{projectId}/forms/{form_name}/draft?ignoreWarnings=true\"\n        result = self.session.post(url, verify=self.verify)\n        if result.status_code != 200:\n            status = result.json()\n            log.error(f\"Couldn't modify {form_name} to draft: {status['message']}\")\n            return None\n\n    # Upload the media\n    url = f\"{self.base}projects/{projectId}/forms/{form_name}/draft/attachments/{filename}\"\n    log.debug(f\"Uploading media to URL: {url}\")\n    result = self.session.post(\n        url, data=media, headers=dict({\"Content-Type\": \"*/*\"}, **self.session.headers), verify=self.verify\n    )\n\n    if result.status_code == 200:\n        log.debug(f\"Uploaded {filename} to Central\")\n    else:\n        status = result.json()\n        log.error(f\"Couldn't upload {filename} to Central: {status['message']}\")\n        return None\n\n    # Publish the draft by default\n    if self.published:\n        self.publishForm(projectId, form_name)\n\n    self.addMedia(media, filename)\n\n    return result\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getMedia","title":"getMedia","text":"<pre><code>getMedia(projectId, xform, filename)\n</code></pre> <p>Fetch a specific attachment by filename from a submission to a form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>filename</code> <code>str</code> <p>The name of the attachment for the XForm on ODK Central</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The media data</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getMedia(\n    self,\n    projectId: int,\n    xform: str,\n    filename: str,\n):\n    \"\"\"Fetch a specific attachment by filename from a submission to a form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n        filename (str): The name of the attachment for the XForm on ODK Central\n\n    Returns:\n        (bytes): The media data\n    \"\"\"\n    if self.draft:\n        url = f\"{self.base}projects/{projectId}/forms/{xform}/draft/attachments/{filename}\"\n    else:\n        url = f\"{self.base}projects/{projectId}/forms/{xform}/attachments/{filename}\"\n    result = self.session.get(url, verify=self.verify)\n    if result.status_code == 200:\n        log.debug(f\"fetched {filename} from Central\")\n    else:\n        status = result.json()\n        log.error(f\"Couldn't fetch {filename} from Central: {status['message']}\")\n    self.addMedia(result.content, filename)\n    return self.media\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.createForm","title":"createForm","text":"<pre><code>createForm(projectId, data, form_name=None, publish=False)\n</code></pre> <p>Create a new form on an ODK Central server.</p> <ul> <li>If no form_name is passed, the form name is generated by default in draft.     If the publish param is also passed, then the form is published.</li> <li>If form_name is passed, a new form is created from this in draft state.     This copies across all attachments.</li> </ul> Note <p>The form name (xmlFormId) is generated from the id=\"\u2026\" attribute immediately inside the  tag of the XForm XML. <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>form_name</code> <code>str</code> <p>The user friendly name to provide the form</p> <code>None</code> <code>data</code> <code>(str, Path, BytesIO)</code> <p>The XForm file path, or BytesIO memory obj</p> required <code>publish</code> <code>bool</code> <p>If the new form should be published. Only valid if form_name is not passed, i.e. a new form.</p> <code>False</code> <p>Returns:</p> Type Description <code>(str, Optional)</code> <p>The form name, else None if failure.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def createForm(\n    self,\n    projectId: int,\n    data: Union[str, Path, BytesIO],\n    form_name: Optional[str] = None,\n    publish: Optional[bool] = False,\n) -&gt; Optional[str]:\n    \"\"\"Create a new form on an ODK Central server.\n\n    - If no form_name is passed, the form name is generated by default in draft.\n        If the publish param is also passed, then the form is published.\n    - If form_name is passed, a new form is created from this in draft state.\n        This copies across all attachments.\n\n    Note:\n        The form name (xmlFormId) is generated from the id=\"\u2026\" attribute\n        immediately inside the &lt;instance&gt; tag of the XForm XML.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        form_name (str): The user friendly name to provide the form\n        data (str, Path, BytesIO): The XForm file path, or BytesIO memory obj\n        publish (bool): If the new form should be published.\n            Only valid if form_name is not passed, i.e. a new form.\n\n    Returns:\n        (str, Optional): The form name, else None if failure.\n    \"\"\"\n    # BytesIO memory object\n    if isinstance(data, BytesIO):\n        self.xml = data.getvalue().decode(\"utf-8\")\n    # Filepath\n    elif isinstance(data, str) or isinstance(data, Path):\n        xml_path = Path(data)\n        if not xml_path.exists():\n            log.error(f\"File does not exist on disk: {data}\")\n            return None\n        # Read the XML or XLS file\n        with open(xml_path, \"rb\") as xml_file:\n            self.xml = xml_file.read()\n        log.debug(\"Read %d bytes from %s\" % (len(self.xml), data))\n\n    if form_name or self.draft:\n        self.draft = True\n        log.debug(f\"Creating draft from template form: {form_name}\")\n        url = f\"{self.base}projects/{projectId}/forms/{form_name}/draft?ignoreWarnings=true\"\n    else:\n        # This is not a draft form, its an entirely new form (even if publish=false)\n        log.debug(\"Creating new form, with name determined from form_id field\")\n        self.published = True if publish else False\n        url = f\"{self.base}projects/{projectId}/forms?ignoreWarnings=true&amp;{'publish=true' if publish else ''}\"\n\n    result = self.session.post(\n        url, data=self.xml, headers=dict({\"Content-Type\": \"application/xml\"}, **self.session.headers), verify=self.verify\n    )\n\n    if result.status_code != 200:\n        try:\n            status = result.json()\n            msg = status.get(\"message\", \"Unknown error\")\n            if result.status_code == 409:\n                log.warning(msg)\n                last_full_stop_index = msg.rfind(\".\")\n                last_comma_index = msg.rfind(\",\")\n                if last_full_stop_index != -1 and last_comma_index != -1:\n                    # Extract xmlFormId from error msg\n                    xmlFormId = msg[last_comma_index + 1 : last_full_stop_index].strip()\n                    return xmlFormId\n                else:\n                    log.warning(\"Unable to extract xmlFormId from error message\")\n                    return None\n            else:\n                log.error(f\"Couldn't create {form_name} on Central: {msg}\")\n                return None\n        except json.decoder.JSONDecodeError:\n            log.error(f\"Couldn't create {form_name} on Central: Error decoding JSON response\")\n            return None\n\n    try:\n        # Log response to terminal\n        json_data = result.json()\n    except json.decoder.JSONDecodeError:\n        log.error(\"Could not parse response json during form creation\")\n        return None\n\n    # epdb.st()\n    # FIXME: should update self.forms with the new form\n\n    if \"success\" in json_data:\n        log.debug(f\"Created draft XForm on ODK server: ({form_name})\")\n        return form_name\n\n    new_form_name = json_data.get(\"xmlFormId\")\n    log.info(f\"Created XForm on ODK server: ({new_form_name})\")\n    return new_form_name\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>OdkCentral</code></p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>OdkAppUser</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"A Class for app user data.\n\n    Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central\n\n    Returns:\n        (OdkAppUser): An instance of this object\n    \"\"\"\n    super().__init__(url, user, passwd)\n    self.user = None\n    self.qrcode = None\n    self.id = None\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>OdkCentral</code></p> <p>Class to manipulate a Entity on an ODK Central server.</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central.\n</code></pre> <p>Returns:</p> Type Description <code>OdkDataset</code> <p>An instance of this object.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central.\n\n    Returns:\n        (OdkDataset): An instance of this object.\n    \"\"\"\n    super().__init__(url, user, passwd)\n    self.name = None\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.deleteForm","title":"deleteForm","text":"<pre><code>deleteForm(projectId, xform)\n</code></pre> <p>Delete a form from an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:     (bool): did it get deleted</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def deleteForm(\n    self,\n    projectId: int,\n    xform: str,\n):\n    \"\"\"Delete a form from an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n    Returns:\n        (bool): did it get deleted\n    \"\"\"\n    # FIXME: If your goal is to prevent it from showing up on survey clients like ODK Collect, consider\n    # setting its state to closing or closed\n    if self.draft:\n        log.debug(f\"Deleting draft form on ODK server: ({xform})\")\n        url = f\"{self.base}projects/{projectId}/forms/{xform}/draft\"\n    else:\n        log.debug(f\"Deleting form on ODK server: ({xform})\")\n        url = f\"{self.base}projects/{projectId}/forms/{xform}\"\n\n    result = self.session.delete(url, verify=self.verify)\n    if not result.ok:\n        try:\n            # Log response to terminal\n            json_data = result.json()\n            log.warning(json_data)\n            return False\n        except json.decoder.JSONDecodeError:\n            log.error(f\"Could not parse response json during form deletion. status_code={result.status_code}\")\n        finally:\n            return False\n\n    self.draft = False\n    self.published = False\n\n    return True\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.publishForm","title":"publishForm","text":"<pre><code>publishForm(projectId, xform)\n</code></pre> <p>Publish a draft form. When creating a form that isn't a draft, it can get publised then.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>int</code> <p>The staus code from ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def publishForm(\n    self,\n    projectId: int,\n    xform: str,\n) -&gt; int:\n    \"\"\"Publish a draft form. When creating a form that isn't a draft, it can get publised then.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        (int): The staus code from ODK Central\n    \"\"\"\n    version = datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S.%f\")\n\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/draft/publish?version={version}\"\n    result = self.session.post(url, verify=self.verify)\n    if result.status_code != 200:\n        status = result.json()\n        log.error(f\"Couldn't publish {xform} on Central: {status['message']}\")\n    else:\n        log.info(f\"Published {xform} on Central.\")\n\n    self.draft = False\n    self.published = True\n\n    return result.status_code\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.formFields","title":"formFields","text":"<pre><code>formFields(projectId, xform)\n</code></pre> <p>Retrieves the form fields for a xform from odk central.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A json object containing the form fields.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def formFields(self, projectId: int, xform: str):\n    \"\"\"Retrieves the form fields for a xform from odk central.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n\n    Returns:\n        dict: A json object containing the form fields.\n\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/fields?odata=true\"\n    response = self.session.get(url, verify=self.verify)\n\n    # TODO wrap this logic and put in every method requiring form name\n    if response.status_code != 200:\n        if response.status_code == 404:\n            msg = f\"The ODK form you referenced does not exist yet: {xform}\"\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        log.debug(f\"Failed to retrieve form fields. Status code: {response.status_code}\")\n        response.raise_for_status()\n\n    return response.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    # super().dump()\n    entries = len(self.media.keys())\n    print(\"Form has %d attachments\" % entries)\n    for filename, content in self.media:\n        print(\"Filename: %s\" % filename)\n        print(\"Content length: %s\" % len(content))\n        print(\"\")\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.create","title":"create","text":"<pre><code>create(projectId, name)\n</code></pre> <p>Create a new app-user for a form.</p> <p>Example response:</p> <p>{ \"createdAt\": \"2018-04-18T23:19:14.802Z\", \"displayName\": \"My Display Name\", \"id\": 115, \"type\": \"user\", \"updatedAt\": \"2018-04-18T23:42:11.406Z\", \"deletedAt\": \"2018-04-18T23:42:11.406Z\", \"token\": \"d1!E2GVHgpr4h9bpxxtqUJ7EVJ1Q$Dusm2RBXg8XyVJMCBCbvyE8cGacxUx3bcUT\", \"projectId\": 1 }</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>name</code> <code>str</code> <p>The name of the XForm</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The response JSON from ODK Central</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def create(\n    self,\n    projectId: int,\n    name: str,\n):\n    \"\"\"Create a new app-user for a form.\n\n    Example response:\n\n    {\n    \"createdAt\": \"2018-04-18T23:19:14.802Z\",\n    \"displayName\": \"My Display Name\",\n    \"id\": 115,\n    \"type\": \"user\",\n    \"updatedAt\": \"2018-04-18T23:42:11.406Z\",\n    \"deletedAt\": \"2018-04-18T23:42:11.406Z\",\n    \"token\": \"d1!E2GVHgpr4h9bpxxtqUJ7EVJ1Q$Dusm2RBXg8XyVJMCBCbvyE8cGacxUx3bcUT\",\n    \"projectId\": 1\n    }\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        name (str): The name of the XForm\n\n    Returns:\n        (dict): The response JSON from ODK Central\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/app-users\"\n    response = self.session.post(url, json={\"displayName\": name}, verify=self.verify)\n    self.user = name\n    if response.ok:\n        return response.json()\n    return {}\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.delete","title":"delete","text":"<pre><code>delete(projectId, userId)\n</code></pre> <p>Create a new app-user for a form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>userId</code> <code>int</code> <p>The ID of the user on ODK Central to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user got deleted or not</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def delete(\n    self,\n    projectId: int,\n    userId: int,\n):\n    \"\"\"Create a new app-user for a form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        userId (int): The ID of the user on ODK Central to delete\n\n    Returns:\n        (bool): Whether the user got deleted or not\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/app-users/{userId}\"\n    result = self.session.delete(url, verify=self.verify)\n    return result\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.updateRole","title":"updateRole","text":"<pre><code>updateRole(projectId, xform, roleId=2, actorId=None)\n</code></pre> <p>Update the role of an app user for a form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>roleId</code> <code>int</code> <p>The role for the user</p> <code>2</code> <code>actorId</code> <code>int</code> <p>The ID of the user</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether it was update or not</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def updateRole(\n    self,\n    projectId: int,\n    xform: str,\n    roleId: int = 2,\n    actorId: Optional[int] = None,\n):\n    \"\"\"Update the role of an app user for a form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xform (str): The XForm to get the details of from ODK Central\n        roleId (int): The role for the user\n        actorId (int): The ID of the user\n\n    Returns:\n        (bool): Whether it was update or not\n    \"\"\"\n    log.info(\"Update access to XForm %s for %s\" % (xform, actorId))\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/assignments/{roleId}/{actorId}\"\n    result = self.session.post(url, verify=self.verify)\n    return result\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.grantAccess","title":"grantAccess","text":"<pre><code>grantAccess(projectId, roleId=2, userId=None, xform=None, actorId=None)\n</code></pre> <p>Grant access to an app user for a form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>roleId</code> <code>int</code> <p>The role ID</p> <code>2</code> <code>userId</code> <code>int</code> <p>The user ID of the user on ODK Central</p> <code>None</code> <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> <code>None</code> <code>actorId</code> <code>int</code> <p>The actor ID of the user on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether access was granted or not</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def grantAccess(self, projectId: int, roleId: int = 2, userId: int = None, xform: str = None, actorId: int = None):\n    \"\"\"Grant access to an app user for a form.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        roleId (int): The role ID\n        userId (int): The user ID of the user on ODK Central\n        xform (str):  The XForm to get the details of from ODK Central\n        actorId (int): The actor ID of the user on ODK Central\n\n    Returns:\n        (bool): Whether access was granted or not\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms/{xform}/assignments/{roleId}/{actorId}\"\n    result = self.session.post(url, verify=self.verify)\n    return result\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.createQRCode","title":"createQRCode","text":"<pre><code>createQRCode(odk_id, project_name, appuser_token, basemap='osm', osm_username='svchotosm', upstream_task_id='', save_qrcode=False)\n</code></pre> <p>Get the QR Code for an app-user.</p> <p>Notes on QR code params:</p> <ul> <li>form_update_mode: 'manual' allows for easier offline mapping, while     if set to 'match_exactly', it will attempt sync with Central</li> </ul> <ul> <li>metadata_email: we 'misuse' this field to add additional metadata,     in this case a task id from an upstream application (FMTM).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>odk_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>project_name</code> <code>str</code> <p>The name of the project to set</p> required <code>appuser_token</code> <code>str</code> <p>The user's token</p> required <code>basemap</code> <code>str</code> <p>Default basemap to use on Collect. Options: \"google\", \"mapbox\", \"osm\", \"usgs\", \"stamen\", \"carto\".</p> <code>'osm'</code> <code>osm_username</code> <code>str</code> <p>The OSM username to attribute to the mapping.</p> <code>'svchotosm'</code> <code>save_qrcode</code> <code>bool</code> <p>Save the generated QR code to disk.</p> <code>False</code> <p>Returns:</p> Type Description <code>QRCode</code> <p>segno.QRCode: The new QR code object</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def createQRCode(\n    self,\n    odk_id: int,\n    project_name: str,\n    appuser_token: str,\n    basemap: str = \"osm\",\n    osm_username: str = \"svchotosm\",\n    upstream_task_id: str = \"\",\n    save_qrcode: bool = False,\n) -&gt; segno.QRCode:\n    \"\"\"Get the QR Code for an app-user.\n\n    Notes on QR code params:\n\n    - form_update_mode: 'manual' allows for easier offline mapping, while\n        if set to 'match_exactly', it will attempt sync with Central\n\n    - metadata_email: we 'misuse' this field to add additional metadata,\n        in this case a task id from an upstream application (FMTM).\n\n    Args:\n        odk_id (int): The ID of the project on ODK Central\n        project_name (str): The name of the project to set\n        appuser_token (str): The user's token\n        basemap (str): Default basemap to use on Collect.\n            Options: \"google\", \"mapbox\", \"osm\", \"usgs\", \"stamen\", \"carto\".\n        osm_username (str): The OSM username to attribute to the mapping.\n        save_qrcode (bool): Save the generated QR code to disk.\n\n    Returns:\n        segno.QRCode: The new QR code object\n    \"\"\"\n    log.info(f\"Generating QR Code for project ({odk_id}) {project_name}\")\n\n    self.settings = {\n        \"general\": {\n            \"server_url\": f\"{self.base}key/{appuser_token}/projects/{odk_id}\",\n            \"form_update_mode\": \"manual\",\n            \"basemap_source\": basemap,\n            \"autosend\": \"wifi_and_cellular\",\n            \"metadata_username\": osm_username,\n            \"metadata_email\": upstream_task_id,\n        },\n        \"project\": {\"name\": f\"{project_name}\"},\n        \"admin\": {},\n    }\n\n    # Base64 encode JSON params for QR code\n    qr_data = b64encode(zlib.compress(json.dumps(self.settings).encode(\"utf-8\")))\n    # Generate QR code\n    self.qrcode = segno.make(qr_data, micro=False)\n\n    if save_qrcode:\n        log.debug(f\"Saving QR code to {project_name}.png\")\n        self.qrcode.save(f\"{project_name}.png\", scale=5)\n\n    return self.qrcode\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkDataset.listDatasets","title":"listDatasets","text":"<pre><code>listDatasets(projectId)\n</code></pre> <p>Get all Entity datasets (entity lists) for a project.</p> <p>JSON response: [     {         \"name\": \"people\",         \"createdAt\": \"2018-01-19T23:58:03.395Z\",         \"projectId\": 1,         \"approvalRequired\": true     } ]</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of JSON dataset metadata.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listDatasets(\n    self,\n    projectId: int,\n):\n    \"\"\"Get all Entity datasets (entity lists) for a project.\n\n    JSON response:\n    [\n        {\n            \"name\": \"people\",\n            \"createdAt\": \"2018-01-19T23:58:03.395Z\",\n            \"projectId\": 1,\n            \"approvalRequired\": true\n        }\n    ]\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n\n    Returns:\n        list: a list of JSON dataset metadata.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/\"\n    result = self.session.get(url, verify=self.verify)\n    return result.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkDataset.listEntities","title":"listEntities","text":"<pre><code>listEntities(projectId, datasetName)\n</code></pre> <p>Get all Entities for a project dataset (entity list).</p> <p>JSON format: [ {     \"uuid\": \"uuid:85cb9aff-005e-4edd-9739-dc9c1a829c44\",     \"createdAt\": \"2018-01-19T23:58:03.395Z\",     \"updatedAt\": \"2018-03-21T12:45:02.312Z\",     \"deletedAt\": \"2018-03-21T12:45:02.312Z\",     \"creatorId\": 1,     \"currentVersion\": {     \"label\": \"John (88)\",     \"current\": true,     \"createdAt\": \"2018-03-21T12:45:02.312Z\",     \"creatorId\": 1,     \"userAgent\": \"Enketo/3.0.4\",     \"version\": 1,     \"baseVersion\": null,     \"conflictingProperties\": null     } } ]</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>str</code> <p>The name of a dataset, specific to a project.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of JSON entity metadata, for a dataset.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def listEntities(\n    self,\n    projectId: int,\n    datasetName: str,\n):\n    \"\"\"Get all Entities for a project dataset (entity list).\n\n    JSON format:\n    [\n    {\n        \"uuid\": \"uuid:85cb9aff-005e-4edd-9739-dc9c1a829c44\",\n        \"createdAt\": \"2018-01-19T23:58:03.395Z\",\n        \"updatedAt\": \"2018-03-21T12:45:02.312Z\",\n        \"deletedAt\": \"2018-03-21T12:45:02.312Z\",\n        \"creatorId\": 1,\n        \"currentVersion\": {\n        \"label\": \"John (88)\",\n        \"current\": true,\n        \"createdAt\": \"2018-03-21T12:45:02.312Z\",\n        \"creatorId\": 1,\n        \"userAgent\": \"Enketo/3.0.4\",\n        \"version\": 1,\n        \"baseVersion\": null,\n        \"conflictingProperties\": null\n        }\n    }\n    ]\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (str): The name of a dataset, specific to a project.\n\n    Returns:\n        list: a list of JSON entity metadata, for a dataset.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities\"\n    response = self.session.get(url, verify=self.verify)\n    return response.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkDataset.createEntity","title":"createEntity","text":"<pre><code>createEntity(projectId, datasetName, label, data)\n</code></pre> <p>Create a new Entity in a project dataset (entity list).</p> <p>JSON request: { \"uuid\": \"54a405a0-53ce-4748-9788-d23a30cc3afa\", \"label\": \"John Doe (88)\", \"data\": {     \"firstName\": \"John\",     \"age\": \"88\" } }</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>label</code> <code>str</code> <p>Label for the Entity.</p> required <code>data</code> <code>dict</code> <p>Key:Value pairs to insert as Entity data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>JSON of entity details. The 'uuid' field includes the unique entity identifier.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def createEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    label: str,\n    data: dict,\n) -&gt; dict:\n    \"\"\"Create a new Entity in a project dataset (entity list).\n\n    JSON request:\n    {\n    \"uuid\": \"54a405a0-53ce-4748-9788-d23a30cc3afa\",\n    \"label\": \"John Doe (88)\",\n    \"data\": {\n        \"firstName\": \"John\",\n        \"age\": \"88\"\n    }\n    }\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        label (str): Label for the Entity.\n        data (dict): Key:Value pairs to insert as Entity data.\n\n    Returns:\n        dict: JSON of entity details.\n            The 'uuid' field includes the unique entity identifier.\n    \"\"\"\n    # The CSV must contain a geometry field to work\n    # TODO also add this validation to uploadMedia if CSV format\n    required_fields = [\"geometry\"]\n    if not all(key in data for key in required_fields):\n        msg = \"'geometry' data field is mandatory\"\n        log.debug(msg)\n        raise ValueError(msg)\n\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities\"\n    response = self.session.post(\n        url,\n        verify=self.verify,\n        json={\n            \"uuid\": str(uuid4()),\n            \"label\": label,\n            \"data\": data,\n        },\n    )\n    if not response.ok:\n        if response.status_code == 404:\n            msg = f\"Does not exist: project ({projectId}) dataset ({datasetName})\"\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        if response.status_code == 400:\n            msg = response.json().get(\"message\")\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        log.debug(f\"Failed to create Entity. Status code: {response.status_code}\")\n        response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkDataset.updateEntity","title":"updateEntity","text":"<pre><code>updateEntity(projectId, datasetName, entityUuid, label=None, data=None, newVersion=None)\n</code></pre> <p>Update an existing Entity in a project dataset (entity list).</p> <p>The JSON request format is the same as creating, minus the 'uuid' field. The PATCH will only update the specific fields specified, leaving the     remainder.</p> <p>If no 'newVersion' param is provided, the entity will be force updated     in place. If 'newVersion' is provided, this must be a single integer increment     from the current version.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>entityUuid</code> <code>str</code> <p>Unique itentifier of the entity.</p> required <code>label</code> <code>str</code> <p>Label for the Entity.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Key:Value pairs to insert as Entity data.</p> <code>None</code> <code>newVersion</code> <code>int</code> <p>Integer version to increment to (current version + 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>JSON of entity details. The 'uuid' field includes the unique entity identifier.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def updateEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    entityUuid: str,\n    label: Optional[str] = None,\n    data: Optional[dict] = None,\n    newVersion: Optional[int] = None,\n):\n    \"\"\"Update an existing Entity in a project dataset (entity list).\n\n    The JSON request format is the same as creating, minus the 'uuid' field.\n    The PATCH will only update the specific fields specified, leaving the\n        remainder.\n\n    If no 'newVersion' param is provided, the entity will be force updated\n        in place.\n    If 'newVersion' is provided, this must be a single integer increment\n        from the current version.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        entityUuid (str): Unique itentifier of the entity.\n        label (str): Label for the Entity.\n        data (dict): Key:Value pairs to insert as Entity data.\n        newVersion (int): Integer version to increment to (current version + 1).\n\n    Returns:\n        dict: JSON of entity details.\n            The 'uuid' field includes the unique entity identifier.\n    \"\"\"\n    if not label and not data:\n        msg = \"One of either the 'label' or 'data' fields must be passed\"\n        log.debug(msg)\n        raise requests.exceptions.HTTPError(msg)\n\n    json_data = {}\n    if data:\n        json_data[\"data\"] = data\n    if label:\n        json_data[\"label\"] = label\n\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities/{entityUuid}\"\n    if newVersion:\n        url = f\"{url}?baseVersion={newVersion - 1}\"\n    else:\n        url = f\"{url}?force=true\"\n\n    log.debug(f\"Calling {url} with params {json_data}\")\n    response = self.session.patch(\n        url,\n        verify=self.verify,\n        json=json_data,\n    )\n    if not response.ok:\n        if response.status_code == 404:\n            msg = f\"Does not exist: project ({projectId}) dataset ({datasetName})\"\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        if response.status_code == 400:\n            msg = response.json().get(\"message\")\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        if response.status_code == 409:\n            msg = response.json().get(\"message\")\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        log.debug(f\"Failed to create Entity. Status code: {response.status_code}\")\n        response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkDataset.deleteEntity","title":"deleteEntity","text":"<pre><code>deleteEntity(projectId, datasetName, entityUuid)\n</code></pre> <p>Delete an Entity in a project dataset (entity list).</p> <p>Only performs a soft deletion, so the Entity is actually archived.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>entityUuid</code> <code>str</code> <p>Unique itentifier of the entity.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Deletion successful or not.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def deleteEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    entityUuid: str,\n):\n    \"\"\"Delete an Entity in a project dataset (entity list).\n\n    Only performs a soft deletion, so the Entity is actually archived.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        entityUuid (str): Unique itentifier of the entity.\n\n    Returns:\n        bool: Deletion successful or not.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities/{entityUuid}\"\n    log.debug(f\"Deleting dataset ({datasetName}) entity UUID ({entityUuid})\")\n    response = self.session.delete(url, verify=self.verify)\n\n    if not response.ok:\n        if response.status_code == 404:\n            msg = f\"Does not exist: project ({projectId}) dataset ({datasetName}) entity ({entityUuid})\"\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        log.debug(f\"Failed to delete Entity. Status code: {response.status_code}\")\n        response.raise_for_status()\n\n    success = (response_msg := response.json()).get(\"success\", False)\n\n    if not success:\n        log.debug(f\"Server returned deletion unsuccessful: {response_msg}\")\n\n    return success\n</code></pre>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkDataset.getEntityData","title":"getEntityData","text":"<pre><code>getEntityData(projectId, datasetName)\n</code></pre> <p>Get a lightweight JSON of the entity data fields in a dataset.</p> <p>Example response JSON: [ {     \"0\": {         \"__id\": \"523699d0-66ec-4cfc-a76b-4617c01c6b92\",         \"label\": \"the_label_you_defined\",         \"__system\": {             \"createdAt\": \"2024-03-24T06:30:31.219Z\",             \"creatorId\": \"7\",             \"creatorName\": \"fmtm@hotosm.org\",             \"updates\": 4,             \"updatedAt\": \"2024-03-24T07:12:55.871Z\",             \"version\": 5,             \"conflict\": null         },         \"geometry\": \"javarosa format geometry\",         \"user_defined_field2\": \"text\",         \"user_defined_field2\": \"text\",         \"user_defined_field3\": \"test\"     } } ]</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>All entity data for a project dataset.</p> Source code in <code>osm_fieldwork/OdkCentral.py</code> <pre><code>def getEntityData(\n    self,\n    projectId: int,\n    datasetName: str,\n):\n    \"\"\"Get a lightweight JSON of the entity data fields in a dataset.\n\n    Example response JSON:\n    [\n    {\n        \"0\": {\n            \"__id\": \"523699d0-66ec-4cfc-a76b-4617c01c6b92\",\n            \"label\": \"the_label_you_defined\",\n            \"__system\": {\n                \"createdAt\": \"2024-03-24T06:30:31.219Z\",\n                \"creatorId\": \"7\",\n                \"creatorName\": \"fmtm@hotosm.org\",\n                \"updates\": 4,\n                \"updatedAt\": \"2024-03-24T07:12:55.871Z\",\n                \"version\": 5,\n                \"conflict\": null\n            },\n            \"geometry\": \"javarosa format geometry\",\n            \"user_defined_field2\": \"text\",\n            \"user_defined_field2\": \"text\",\n            \"user_defined_field3\": \"test\"\n        }\n    }\n    ]\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n\n    Returns:\n        list: All entity data for a project dataset.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}.svc/Entities\"\n    response = self.session.get(url, verify=self.verify)\n\n    if not response.ok:\n        if response.status_code == 404:\n            msg = f\"Does not exist: project ({projectId}) dataset ({datasetName})\"\n            log.debug(msg)\n            raise requests.exceptions.HTTPError(msg)\n        log.debug(f\"Failed to get Entity data. Status code: {response.status_code}\")\n        response.raise_for_status()\n    return response.json().get(\"value\", {})\n</code></pre>"},{"location":"api/OdkCentralAsync/","title":"OdkCentral","text":"<p>               Bases: <code>object</code></p> <p>Helper methods for ODK Central API.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <code>session</code> <code>str</code> <p>Pass in an existing session for reuse.</p> required <p>Returns:</p> Type Description <code>OdkCentral</code> <p>An instance of this class</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"A Class for accessing an ODK Central server via it's REST API.\n\n    Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central\n        session (str): Pass in an existing session for reuse.\n\n    Returns:\n        (OdkCentral): An instance of this class\n    \"\"\"\n    if not url:\n        url = os.getenv(\"ODK_CENTRAL_URL\", default=None)\n    self.url = url\n    if not user:\n        user = os.getenv(\"ODK_CENTRAL_USER\", default=None)\n    self.user = user\n    if not passwd:\n        passwd = os.getenv(\"ODK_CENTRAL_PASSWD\", default=None)\n    self.passwd = passwd\n    verify = os.getenv(\"ODK_CENTRAL_SECURE\", default=True)\n    if type(verify) == str:\n        self.verify = verify.lower() in (\"true\", \"1\", \"t\")\n    else:\n        self.verify = verify\n\n    # Base URL for the REST API\n    self.version = \"v1\"\n    self.base = f\"{self.url}/{self.version}/\"\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>OdkCentral</code></p> <p>Class to manipulate a project on an ODK Central server.</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central.\n</code></pre> <p>Returns:</p> Type Description <code>OdkProject</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n):\n    \"\"\"Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central.\n\n    Returns:\n        (OdkProject): An instance of this object\n    \"\"\"\n    super().__init__(url, user, passwd)\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>OdkCentral</code></p> <p>Class to manipulate a Entity on an ODK Central server.</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central.\n</code></pre> <p>Returns:</p> Type Description <code>OdkDataset</code> <p>An instance of this object.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    user: Optional[str] = None,\n    passwd: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Args:\n        url (str): The URL of the ODK Central\n        user (str): The user's account name on ODK Central\n        passwd (str):  The user's account password on ODK Central.\n\n    Returns:\n        (OdkDataset): An instance of this object.\n    \"\"\"\n    super().__init__(url, user, passwd)\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkCentral.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate()\n</code></pre> <p>Authenticate to an ODK Central server.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def authenticate(self):\n    \"\"\"Authenticate to an ODK Central server.\"\"\"\n    try:\n        async with self.session.post(f\"{self.base}sessions\", json={\"email\": self.user, \"password\": self.passwd}) as response:\n            token = (await response.json())[\"token\"]\n            self.session.headers.update({\"Authorization\": f\"Bearer {token}\"})\n    except aiohttp.ClientConnectorError as request_error:\n        await self.session.close()\n        raise ConnectionError(\"Failed to connect to Central. Is the URL valid?\") from request_error\n    except aiohttp.ClientResponseError as response_error:\n        await self.session.close()\n        if response_error.status == 401:\n            raise ConnectionError(\"ODK credentials are invalid, or may have changed. Please update them.\") from response_error\n        raise response_error\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkProject.listForms","title":"listForms  <code>async</code>","text":"<pre><code>listForms(projectId, metadata=False)\n</code></pre> <p>Fetch a list of forms in a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of XForms in this project</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def listForms(self, projectId: int, metadata: bool = False):\n    \"\"\"Fetch a list of forms in a project on an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n\n    Returns:\n        (list): The list of XForms in this project\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/forms\"\n    headers = {}\n    if metadata:\n        headers.update({\"X-Extended-Metadata\": \"true\"})\n    try:\n        async with self.session.get(url, ssl=self.verify, headers=headers) as response:\n            self.forms = await response.json()\n            return self.forms\n    except aiohttp.ClientError as e:\n        msg = f\"Error fetching forms: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkProject.getAllProjectSubmissions","title":"getAllProjectSubmissions  <code>async</code>","text":"<pre><code>getAllProjectSubmissions(projectId, xforms=None, filters=None)\n</code></pre> <p>Fetch a list of submissions in a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xforms</code> <code>list</code> <p>The list of XForms to get the submissions of</p> <code>None</code> <p>Returns:</p> Type Description <code>json</code> <p>All of the submissions for all of the XForm in a project</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def getAllProjectSubmissions(self, projectId: int, xforms: list = None, filters: dict = None):\n    \"\"\"Fetch a list of submissions in a project on an ODK Central server.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central\n        xforms (list): The list of XForms to get the submissions of\n\n    Returns:\n        (json): All of the submissions for all of the XForm in a project\n    \"\"\"\n    # TODO this function needs more testing!\n\n    log.info(f\"Getting all submissions for ODK project ({projectId}) forms ({xforms})\")\n    submission_data = []\n\n    async with OdkForm(self.url, self.user, self.passwd) as odk_form:\n        submission_tasks = [odk_form.listSubmissions(projectId, xform, filters) for xform in xforms or []]\n\n        submissions = await gather(*submission_tasks, return_exceptions=True)\n\n    for submission in submissions:\n        if isinstance(submission, Exception):\n            log.error(f\"Failed to get submissions: {submission}\")\n            continue\n        log.debug(f\"There are {len(submission['value'])} submissions\")\n        submission_data.extend(submission[\"value\"])\n\n    return submission_data\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.listDatasets","title":"listDatasets  <code>async</code>","text":"<pre><code>listDatasets(projectId)\n</code></pre> <p>Get all Entity datasets (entity lists) for a project.</p> <p>JSON response: [     {         \"name\": \"people\",         \"createdAt\": \"2018-01-19T23:58:03.395Z\",         \"projectId\": 1,         \"approvalRequired\": true     } ]</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of JSON dataset metadata.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def listDatasets(\n    self,\n    projectId: int,\n) -&gt; list:\n    \"\"\"Get all Entity datasets (entity lists) for a project.\n\n    JSON response:\n    [\n        {\n            \"name\": \"people\",\n            \"createdAt\": \"2018-01-19T23:58:03.395Z\",\n            \"projectId\": 1,\n            \"approvalRequired\": true\n        }\n    ]\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n\n    Returns:\n        list: a list of JSON dataset metadata.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/\"\n    try:\n        async with self.session.get(url, ssl=self.verify) as response:\n            return await response.json()\n    except aiohttp.ClientError as e:\n        msg = f\"Error fetching datasets: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.createDataset","title":"createDataset  <code>async</code>","text":"<pre><code>createDataset(projectId, datasetName='features', properties=[])\n</code></pre> <p>Creates a dataset for a given project.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project to create the dataset for.</p> required <code>datasetName</code> <code>str</code> <p>The name of the dataset to be created.</p> <code>'features'</code> <code>properties</code> <code>list[str]</code> <p>List of property names to create. Alternatively call createDatasetProperty for each property manually.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The JSON response containing information about the created dataset.</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>If an error occurs during the dataset creation process.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def createDataset(\n    self,\n    projectId: int,\n    datasetName: Optional[str] = \"features\",\n    properties: Optional[list[str]] = [],\n):\n    \"\"\"Creates a dataset for a given project.\n\n    Args:\n        projectId (int): The ID of the project to create the dataset for.\n        datasetName (str): The name of the dataset to be created.\n        properties (list[str]): List of property names to create.\n            Alternatively call createDatasetProperty for each property manually.\n\n    Returns:\n        dict: The JSON response containing information about the created dataset.\n\n    Raises:\n        aiohttp.ClientError: If an error occurs during the dataset creation process.\n    \"\"\"\n    # Validation of properties param\n    if properties and (not isinstance(properties, list) or not isinstance(properties[-1], str)):\n        msg = \"The properties must be a list of string values to create a dataset\"\n        log.error(msg)\n        raise ValueError(msg)\n\n    # Create the dataset\n    url = f\"{self.base}projects/{projectId}/datasets\"\n    payload = {\"name\": datasetName}\n    try:\n        log.info(f\"Creating dataset ({datasetName}) for ODK project ({projectId})\")\n        async with self.session.post(\n            url,\n            ssl=self.verify,\n            json=payload,\n        ) as response:\n            if response.status not in (200, 201):\n                error_message = await response.text()\n                log.error(f\"Failed to create Dataset: {error_message}\")\n            log.info(f\"Successfully created Dataset {datasetName}\")\n            dataset = await response.json()\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to create Dataset: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n\n    if not properties:\n        return dataset\n\n    # Add the properties, if specified\n    # FIXME this is a bit of a hack until ODK Central has better support\n    # FIXME for adding dataset properties in bulk\n    try:\n        log.debug(f\"Creating properties for dataset ({datasetName}): {properties}\")\n        properties_tasks = [self.createDatasetProperty(projectId, field, datasetName) for field in properties]\n        success = await gather(*properties_tasks, return_exceptions=True)  # type: ignore\n        if not success:\n            log.warning(f\"No properties were uploaded for ODK project ({projectId}) dataset name ({datasetName})\")\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to create properties: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n\n    # Manually append to prevent another API call\n    dataset[\"properties\"] = properties\n    return dataset\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.createDatasetProperty","title":"createDatasetProperty  <code>async</code>","text":"<pre><code>createDatasetProperty(projectId, field_name, datasetName='features')\n</code></pre> <p>Create a property for a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project.</p> required <code>datasetName</code> <code>str</code> <p>The name of the dataset.</p> <code>'features'</code> <code>field</code> <code>dict</code> <p>A dictionary containing the field information.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response data from the API.</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>If an error occurs during the API request.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def createDatasetProperty(\n    self,\n    projectId: int,\n    field_name: str,\n    datasetName: Optional[str] = \"features\",\n):\n    \"\"\"Create a property for a dataset.\n\n    Args:\n        projectId (int): The ID of the project.\n        datasetName (str): The name of the dataset.\n        field (dict): A dictionary containing the field information.\n\n    Returns:\n        dict: The response data from the API.\n\n    Raises:\n        aiohttp.ClientError: If an error occurs during the API request.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/properties\"\n    payload = {\n        \"name\": field_name,\n    }\n\n    try:\n        log.debug(f\"Creating property ({field_name}) for dataset {datasetName}\")\n        async with self.session.post(url, ssl=self.verify, json=payload) as response:\n            response_data = await response.json()\n            if response.status not in (200, 201):\n                log.warning(f\"Failed to create properties: {response.status}, message='{response_data}'\")\n            log.debug(f\"Successfully created property ({field_name}) for dataset {datasetName}\")\n            return response_data\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to create properties: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.listEntities","title":"listEntities  <code>async</code>","text":"<pre><code>listEntities(projectId, datasetName)\n</code></pre> <p>Get all Entities for a project dataset (entity list).</p> <p>JSON format: [ {     \"uuid\": \"uuid:85cb9aff-005e-4edd-9739-dc9c1a829c44\",     \"createdAt\": \"2018-01-19T23:58:03.395Z\",     \"updatedAt\": \"2018-03-21T12:45:02.312Z\",     \"deletedAt\": \"2018-03-21T12:45:02.312Z\",     \"creatorId\": 1,     \"currentVersion\": {         \"label\": \"John (88)\",         \"data\": {             \"field1\": \"value1\"         },         \"current\": true,         \"createdAt\": \"2018-03-21T12:45:02.312Z\",         \"creatorId\": 1,         \"userAgent\": \"Enketo/3.0.4\",         \"version\": 1,         \"baseVersion\": null,         \"conflictingProperties\": null     } } ]</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>str</code> <p>The name of a dataset, specific to a project.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of JSON entity metadata, for a dataset.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def listEntities(\n    self,\n    projectId: int,\n    datasetName: str,\n) -&gt; list:\n    \"\"\"Get all Entities for a project dataset (entity list).\n\n    JSON format:\n    [\n    {\n        \"uuid\": \"uuid:85cb9aff-005e-4edd-9739-dc9c1a829c44\",\n        \"createdAt\": \"2018-01-19T23:58:03.395Z\",\n        \"updatedAt\": \"2018-03-21T12:45:02.312Z\",\n        \"deletedAt\": \"2018-03-21T12:45:02.312Z\",\n        \"creatorId\": 1,\n        \"currentVersion\": {\n            \"label\": \"John (88)\",\n            \"data\": {\n                \"field1\": \"value1\"\n            },\n            \"current\": true,\n            \"createdAt\": \"2018-03-21T12:45:02.312Z\",\n            \"creatorId\": 1,\n            \"userAgent\": \"Enketo/3.0.4\",\n            \"version\": 1,\n            \"baseVersion\": null,\n            \"conflictingProperties\": null\n        }\n    }\n    ]\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (str): The name of a dataset, specific to a project.\n\n    Returns:\n        list: a list of JSON entity metadata, for a dataset.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities\"\n    try:\n        async with self.session.get(url, ssl=self.verify) as response:\n            return await response.json()\n    except aiohttp.ClientError as e:\n        msg = f\"Error fetching entities: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.getEntity","title":"getEntity  <code>async</code>","text":"<pre><code>getEntity(projectId, datasetName, entityUuid)\n</code></pre> <p>Get a single Entity by it's UUID for a project.</p> <p>JSON response: { \"uuid\": \"a54400b6-49fe-4787-9ab8-7e2f56ff52bc\", \"createdAt\": \"2024-04-15T09:26:08.209Z\", \"creatorId\": 5, \"updatedAt\": null, \"deletedAt\": null, \"conflict\": null, \"currentVersion\": {     \"createdAt\": \"2024-04-15T09:26:08.209Z\",     \"current\": true,     \"label\": \"test entity\",     \"creatorId\": 5,     \"userAgent\": \"Python/3.10 aiohttp/3.9.3\",     \"data\": {         \"osm_id\": \"1\",         \"geometry\": \"test\"     },     \"version\": 1,     \"baseVersion\": null,     \"dataReceived\": {         \"label\": \"test entity\",         \"osm_id\": \"1\",         \"geometry\": \"test\"     },     \"conflictingProperties\": null } }</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>str</code> <p>The name of a dataset, specific to a project.</p> required <code>entityUuid</code> <code>str</code> <p>Unique itentifier of the entity in the dataset.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the JSON entity details, for a specific dataset.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def getEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    entityUuid: str,\n) -&gt; dict:\n    \"\"\"Get a single Entity by it's UUID for a project.\n\n    JSON response:\n    {\n    \"uuid\": \"a54400b6-49fe-4787-9ab8-7e2f56ff52bc\",\n    \"createdAt\": \"2024-04-15T09:26:08.209Z\",\n    \"creatorId\": 5,\n    \"updatedAt\": null,\n    \"deletedAt\": null,\n    \"conflict\": null,\n    \"currentVersion\": {\n        \"createdAt\": \"2024-04-15T09:26:08.209Z\",\n        \"current\": true,\n        \"label\": \"test entity\",\n        \"creatorId\": 5,\n        \"userAgent\": \"Python/3.10 aiohttp/3.9.3\",\n        \"data\": {\n            \"osm_id\": \"1\",\n            \"geometry\": \"test\"\n        },\n        \"version\": 1,\n        \"baseVersion\": null,\n        \"dataReceived\": {\n            \"label\": \"test entity\",\n            \"osm_id\": \"1\",\n            \"geometry\": \"test\"\n        },\n        \"conflictingProperties\": null\n    }\n    }\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (str): The name of a dataset, specific to a project.\n        entityUuid (str): Unique itentifier of the entity in the dataset.\n\n    Returns:\n        dict: the JSON entity details, for a specific dataset.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities/{entityUuid}\"\n    try:\n        async with self.session.get(url, ssl=self.verify) as response:\n            return await response.json()\n    except aiohttp.ClientError as e:\n        # NOTE skip raising exception on HTTP 404 (not found)\n        log.error(f\"Error fetching entity: {e}\")\n        return {}\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.createEntity","title":"createEntity  <code>async</code>","text":"<pre><code>createEntity(projectId, datasetName, label, data)\n</code></pre> <p>Create a new Entity in a project dataset (entity list).</p> <p>JSON request: { \"uuid\": \"54a405a0-53ce-4748-9788-d23a30cc3afa\", \"label\": \"John Doe (88)\", \"data\": {     \"firstName\": \"John\",     \"age\": \"88\" } }</p> <p>JSON response: { \"uuid\": \"d2e03bf8-cfc9-45c6-ab23-b8bc5b7d9aba\", \"createdAt\": \"2024-04-12T15:22:02.148Z\", \"creatorId\": 5, \"updatedAt\": None, \"deletedAt\": None, \"conflict\": None, \"currentVersion\": {     \"createdAt\": \"2024-04-12T15:22:02.148Z\",     \"current\": True,     \"label\": \"test entity 1\",     \"creatorId\": 5,     \"userAgent\": \"Python/3.10 aiohttp/3.9.3\",     \"data\": {         \"status\": \"READY\",         \"geometry\": \"test\"     },     \"version\": 1,     \"baseVersion\": None,     \"dataReceived\": {         \"label\": \"test entity 1\",         \"status\": \"READY\",         \"geometry\": \"test\"     },     \"conflictingProperties\": None } }</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>label</code> <code>str</code> <p>Label for the Entity.</p> required <code>data</code> <code>dict</code> <p>Key:Value pairs to insert as Entity data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>JSON of entity details. The 'uuid' field includes the unique entity identifier.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def createEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    label: str,\n    data: dict,\n) -&gt; dict:\n    \"\"\"Create a new Entity in a project dataset (entity list).\n\n    JSON request:\n    {\n    \"uuid\": \"54a405a0-53ce-4748-9788-d23a30cc3afa\",\n    \"label\": \"John Doe (88)\",\n    \"data\": {\n        \"firstName\": \"John\",\n        \"age\": \"88\"\n    }\n    }\n\n    JSON response:\n    {\n    \"uuid\": \"d2e03bf8-cfc9-45c6-ab23-b8bc5b7d9aba\",\n    \"createdAt\": \"2024-04-12T15:22:02.148Z\",\n    \"creatorId\": 5,\n    \"updatedAt\": None,\n    \"deletedAt\": None,\n    \"conflict\": None,\n    \"currentVersion\": {\n        \"createdAt\": \"2024-04-12T15:22:02.148Z\",\n        \"current\": True,\n        \"label\": \"test entity 1\",\n        \"creatorId\": 5,\n        \"userAgent\": \"Python/3.10 aiohttp/3.9.3\",\n        \"data\": {\n            \"status\": \"READY\",\n            \"geometry\": \"test\"\n        },\n        \"version\": 1,\n        \"baseVersion\": None,\n        \"dataReceived\": {\n            \"label\": \"test entity 1\",\n            \"status\": \"READY\",\n            \"geometry\": \"test\"\n        },\n        \"conflictingProperties\": None\n    }\n    }\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        label (str): Label for the Entity.\n        data (dict): Key:Value pairs to insert as Entity data.\n\n    Returns:\n        dict: JSON of entity details.\n            The 'uuid' field includes the unique entity identifier.\n    \"\"\"\n    # The CSV must contain a geometry field to work\n    # TODO also add this validation to uploadMedia if CSV format\n\n    required_fields = [\"geometry\"]\n    if not all(key in data for key in required_fields):\n        msg = \"'geometry' data field is mandatory\"\n        log.debug(msg)\n        raise ValueError(msg)\n\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities\"\n    try:\n        async with self.session.post(\n            url,\n            ssl=self.verify,\n            json={\n                \"uuid\": str(uuid4()),\n                \"label\": label,\n                \"data\": data,\n            },\n        ) as response:\n            return await response.json()\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to create Entity: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.createEntities","title":"createEntities  <code>async</code>","text":"<pre><code>createEntities(projectId, datasetName, entities)\n</code></pre> <p>Bulk create Entities in a project dataset (entity list).</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>entities</code> <code>list[EntityIn]</code> <p>A list of Entities to insert. Format: {\"label\": \"John Doe\", \"data\": {\"firstName\": \"John\", \"age\": \"22\"}}</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <code>dict</code> <code>dict</code> <p>{'success': true} When creating bulk entities ODK Central return this for now.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def createEntities(\n    self,\n    projectId: int,\n    datasetName: str,\n    entities: list[EntityIn],\n) -&gt; dict:\n    \"\"\"Bulk create Entities in a project dataset (entity list).\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        entities (list[EntityIn]): A list of Entities to insert.\n            Format: {\"label\": \"John Doe\", \"data\": {\"firstName\": \"John\", \"age\": \"22\"}}\n\n    Returns:\n        # list: A list of Entity detail JSONs.\n        #     The 'uuid' field includes the unique entity identifier.\n        dict: {'success': true}\n            When creating bulk entities ODK Central return this for now.\n    \"\"\"\n    # Validation\n    if not isinstance(entities, list):\n        raise ValueError(\"Entities must be a list\")\n\n    log.info(f\"Bulk uploading ({len(entities)}) Entities for ODK project ({projectId}) dataset ({datasetName})\")\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities\"\n    payload = {\"entities\": entities, \"source\": {\"name\": \"features.csv\"}}\n\n    try:\n        async with self.session.post(url, ssl=self.verify, json=payload) as response:\n            response.raise_for_status()\n            log.info(f\"Successfully created entities for ODK project ({projectId}) in dataset ({datasetName})\")\n            return await response.json()\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to create Entities: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.createEntities--list-a-list-of-entity-detail-jsons","title":"list: A list of Entity detail JSONs.","text":""},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.createEntities--the-uuid-field-includes-the-unique-entity-identifier","title":"The 'uuid' field includes the unique entity identifier.","text":""},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.updateEntity","title":"updateEntity  <code>async</code>","text":"<pre><code>updateEntity(projectId, datasetName, entityUuid, label=None, data=None, newVersion=None)\n</code></pre> <p>Update an existing Entity in a project dataset (entity list).</p> <p>The JSON request format is the same as creating, minus the 'uuid' field. The PATCH will only update the specific fields specified, leaving the     remainder.</p> <p>If no 'newVersion' param is provided, the entity will be force updated     in place. If 'newVersion' is provided, this must be a single integer increment     from the current version.</p> <p>Example response: { \"uuid\": \"71fff014-7518-429b-b97c-1332149efe7a\", \"createdAt\": \"2024-04-12T14:22:37.121Z\", \"creatorId\": 5, \"updatedAt\": \"2024-04-12T14:22:37.544Z\", \"deletedAt\": None, \"conflict\": None, \"currentVersion\": {     \"createdAt\": \"2024-04-12T14:22:37.544Z\",     \"current\": True,     \"label\": \"new label\",     \"creatorId\": 5,     \"userAgent\": \"Python/3.10 aiohttp/3.9.3\",     \"data\": {         \"osm_id\": \"1\",         \"status\": \"new status\",         \"geometry\": \"test\",         \"project_id\": \"100\"     },     \"version\": 3,     \"baseVersion\": 2,     \"dataReceived\": {         \"status\": \"new status\",         \"project_id\": \"100\"     },     \"conflictingProperties\": None } }</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>entityUuid</code> <code>str</code> <p>Unique itentifier of the entity.</p> required <code>label</code> <code>str</code> <p>Label for the Entity.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Key:Value pairs to insert as Entity data.</p> <code>None</code> <code>newVersion</code> <code>int</code> <p>Integer version to increment to (current version + 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>JSON of entity details. The 'uuid' field includes the unique entity identifier.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def updateEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    entityUuid: str,\n    label: Optional[str] = None,\n    data: Optional[dict] = None,\n    newVersion: Optional[int] = None,\n) -&gt; dict:\n    \"\"\"Update an existing Entity in a project dataset (entity list).\n\n    The JSON request format is the same as creating, minus the 'uuid' field.\n    The PATCH will only update the specific fields specified, leaving the\n        remainder.\n\n    If no 'newVersion' param is provided, the entity will be force updated\n        in place.\n    If 'newVersion' is provided, this must be a single integer increment\n        from the current version.\n\n    Example response:\n    {\n    \"uuid\": \"71fff014-7518-429b-b97c-1332149efe7a\",\n    \"createdAt\": \"2024-04-12T14:22:37.121Z\",\n    \"creatorId\": 5,\n    \"updatedAt\": \"2024-04-12T14:22:37.544Z\",\n    \"deletedAt\": None,\n    \"conflict\": None,\n    \"currentVersion\": {\n        \"createdAt\": \"2024-04-12T14:22:37.544Z\",\n        \"current\": True,\n        \"label\": \"new label\",\n        \"creatorId\": 5,\n        \"userAgent\": \"Python/3.10 aiohttp/3.9.3\",\n        \"data\": {\n            \"osm_id\": \"1\",\n            \"status\": \"new status\",\n            \"geometry\": \"test\",\n            \"project_id\": \"100\"\n        },\n        \"version\": 3,\n        \"baseVersion\": 2,\n        \"dataReceived\": {\n            \"status\": \"new status\",\n            \"project_id\": \"100\"\n        },\n        \"conflictingProperties\": None\n    }\n    }\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        entityUuid (str): Unique itentifier of the entity.\n        label (str): Label for the Entity.\n        data (dict): Key:Value pairs to insert as Entity data.\n        newVersion (int): Integer version to increment to (current version + 1).\n\n    Returns:\n        dict: JSON of entity details.\n            The 'uuid' field includes the unique entity identifier.\n    \"\"\"\n    if not label and not data:\n        msg = \"One of either the 'label' or 'data' fields must be passed\"\n        log.debug(msg)\n        raise ValueError(msg)\n\n    json_data = {}\n    if data:\n        json_data[\"data\"] = data\n    if label:\n        json_data[\"label\"] = label\n\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities/{entityUuid}\"\n    if newVersion:\n        url = f\"{url}?baseVersion={newVersion - 1}\"\n    else:\n        url = f\"{url}?force=true\"\n\n    try:\n        log.info(\n            f\"Updating Entity ({entityUuid}) for ODK project ({projectId}) \"\n            f\"with params: label={label} data={data} newVersion={newVersion}\"\n        )\n        async with self.session.patch(\n            url,\n            ssl=self.verify,\n            json=json_data,\n        ) as response:\n            return await response.json()\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to update Entity: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.deleteEntity","title":"deleteEntity  <code>async</code>","text":"<pre><code>deleteEntity(projectId, datasetName, entityUuid)\n</code></pre> <p>Delete an Entity in a project dataset (entity list).</p> <p>Only performs a soft deletion, so the Entity is actually archived.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>entityUuid</code> <code>str</code> <p>Unique itentifier of the entity.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Deletion successful or not.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def deleteEntity(\n    self,\n    projectId: int,\n    datasetName: str,\n    entityUuid: str,\n) -&gt; bool:\n    \"\"\"Delete an Entity in a project dataset (entity list).\n\n    Only performs a soft deletion, so the Entity is actually archived.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        entityUuid (str): Unique itentifier of the entity.\n\n    Returns:\n        bool: Deletion successful or not.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}/entities/{entityUuid}\"\n    log.debug(f\"Deleting dataset ({datasetName}) entity UUID ({entityUuid})\")\n    try:\n        log.info(f\"Deleting Entity ({entityUuid}) for ODK project ({projectId}) and dataset ({datasetName})\")\n        async with self.session.delete(url, ssl=self.verify) as response:\n            success = (response_msg := await response.json()).get(\"success\", False)\n            if not success:\n                log.debug(f\"Server returned deletion unsuccessful: {response_msg}\")\n            return success\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to delete Entity: {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.getEntityCount","title":"getEntityCount  <code>async</code>","text":"<pre><code>getEntityCount(projectId, datasetName)\n</code></pre> <p>Get only the count of the Entity entries.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>All entity data for a project dataset.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def getEntityCount(\n    self,\n    projectId: int,\n    datasetName: str,\n) -&gt; int:\n    \"\"\"Get only the count of the Entity entries.\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n\n    Returns:\n        int: All entity data for a project dataset.\n    \"\"\"\n    # NOTE returns no entity data (value: []), only the count\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}.svc/Entities?%24top=0&amp;%24count=true\"\n    try:\n        async with self.session.get(url, ssl=self.verify) as response:\n            count = (await response.json()).get(\"@odata.count\", None)\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to get Entity count for ODK project ({projectId}): {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n\n    if count is None:\n        log.debug(f\"Project ({projectId}) has no Entities in dataset ({datasetName})\")\n        return 0\n\n    return count\n</code></pre>"},{"location":"api/OdkCentralAsync/#osm_fieldwork.OdkCentralAsync.OdkDataset.getEntityData","title":"getEntityData  <code>async</code>","text":"<pre><code>getEntityData(projectId, datasetName, url_params=None, include_metadata=False)\n</code></pre> <p>Get a lightweight JSON of the entity data fields in a dataset.</p> <p>Be sure to check the latest docs to see which fields are supported for OData filtering: https://docs.getodk.org/central-api-odata-endpoints/#id3</p> <p>Example response list (include_metadata=False): [     {         \"__id\": \"523699d0-66ec-4cfc-a76b-4617c01c6b92\",         \"label\": \"the_label_you_defined\",         \"__system\": {             \"createdAt\": \"2024-03-24T06:30:31.219Z\",             \"creatorId\": \"7\",             \"creatorName\": \"fmtm@hotosm.org\",             \"updates\": 4,             \"updatedAt\": \"2024-03-24T07:12:55.871Z\",             \"version\": 5,             \"conflict\": null         },         \"geometry\": \"javarosa format geometry\",         \"user_defined_field2\": \"text\",         \"user_defined_field2\": \"text\",         \"user_defined_field3\": \"test\"     } ]</p> <p>Example response JSON where: - url_params=\"$top=205&amp;$count=true\" - include_metadata=True automatically due to use of $top param</p> <p>{ \"value\": [     {     \"__id\": \"523699d0-66ec-4cfc-a76b-4617c01c6b92\",     \"label\": \"the_label_you_defined\",     \"__system\": {         \"createdAt\": \"2024-03-24T06:30:31.219Z\",         \"creatorId\": \"7\",         \"creatorName\": \"fmtm@hotosm.org\",         \"updates\": 4,         \"updatedAt\": \"2024-03-24T07:12:55.871Z\",         \"version\": 5,         \"conflict\": null     },     \"geometry\": \"javarosa format geometry\",     \"user_defined_field2\": \"text\",     \"user_defined_field2\": \"text\",     \"user_defined_field3\": \"test\"     } ] \"@odata.context\": (     \"https://URL/v1/projects/6/datasets/buildings.svc/$metadata#Entities\", ) \"@odata.nextLink\": (     \"https://URL/v1/projects/6/datasets/buildings.svc/Entities\"     \"?%24top=250&amp;%24count=true&amp;%24skiptoken=returnedtokenhere%3D\" \"@odata.count\": 667 }</p> <p>Info on OData URL params: http://docs.oasis-open.org /odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358948</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central.</p> required <code>datasetName</code> <code>int</code> <p>The name of a dataset, specific to a project.</p> required <code>url_params</code> <code>str</code> <p>Any supported OData URL params, such as 'filter' or 'select'. The ? is not required.</p> <code>None</code> <code>include_metadata</code> <code>bool</code> <p>Include additional metadata. If true, returns a dict, if false, returns a list of Entities. If $top is included in url_params, this is enabled by default to get the \"@odata.nextLink\" field.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict | list</code> <p>list | dict: All (or filtered) entity data for a project dataset.</p> Source code in <code>osm_fieldwork/OdkCentralAsync.py</code> <pre><code>async def getEntityData(\n    self,\n    projectId: int,\n    datasetName: str,\n    url_params: Optional[str] = None,\n    include_metadata: Optional[bool] = False,\n) -&gt; dict | list:\n    \"\"\"Get a lightweight JSON of the entity data fields in a dataset.\n\n    Be sure to check the latest docs to see which fields are supported for\n    OData filtering:\n    https://docs.getodk.org/central-api-odata-endpoints/#id3\n\n    Example response list (include_metadata=False):\n    [\n        {\n            \"__id\": \"523699d0-66ec-4cfc-a76b-4617c01c6b92\",\n            \"label\": \"the_label_you_defined\",\n            \"__system\": {\n                \"createdAt\": \"2024-03-24T06:30:31.219Z\",\n                \"creatorId\": \"7\",\n                \"creatorName\": \"fmtm@hotosm.org\",\n                \"updates\": 4,\n                \"updatedAt\": \"2024-03-24T07:12:55.871Z\",\n                \"version\": 5,\n                \"conflict\": null\n            },\n            \"geometry\": \"javarosa format geometry\",\n            \"user_defined_field2\": \"text\",\n            \"user_defined_field2\": \"text\",\n            \"user_defined_field3\": \"test\"\n        }\n    ]\n\n    Example response JSON where:\n    - url_params=\"$top=205&amp;$count=true\"\n    - include_metadata=True automatically due to use of $top param\n\n    {\n    \"value\": [\n        {\n        \"__id\": \"523699d0-66ec-4cfc-a76b-4617c01c6b92\",\n        \"label\": \"the_label_you_defined\",\n        \"__system\": {\n            \"createdAt\": \"2024-03-24T06:30:31.219Z\",\n            \"creatorId\": \"7\",\n            \"creatorName\": \"fmtm@hotosm.org\",\n            \"updates\": 4,\n            \"updatedAt\": \"2024-03-24T07:12:55.871Z\",\n            \"version\": 5,\n            \"conflict\": null\n        },\n        \"geometry\": \"javarosa format geometry\",\n        \"user_defined_field2\": \"text\",\n        \"user_defined_field2\": \"text\",\n        \"user_defined_field3\": \"test\"\n        }\n    ]\n    \"@odata.context\": (\n        \"https://URL/v1/projects/6/datasets/buildings.svc/$metadata#Entities\",\n    )\n    \"@odata.nextLink\": (\n        \"https://URL/v1/projects/6/datasets/buildings.svc/Entities\"\n        \"?%24top=250&amp;%24count=true&amp;%24skiptoken=returnedtokenhere%3D\"\n    \"@odata.count\": 667\n    }\n\n    Info on OData URL params:\n    http://docs.oasis-open.org\n    /odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358948\n\n    Args:\n        projectId (int): The ID of the project on ODK Central.\n        datasetName (int): The name of a dataset, specific to a project.\n        url_params (str): Any supported OData URL params, such as 'filter'\n            or 'select'. The ? is not required.\n        include_metadata (bool): Include additional metadata.\n            If true, returns a dict, if false, returns a list of Entities.\n            If $top is included in url_params, this is enabled by default to get\n            the \"@odata.nextLink\" field.\n\n    Returns:\n        list | dict: All (or filtered) entity data for a project dataset.\n    \"\"\"\n    url = f\"{self.base}projects/{projectId}/datasets/{datasetName}.svc/Entities\"\n    if url_params:\n        url += f\"?{url_params}\"\n        if \"$top\" in url_params:\n            # Force enable metadata, as required for pagination\n            include_metadata = True\n\n    try:\n        async with self.session.get(url, ssl=self.verify) as response:\n            response_json = await response.json()\n            if not include_metadata:\n                return response_json.get(\"value\", [])\n            return response_json\n    except aiohttp.ClientError as e:\n        msg = f\"Failed to get Entity data for ODK project ({projectId}): {e}\"\n        log.error(msg)\n        raise aiohttp.ClientError(msg) from e\n</code></pre>"},{"location":"api/OdkCentralAsync/#usage-example","title":"Usage Example","text":"<ul> <li>An async context manager must be used (<code>async with</code>).</li> </ul> <pre><code>from osm_fieldwork.OdkCentralAsync import OdkProject\n\nasync with OdkProject(\n    url=\"http://server.com\",\n    user=\"user@domain.com\",\n    passwd=\"password\",\n) as odk_central:\n    projects = await odk_central.listProjects()\n</code></pre>"},{"location":"api/basemapper/","title":"basemapper.py","text":"<p>Thread to handle downloads for Queue.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>str</code> <p>The filespec of the tile cache.</p> required <code>mirrors</code> <code>list</code> <p>The list of mirrors to get imagery.</p> required <code>tiles</code> <code>list</code> <p>The list of tiles to download.</p> required Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def dlthread(dest: str, mirrors: list[dict], tiles: list[tuple]) -&gt; None:\n    \"\"\"Thread to handle downloads for Queue.\n\n    Args:\n        dest (str): The filespec of the tile cache.\n        mirrors (list): The list of mirrors to get imagery.\n        tiles (list): The list of tiles to download.\n    \"\"\"\n    if len(tiles) == 0:\n        # epdb.st()\n        return\n\n    # Create the subdirectories as pySmartDL doesn't do it for us\n    Path(dest).mkdir(parents=True, exist_ok=True)\n\n    log.info(f\"Downloading {len(tiles)} tiles in thread {threading.get_ident()} to {dest}\")\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [executor.submit(download_tile, dest, tile, mirrors) for tile in tiles]\n        concurrent.futures.wait(futures)\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>object</code></p> <p>Basemapper parent class.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Union[str, BytesIO]</code> <p>A BBOX string or GeoJSON provided as BytesIO object of the AOI. The GeoJSON can contain multiple geometries.</p> required <code>base</code> <code>str</code> <p>The base directory to cache map tile in</p> required <code>source</code> <code>str</code> <p>The upstream data source for map tiles</p> required <p>Returns:</p> Type Description <code>BaseMapper</code> <p>An instance of this class</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def __init__(\n    self,\n    boundary: Union[str, BytesIO],\n    base: str,\n    source: str,\n):\n    \"\"\"Create an tile basemap for ODK Collect.\n\n    Args:\n        boundary (Union[str, BytesIO]): A BBOX string or GeoJSON provided as BytesIO object of the AOI.\n            The GeoJSON can contain multiple geometries.\n        base (str): The base directory to cache map tile in\n        source (str): The upstream data source for map tiles\n\n    Returns:\n        (BaseMapper): An instance of this class\n    \"\"\"\n    bbox_factory = BoundaryHandlerFactory(boundary)\n    self.bbox = bbox_factory.get_bounding_box()\n    self.tiles = list()\n    self.base = base\n    # sources for imagery\n    self.source = source\n    self.sources = dict()\n\n    path = xlsforms_path.replace(\"xlsforms\", \"imagery.yaml\")\n    self.yaml = YamlFile(path)\n\n    for entry in self.yaml.yaml[\"sources\"]:\n        for k, v in entry.items():\n            src = dict()\n            for item in v:\n                src[\"source\"] = k\n                for k1, v1 in item.items():\n                    # print(f\"\\tFIXME2: {k1} - {v1}\")\n                    src[k1] = v1\n            self.sources[k] = src\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>Create a basemap with given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>str | BytesIO</code> <p>The boundary for the area you want.</p> <code>None</code> <code>tms</code> <code>str</code> <p>Custom TMS URL.</p> <code>None</code> <code>xy</code> <code>bool</code> <p>Swap the X &amp; Y coordinates when using a custom TMS if True.</p> <code>False</code> <code>outfile</code> <code>str</code> <p>Output file name for the basemap.</p> <code>None</code> <code>zooms</code> <code>str</code> <p>The Zoom levels, specified as a range (e.g., \"12-17\") or comma-separated levels (e.g., \"12,13,14\").</p> <code>'12-17'</code> <code>outdir</code> <code>str</code> <p>Output directory name for tile cache.</p> <code>None</code> <code>source</code> <code>str</code> <p>Imagery source, one of [\"esri\", \"bing\", \"topo\", \"google\", \"oam\", \"custom\"] (default is \"esri\").</p> <code>'esri'</code> <code>append</code> <code>bool</code> <p>Whether to append to an existing file</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def create_basemap_file(\n    boundary=None,\n    tms=None,\n    xy=False,\n    outfile=None,\n    zooms=\"12-17\",\n    outdir=None,\n    source=\"esri\",\n    append: bool = False,\n) -&gt; None:\n    \"\"\"Create a basemap with given parameters.\n\n    Args:\n        boundary (str | BytesIO, optional): The boundary for the area you want.\n        tms (str, optional): Custom TMS URL.\n        xy (bool, optional): Swap the X &amp; Y coordinates when using a\n            custom TMS if True.\n        outfile (str, optional): Output file name for the basemap.\n        zooms (str, optional): The Zoom levels, specified as a range\n            (e.g., \"12-17\") or comma-separated levels (e.g., \"12,13,14\").\n        outdir (str, optional): Output directory name for tile cache.\n        source (str, optional): Imagery source, one of\n            [\"esri\", \"bing\", \"topo\", \"google\", \"oam\", \"custom\"] (default is \"esri\").\n        append (bool, optional): Whether to append to an existing file\n\n    Returns:\n        None\n    \"\"\"\n    log.debug(\n        \"Creating basemap with params: \"\n        f\"boundary={boundary} | \"\n        f\"outfile={outfile} | \"\n        f\"zooms={zooms} | \"\n        f\"outdir={outdir} | \"\n        f\"source={source} | \"\n        f\"tms={tms}\"\n    )\n\n    # Validation\n    if not boundary:\n        err = \"You need to specify a boundary! (in-memory object or bbox)\"\n        log.error(err)\n        raise ValueError(err)\n\n    # Get all the zoom levels we want\n    zoom_levels = list()\n    if zooms:\n        if zooms.find(\"-\") &gt; 0:\n            start = int(zooms.split(\"-\")[0])\n            end = int(zooms.split(\"-\")[1]) + 1\n            x = range(start, end)\n            for i in x:\n                zoom_levels.append(i)\n        elif zooms.find(\",\") &gt; 0:\n            levels = zooms.split(\",\")\n            for level in levels:\n                zoom_levels.append(int(level))\n        else:\n            zoom_levels.append(int(zooms))\n\n    if not outdir:\n        base = Path.cwd().absolute()\n    else:\n        base = Path(outdir).absolute()\n\n    # Source / TMS validation\n    if not source and not tms:\n        err = \"You need to specify a source!\"\n        log.error(err)\n        raise ValueError(err)\n    if source == \"oam\" and not tms:\n        err = \"A TMS URL must be provided for OpenAerialMap!\"\n        log.error(err)\n        raise ValueError(err)\n    # A custom TMS provider\n    if source != \"oam\" and tms:\n        source = \"custom\"\n\n    tiledir = base / f\"{source}tiles\"\n    # Make tile download directory\n    tiledir.mkdir(parents=True, exist_ok=True)\n    # Convert to string for other methods\n    tiledir = str(tiledir)\n\n    basemap = BaseMapper(boundary, tiledir, source)\n\n    if tms:\n        # Add TMS URL to sources for download\n        basemap.customTMS(tms, True if source == \"oam\" else False, xy)\n\n    # Args parsed, main code:\n    tiles = list()\n    for zoom_level in zoom_levels:\n        # Download the tile directory\n        basemap.getTiles(zoom_level)\n        tiles += basemap.tiles\n\n    if not outfile:\n        log.info(f\"No outfile specified, tile download finished: {tiledir}\")\n        return\n\n    suffix = Path(outfile).suffix.lower()\n    image_format = basemap.sources[source].get(\"suffix\", \"jpg\")\n    log.debug(f\"Basemap output format: {suffix} | Image format: {image_format}\")\n\n    if any(substring in suffix for substring in [\"sqlite\", \"mbtiles\"]):\n        outf = DataFile(outfile, basemap.getFormat(), append)\n        if suffix == \".mbtiles\":\n            outf.addBounds(basemap.bbox)\n            outf.addZoomLevels(zoom_levels)\n        # Create output database and specify image format, png, jpg, or tif\n        outf.writeTiles(tiles, tiledir, image_format)\n\n    elif suffix == \".pmtiles\":\n        tile_dir_to_pmtiles(outfile, tiledir, basemap.bbox, image_format, zoom_levels, source)\n\n    else:\n        msg = f\"Format {suffix} not supported\"\n        log.error(msg)\n        raise ValueError(msg) from None\n    log.info(f\"Wrote {outfile}\")\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>Write PMTiles archive from tiles in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output PMTiles archive file path.</p> required <code>tile_dir</code> <code>str | Path</code> <p>The directory containing the tile images.</p> required <code>bbox</code> <code>tuple</code> <p>Bounding box in format (min_lon, min_lat, max_lon, max_lat).</p> required <code>attribution</code> <code>str</code> <p>Attribution string to include in PMTile archive.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def tile_dir_to_pmtiles(\n    outfile: str,\n    tile_dir: str | Path,\n    bbox: tuple,\n    image_format: str,\n    zoom_levels: list[int],\n    attribution: str,\n):\n    \"\"\"Write PMTiles archive from tiles in the specified directory.\n\n    Args:\n        outfile (str): The output PMTiles archive file path.\n        tile_dir (str | Path): The directory containing the tile images.\n        bbox (tuple): Bounding box in format (min_lon, min_lat, max_lon, max_lat).\n        attribution (str): Attribution string to include in PMTile archive.\n\n    Returns:\n        None\n    \"\"\"\n    tile_dir = Path(tile_dir)\n\n    # Abort if no files are present\n    first_file = next((file for file in tile_dir.rglob(\"*.*\") if file.is_file()), None)\n    if not first_file:\n        err = \"No tile files found in the specified directory. Aborting PMTile creation.\"\n        log.error(err)\n        raise ValueError(err)\n\n    tile_format = image_format.upper()\n    # NOTE JPEG exception / flexible extension (.jpg, .jpeg)\n    if tile_format == \"JPG\":\n        tile_format = \"JPEG\"\n    log.debug(f\"PMTile determind internal file format: {tile_format}\")\n    possible_tile_formats = [f\".{e.name.lower()}\" for e in PMTileType]\n    possible_tile_formats.append(\".jpg\")\n    possible_tile_formats.remove(\".unknown\")\n\n    with open(outfile, \"wb\") as pmtile_file:\n        writer = PMTileWriter(pmtile_file)\n\n        for tile_path in tile_dir.rglob(\"*\"):\n            if tile_path.is_file() and tile_path.suffix.lower() in possible_tile_formats:\n                tile_id = tileid_from_zyx_dir_path(tile_path)\n\n                with open(tile_path, \"rb\") as tile:\n                    writer.write_tile(tile_id, tile.read())\n\n        min_lon, min_lat, max_lon, max_lat = bbox\n        log.debug(\n            f\"Writing PMTiles file with min_zoom ({zoom_levels[0]}) \"\n            f\"max_zoom ({zoom_levels[-1]}) bbox ({bbox}) tile_compression None\"\n        )\n\n        # Write PMTile metadata\n        writer.finalize(\n            header={\n                \"tile_type\": PMTileType[tile_format],\n                \"tile_compression\": PMTileCompression.NONE,\n                \"min_zoom\": zoom_levels[0],\n                \"max_zoom\": zoom_levels[-1],\n                \"min_lon_e7\": int(min_lon * 10000000),\n                \"min_lat_e7\": int(min_lat * 10000000),\n                \"max_lon_e7\": int(max_lon * 10000000),\n                \"max_lat_e7\": int(max_lat * 10000000),\n                \"center_zoom\": zoom_levels[0],\n                \"center_lon_e7\": int(min_lon + ((max_lon - min_lon) / 2)),\n                \"center_lat_e7\": int(min_lat + ((max_lat - min_lat) / 2)),\n            },\n            metadata={\"attribution\": f\"\u00a9 {attribution}\"},\n        )\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>Helper function to get the tile id from a tile in xyz (zyx) directory structure.</p> <p>TMS typically has structure z/y/x.png If the --xy flag was used previously, the TMS was downloaed into directories of z/y/x structure from their z/x/y URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to tile image within the xyz directory.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The globally defined tile id from the xyz definition.</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def tileid_from_zyx_dir_path(filepath: Union[Path, str]) -&gt; int:\n    \"\"\"Helper function to get the tile id from a tile in xyz (zyx) directory structure.\n\n    TMS typically has structure z/y/x.png\n    If the --xy flag was used previously, the TMS was downloaed into\n    directories of z/y/x structure from their z/x/y URL.\n\n    Args:\n        filepath (Union[Path, str]): The path to tile image within the xyz directory.\n\n    Returns:\n        int: The globally defined tile id from the xyz definition.\n    \"\"\"\n    # Extract the final 3 parts from the TMS file path\n    tile_image_path = Path(filepath).parts[-3:]\n\n    try:\n        final_tile = int(Path(tile_image_path[-1]).stem)\n    except ValueError as e:\n        msg = f\"Invalid tile path (cannot parse as int): {str(tile_image_path)}\"\n        log.error(msg)\n        raise ValueError(msg) from e\n\n    x = final_tile\n    z, y = map(int, tile_image_path[:-1])\n\n    return zxy_to_tileid(z, x, y)\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.customTMS","title":"customTMS","text":"<pre><code>customTMS(url, is_oam=False, is_xy=False)\n</code></pre> <p>Add a custom TMS URL to the list of sources.</p> <p>The url must end in %s to be replaced with the tile xyz values.</p> <p>Format examples: https://basemap.nationalmap.gov/ArcGIS/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x} https://maps.nyc.gov/xyz/1.0.0/carto/basemap/%s https://maps.nyc.gov/xyz/1.0.0/carto/basemap/{z}/{x}/{y}.jpg</p> <p>The method will replace {z}/{x}/{y}.jpg with %s</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL string</p> required <code>source</code> <code>str</code> <p>The provier source, for setting attribution</p> required <code>is_xy</code> <code>bool</code> <p>Swap the x and y for the provider --&gt; 'zxy'</p> <code>False</code> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def customTMS(self, url: str, is_oam: bool = False, is_xy: bool = False):\n    \"\"\"Add a custom TMS URL to the list of sources.\n\n    The url must end in %s to be replaced with the tile xyz values.\n\n    Format examples:\n    https://basemap.nationalmap.gov/ArcGIS/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}\n    https://maps.nyc.gov/xyz/1.0.0/carto/basemap/%s\n    https://maps.nyc.gov/xyz/1.0.0/carto/basemap/{z}/{x}/{y}.jpg\n\n    The method will replace {z}/{x}/{y}.jpg with %s\n\n    Args:\n        url (str): The URL string\n        source (str): The provier source, for setting attribution\n        is_xy (bool): Swap the x and y for the provider --&gt; 'zxy'\n    \"\"\"\n    # Remove any file extensions if present and update the 'suffix' parameter\n    # NOTE the file extension gets added again later for the download URL\n    if url.endswith(\".jpg\"):\n        suffix = \"jpg\"\n        url = url[:-4]  # Remove the last 4 characters (\".jpg\")\n    elif url.endswith(\".png\"):\n        suffix = \"png\"\n        url = url[:-4]  # Remove the last 4 characters (\".png\")\n    else:\n        # FIXME handle other formats for custom TMS\n        suffix = \"jpg\"\n\n    # If placeholders present, validate they have no additional spaces\n    if \"{\" in url and \"}\" in url:\n        pattern = r\".*/\\{[zxy]\\}/\\{[zxy]\\}/\\{[zxy]\\}(?:/|/?)\"\n        if not bool(re.search(pattern, url)):\n            msg = \"Invalid TMS URL format. Please check the URL placeholders {z}/{x}/{y}.\"\n            log.error(msg)\n            raise ValueError(msg)\n\n    # Remove \"{z}/{x}/{y}\" placeholders if they are present\n    url = re.sub(r\"/{[xyz]+\\}\", \"\", url)\n    # Append \"%s\" to the end of the URL to later add the tile path\n    url = url + r\"/%s\"\n\n    if is_oam:\n        # Override dummy OAM URL\n        source = \"oam\"\n        self.sources[source][\"url\"] = url\n    else:\n        source = \"custom\"\n        tms_params = {\"name\": source, \"url\": url, \"suffix\": suffix, \"source\": source, \"xy\": is_xy}\n        log.debug(f\"Setting custom TMS with params: {tms_params}\")\n        self.sources[source] = tms_params\n\n    # Select the source\n    self.source = source\n</code></pre>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.getFormat","title":"getFormat","text":"<pre><code>getFormat()\n</code></pre> <p>Get the image format of the map tiles.</p> <p>Returns:</p> Type Description <code>str</code> <p>the upstream source for map tiles.</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def getFormat(self):\n    \"\"\"Get the image format of the map tiles.\n\n    Returns:\n        (str): the upstream source for map tiles.\n    \"\"\"\n    return self.sources[self.source][\"suffix\"]\n</code></pre>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.getTiles","title":"getTiles","text":"<pre><code>getTiles(zoom)\n</code></pre> <p>Get a list of tiles for the specified zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The Zoom level of the desired map tiles.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of map tiles downloaded.</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def getTiles(self, zoom: int) -&gt; int:\n    \"\"\"Get a list of tiles for the specified zoom level.\n\n    Args:\n        zoom (int): The Zoom level of the desired map tiles.\n\n    Returns:\n        int: The total number of map tiles downloaded.\n    \"\"\"\n    info = get_cpu_info()\n    cores = info[\"count\"]\n\n    self.tiles = list(mercantile.tiles(self.bbox[0], self.bbox[1], self.bbox[2], self.bbox[3], zoom))\n    total = len(self.tiles)\n    log.info(f\"{total} tiles for zoom level {zoom}\")\n\n    mirrors = [self.sources[self.source]]\n    chunk_size = max(1, round(total / cores))\n\n    if total &lt; chunk_size or chunk_size == 0:\n        dlthread(self.base, mirrors, self.tiles)\n    else:\n        with concurrent.futures.ThreadPoolExecutor(max_workers=cores) as executor:\n            futures = []\n            for i in range(0, total, chunk_size):\n                chunk = self.tiles[i : i + chunk_size]\n                futures.append(executor.submit(dlthread, self.base, mirrors, chunk))\n                log.debug(f\"Dispatching Block {i}:{i + chunk_size}\")\n            concurrent.futures.wait(futures)\n\n    return total\n</code></pre>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.tileExists","title":"tileExists","text":"<pre><code>tileExists(tile)\n</code></pre> <p>See if a map tile already exists.</p> <p>Parameters:</p> Name Type Description Default <code>tile</code> <code>MapTile</code> <p>The map tile to check for the existence of</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the tile exists in the map tile cache</p> Source code in <code>osm_fieldwork/basemapper.py</code> <pre><code>def tileExists(\n    self,\n    tile: MapTile,\n):\n    \"\"\"See if a map tile already exists.\n\n    Args:\n        tile (MapTile): The map tile to check for the existence of\n\n    Returns:\n        (bool): Whether the tile exists in the map tile cache\n    \"\"\"\n    filespec = f\"{self.base}{tile[2]}/{tile[1]}/{tile[0]}.{self.sources[{self.source}]['suffix']}\"\n    if Path(filespec).exists():\n        log.debug(\"%s exists\" % filespec)\n        return True\n    else:\n        log.debug(\"%s doesn't exists\" % filespec)\n        return False\n</code></pre>"},{"location":"api/convert/","title":"convert.py","text":"<p>               Bases: <code>YamlFile</code></p> <p>A class to apply a YAML config file and convert ODK to OSM.</p> <p>Returns:</p> Type Description <code>Convert</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def __init__(\n    self,\n    xform: str = None,\n):\n    path = xlsforms_path.replace(\"xlsforms\", \"\")\n    if xform is not None:\n        file = xform\n    else:\n        file = f\"{path}/xforms.yaml\"\n    self.yaml = YamlFile(file)\n    self.filespec = file\n    # Parse the file contents into a data structure to make it\n    # easier to retrieve values\n    self.convert = dict()\n    self.ignore = list()\n    self.private = list()\n    self.defaults = dict()\n    self.entries = dict()\n    self.types = dict()\n    self.saved = dict()\n    for item in self.yaml.yaml[\"convert\"]:\n        key = list(item.keys())[0]\n        value = item[key]\n        # print(\"ZZZZ: %r, %r\" % (key, value))\n        if type(value) is str:\n            self.convert[key] = value\n        elif type(value) is list:\n            vals = dict()\n            for entry in value:\n                if type(entry) is str:\n                    # epdb.st()\n                    tag = entry\n                else:\n                    tag = list(entry.keys())[0]\n                    vals[tag] = entry[tag]\n            self.convert[key] = vals\n    self.ignore = self.yaml.yaml[\"ignore\"]\n    self.private = self.yaml.yaml[\"private\"]\n    if \"multiple\" in self.yaml.yaml:\n        self.multiple = self.yaml.yaml[\"multiple\"]\n    else:\n        self.multiple = list()\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.privateData","title":"privateData","text":"<pre><code>privateData(keyword)\n</code></pre> <p>Search the private data category for a keyword.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>=If the keyword is in the private data section</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def privateData(\n    self,\n    keyword: str,\n) -&gt; bool:\n    \"\"\"Search the private data category for a keyword.\n\n    Args:\n        keyword (str): The keyword to search for\n\n    Returns:\n        (bool): =If the keyword is in the private data section\n    \"\"\"\n    return keyword.lower() in self.private\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertData","title":"convertData","text":"<pre><code>convertData(keyword)\n</code></pre> <p>Search the convert data category for a keyword.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the convert data section</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def convertData(\n    self,\n    keyword: str,\n) -&gt; bool:\n    \"\"\"Search the convert data category for a keyword.\n\n    Args:\n        keyword (str): The keyword to search for\n\n    Returns:\n        (bool): Check to see if the keyword is in the convert data section\n    \"\"\"\n    return keyword.lower() in self.convert\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.ignoreData","title":"ignoreData","text":"<pre><code>ignoreData(keyword)\n</code></pre> <p>Search the convert data category for a ketyword.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the ignore data section</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def ignoreData(\n    self,\n    keyword: str,\n) -&gt; bool:\n    \"\"\"Search the convert data category for a ketyword.\n\n    Args:\n        keyword (str): The keyword to search for\n\n    Returns:\n        (bool): Check to see if the keyword is in the ignore data section\n    \"\"\"\n    return keyword.lower() in self.ignore\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.getKeyword","title":"getKeyword","text":"<pre><code>getKeyword(value)\n</code></pre> <p>Get the keyword for a value from the yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The value to find the keyword for</p> required <p>Returns:</p> Type Description <code>str</code> <p>The keyword if found, or None</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def getKeyword(\n    self,\n    value: str,\n) -&gt; str:\n    \"\"\"Get the keyword for a value from the yaml file.\n\n    Args:\n        value (str): The value to find the keyword for\n\n    Returns:\n        (str): The keyword if found, or None\n    \"\"\"\n    key = self.yaml.yaml(value)\n    if type(key) == bool:\n        return value\n    if len(key) == 0:\n        key = self.yaml.getKeyword(value)\n    return key\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.getValues","title":"getValues","text":"<pre><code>getValues(keyword=None)\n</code></pre> <p>Get the values for a primary key.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to get the value of</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The values or None</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def getValues(\n    self,\n    keyword: str = None,\n) -&gt; str:\n    \"\"\"Get the values for a primary key.\n\n    Args:\n        keyword (str): The keyword to get the value of\n\n    Returns:\n        (str): The values or None\n    \"\"\"\n    if keyword is not None:\n        if keyword in self.convert:\n            return self.convert[keyword]\n    else:\n        return None\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertEntry","title":"convertEntry","text":"<pre><code>convertEntry(tag, value)\n</code></pre> <p>Convert a tag and value from the ODK represention to an OSM one.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag from the ODK XML file</p> required <code>value</code> <code>str</code> <p>The value from the ODK XML file</p> required <p>Returns:</p> Type Description <code>list</code> <p>The converted values</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def convertEntry(\n    self,\n    tag: str,\n    value: str,\n) -&gt; list:\n    \"\"\"Convert a tag and value from the ODK represention to an OSM one.\n\n    Args:\n        tag (str): The tag from the ODK XML file\n        value (str): The value from the ODK XML file\n\n    Returns:\n        (list): The converted values\n    \"\"\"\n    all = list()\n\n    # If it's not in any conversion data, pass it through unchanged.\n    if tag.lower() in self.ignore:\n        # logging.debug(f\"FIXME: Ignoring {tag}\")\n        return None\n    low = tag.lower()\n    if value is None:\n        return low\n\n    if low not in self.convert and low not in self.ignore and low not in self.private:\n        return {tag: value}\n\n    newtag = tag.lower()\n    newval = value\n    # If the tag is in the config file, convert it.\n    if self.convertData(newtag):\n        newtag = self.convertTag(newtag)\n        # if newtag != tag:\n        #    logging.debug(f\"Converted Tag for entry {tag} to {newtag}\")\n\n    # Truncate the elevation, as it's really long\n    if newtag == \"ele\":\n        value = value[:7]\n    newval = self.convertValue(newtag, value)\n    # logging.debug(\"Converted Value for entry '%s' to '%s'\" % (value, newval))\n    # there can be multiple new tag/value pairs for some values from ODK\n    if type(newval) == str:\n        all.append({newtag: newval})\n    elif type(newval) == list:\n        for entry in newval:\n            if type(entry) == str:\n                all.append({newtag: newval})\n            elif type(entry) == dict:\n                for k, v in entry.items():\n                    all.append({k: v})\n    return all\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertValue","title":"convertValue","text":"<pre><code>convertValue(tag, value)\n</code></pre> <p>Convert a single tag value.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag from the ODK XML file</p> required <code>value</code> <code>str</code> <p>The value from the ODK XML file</p> required <p>Returns:</p> Type Description <code>list</code> <p>The converted values</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def convertValue(\n    self,\n    tag: str,\n    value: str,\n) -&gt; list:\n    \"\"\"Convert a single tag value.\n\n    Args:\n        tag (str): The tag from the ODK XML file\n        value (str): The value from the ODK XML file\n\n    Returns:\n        (list): The converted values\n    \"\"\"\n    all = list()\n\n    vals = self.getValues(tag)\n    # There is no conversion data for this tag\n    if vals is None:\n        return value\n\n    if type(vals) is dict:\n        if value not in vals:\n            all.append({tag: value})\n            return all\n        if type(vals[value]) is bool:\n            entry = dict()\n            if vals[value]:\n                entry[tag] = \"yes\"\n            else:\n                entry[tag] = \"no\"\n            all.append(entry)\n            return all\n        for item in vals[value].split(\",\"):\n            entry = dict()\n            tmp = item.split(\"=\")\n            if len(tmp) == 1:\n                entry[tag] = vals[value]\n            else:\n                entry[tmp[0]] = tmp[1]\n                logging.debug(\"\\tValue %s converted value to %s\" % (value, entry))\n            all.append(entry)\n    return all\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertTag","title":"convertTag","text":"<pre><code>convertTag(tag)\n</code></pre> <p>Convert a single tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag from the ODK XML file</p> required <p>Returns:</p> Type Description <code>str</code> <p>The new tag</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def convertTag(\n    self,\n    tag: str,\n) -&gt; str:\n    \"\"\"Convert a single tag.\n\n    Args:\n        tag (str): The tag from the ODK XML file\n\n    Returns:\n        (str): The new tag\n    \"\"\"\n    low = tag.lower()\n    if low in self.convert:\n        newtag = self.convert[low]\n        if type(newtag) is str:\n            # logging.debug(\"\\tTag '%s' converted tag to '%s'\" % (tag, newtag))\n            tmp = newtag.split(\"=\")\n            if len(tmp) &gt; 1:\n                newtag = tmp[0]\n        elif type(newtag) is list:\n            logging.error(\"FIXME: list()\")\n            # epdb.st()\n            return low, value\n        elif type(newtag) is dict:\n            # logging.error(\"FIXME: dict()\")\n            return low\n        return newtag.lower()\n    else:\n        logging.debug(f\"Not in convert!: {low}\")\n        return low\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertMultiple","title":"convertMultiple","text":"<pre><code>convertMultiple(value)\n</code></pre> <p>Convert a multiple tags from a select_multiple question..</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The tags from the ODK XML file</p> required <p>Returns:</p> Type Description <code>list</code> <p>The new tags</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def convertMultiple(\n    self,\n    value: str,\n) -&gt; list:\n    \"\"\"Convert a multiple tags from a select_multiple question..\n\n    Args:\n        value (str): The tags from the ODK XML file\n\n    Returns:\n        (list): The new tags\n    \"\"\"\n    tags = dict()\n    for tag in value.split(\" \"):\n        low = tag.lower()\n        if self.convertData(low):\n            newtag = self.convert[low]\n            if newtag.find(\"=\") &gt; 0:\n                tmp = newtag.split(\"=\")\n                if tmp[0] in tags:\n                    tags[tmp[0]] = f\"{tags[tmp[0]]};{tmp[1]}\"\n                else:\n                    tags.update({tmp[0]: tmp[1]})\n        else:\n            tags.update({low: \"yes\"})\n    # logging.debug(f\"\\tConverted multiple to {tags}\")\n    return tags\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.parseXLS","title":"parseXLS","text":"<pre><code>parseXLS(xlsfile)\n</code></pre> <p>Parse the source XLSFile if available to look for details we need.</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def parseXLS(\n    self,\n    xlsfile: str,\n):\n    \"\"\"Parse the source XLSFile if available to look for details we need.\"\"\"\n    if xlsfile is not None and len(xlsfile) &gt; 0:\n        self.entries = pd.read_excel(xlsfile, sheet_name=[0])[0]\n        # There will only be a single sheet\n        names = self.entries[\"name\"]\n        defaults = self.entries[\"default\"]\n        i = 0\n        while i &lt; len(self.entries):\n            if type(self.entries[\"type\"][i]) == float:\n                self.types[self.entries[\"name\"][i]] = None\n            else:\n                self.types[self.entries[\"name\"][i]] = self.entries[\"type\"][i].split(\" \")[0]\n            i += 1\n        total = len(names)\n        i = 0\n        while i &lt; total:\n            entry = defaults[i]\n            if str(entry) != \"nan\":\n                pat = re.compile(\"..last-saved.*\")\n                if pat.match(entry):\n                    name = entry.split(\"#\")[1][:-1]\n                    self.saved[name] = None\n                else:\n                    self.defaults[names[i]] = entry\n            i += 1\n    return True\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.createEntry","title":"createEntry","text":"<pre><code>createEntry(entry)\n</code></pre> <p>Create the feature data structure.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>dict</code> <p>The feature data</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The OSM data structure for this entry from the json file</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def createEntry(\n    self,\n    entry: dict,\n) -&gt; dict:\n    \"\"\"Create the feature data structure.\n\n    Args:\n        entry (dict): The feature data\n\n    Returns:\n        (dict): The OSM data structure for this entry from the json file\n    \"\"\"\n    # print(line)\n    feature = dict()\n    attrs = dict()\n    tags = dict()\n    priv = dict()\n    refs = list()\n\n    # log.debug(\"Creating entry\")\n    # First convert the tag to the approved OSM equivalent\n    if \"lat\" in entry and \"lon\" in entry:\n        attrs[\"lat\"] = entry[\"lat\"]\n        attrs[\"lon\"] = entry[\"lon\"]\n    for key, value in entry.items():\n        attributes = (\n            \"id\",\n            \"timestamp\",\n            \"lat\",\n            \"lon\",\n            \"uid\",\n            \"user\",\n            \"version\",\n            \"action\",\n        )\n\n        if key in self.ignore:\n            continue\n        # When using existing OSM data, there's a special geometry field.\n        # Otherwise use the GPS coordinates where you are.\n        if key == \"geometry\" and len(value) &gt; 0:\n            geometry = value.split(\" \")\n            if len(geometry) == 4:\n                attrs[\"lat\"] = geometry[0]\n                attrs[\"lon\"] = geometry[1]\n            continue\n\n        # if 'lat' in attrs and len(attrs[\"lat\"]) == 0:\n        #    continue\n\n        if key is not None and len(key) &gt; 0 and key in attributes:\n            attrs[key] = value\n            # log.debug(\"Adding attribute %s with value %s\" % (key, value))\n            continue\n        if value is not None and value != \"no\" and value != \"unknown\":\n            if key == \"username\":\n                tags[\"user\"] = value\n                continue\n            items = self.convertEntry(key, value)\n            if key in self.types:\n                if self.types[key] == \"select_multiple\":\n                    vals = self.convertMultiple(value)\n                    if len(vals) &gt; 0:\n                        for tag in vals:\n                            tags.update(tag)\n                    continue\n            if key == \"track\" or key == \"geoline\":\n                # refs.append(tags)\n                # log.debug(\"Adding reference %s\" % tags)\n                refs = value.split(\";\")\n            elif type(value) != str:\n                if self.privateData(key):\n                    priv[key] = str(value)\n                else:\n                    tags[key] = str(value)\n            elif len(value) &gt; 0:\n                if self.privateData(key):\n                    priv[key] = value\n                else:\n                    tags[key] = value\n        feature[\"attrs\"] = attrs\n        if len(tags) &gt; 0:\n            # logging.debug(f\"TAGS: {tags}\")\n            feature[\"tags\"] = tags\n        if len(refs) &gt; 1:\n            feature[\"refs\"] = refs\n        if len(priv) &gt; 0:\n            feature[\"private\"] = priv\n\n    return feature\n</code></pre>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/convert.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    print(\"YAML file: %s\" % self.filespec)\n    print(\"Convert section\")\n    for key, val in self.convert.items():\n        if type(val) is list:\n            print(\"\\tTag %s is\" % key)\n            for data in val:\n                print(\"\\t\\t%r\" % data)\n        else:\n            print(\"\\tTag %s is %s\" % (key, val))\n\n    print(\"Ignore Section\")\n    for item in self.ignore:\n        print(f\"\\tIgnoring tag {item}\")\n</code></pre>"},{"location":"api/filter_data/","title":"filter_data.py","text":"<p>               Bases: <code>object</code></p> <p>Returns:</p> Type Description <code>FilterData</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/filter_data.py</code> <pre><code>def __init__(\n    self,\n    filespec: str = None,\n    config: QueryConfig = None,\n):\n    \"\"\"Args:\n        filespec (str): The optional data file to read.\n\n    Returns:\n        (FilterData): An instance of this object\n    \"\"\"\n    self.tags = dict()\n    self.qc = config\n    if filespec and config:\n        self.parse(filespec, config)\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/filter_data/#osm_fieldwork.filter_data.FilterData.parse","title":"parse","text":"<pre><code>parse(filespec, config)\n</code></pre> <p>Read in the XLSForm and extract the data we want.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The filespec to the XLSForm file</p> required <p>Returns:</p> Name Type Description <code>title</code> <code>str</code> <p>The title from the XLSForm Setting sheet</p> <code>extract</code> <code>str</code> <p>The data extract filename from the XLSForm Survey sheet</p> Source code in <code>osm_fieldwork/filter_data.py</code> <pre><code>def parse(\n    self,\n    filespec: str,\n    config: QueryConfig,\n):\n    \"\"\"Read in the XLSForm and extract the data we want.\n\n    Args:\n        filespec (str): The filespec to the XLSForm file\n\n    Returns:\n        title (str): The title from the XLSForm Setting sheet\n        extract (str): The data extract filename from the XLSForm Survey sheet\n    \"\"\"\n    if config:\n        self.qc = config\n    excel_object = pd.ExcelFile(filespec)\n    entries = excel_object.parse(sheet_name=[0, 1, 2], index_col=0, usercols=[0, 1, 2])\n    entries = pd.read_excel(filespec, sheet_name=[0, 1, 2])\n    title = entries[2][\"form_title\"].to_list()[0]\n    extract = \"\"\n    for entry in entries[0][\"type\"]:\n        if str(entry) == \"nan\":\n            continue\n        if entry[:20] == \"select_one_from_file\":\n            extract = entry[21:]\n            log.info(f'Got data extract filename: \"{extract}\", title: \"{title}\"')\n        else:\n            extract = \"none\"\n    total = len(entries[1][\"list_name\"])\n    index = 1\n    while index &lt; total:\n        key = entries[1][\"list_name\"][index]\n        if key == \"model\" or str(key) == \"nan\":\n            index += 1\n            continue\n        value = entries[1][\"name\"][index]\n        if value == \"&lt;text&gt;\" or str(value) == \"null\":\n            index += 1\n            continue\n        if key not in self.tags:\n            self.tags[key] = list()\n        self.tags[key].append(value)\n        index += 1\n\n    # The yaml config file for the query has a list of columns\n    # to keep in addition to this default set. These wind up\n    # in the SELECT\n    keep = (\n        \"name\",\n        \"name:en\",\n        \"id\",\n        \"operator\",\n        \"addr:street\",\n        \"addr:housenumber\",\n        \"osm_id\",\n        \"title\",\n        \"tags\",\n        \"label\",\n        \"landuse\",\n        \"opening_hours\",\n        \"tourism\",\n    )\n    self.keep = list(keep)\n    if \"keep\" in config.config[\"keep\"]:\n        self.keep.extend(config.config[\"keep\"])\n\n    return title, extract\n</code></pre>"},{"location":"api/filter_data/#osm_fieldwork.filter_data.FilterData.cleanData","title":"cleanData","text":"<pre><code>cleanData(data)\n</code></pre> <p>Filter out any data not in the data_model.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The input data or filespec to the input data file</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>The modifed data</p> Source code in <code>osm_fieldwork/filter_data.py</code> <pre><code>def cleanData(\n    self,\n    data,\n):\n    \"\"\"Filter out any data not in the data_model.\n\n    Args:\n        data (bytes): The input data or filespec to the input data file\n\n    Returns:\n        (FeatureCollection): The modifed data\n\n    \"\"\"\n    log.debug(\"Cleaning data...\")\n    if type(data) == str:\n        outfile = open(f\"new-{data}\", \"x\")\n        infile = open(tmpfile, \"r\")\n        indata = geojson.load(infile)\n    elif type(data) == bytes:\n        indata = eval(data.decode())\n    else:\n        indata = data\n    # these just create noise in the log file\n    ignore = (\n        \"timestamp\",\n        \"version\",\n        \"changeset\",\n    )\n    keep = (\"osm_id\", \"id\", \"version\")\n    collection = list()\n    for feature in indata[\"features\"]:\n        # log.debug(f\"FIXME0: {feature}\")\n        properties = dict()\n        for key, value in feature[\"properties\"].items():\n            # log.debug(f\"{key} = {value}\")\n            # FIXME: this is a hack!\n            if True:\n                if key == \"tags\":\n                    for k, v in value.items():\n                        if k[:4] == \"name\":\n                            properties[\"title\"] = value[k]\n                            properties[\"label\"] = value[k]\n                        else:\n                            properties[k] = v\n                else:\n                    if key == \"osm_id\":\n                        properties[\"id\"] = value\n                        properties[\"title\"] = value\n                        properties[\"label\"] = value\n                    else:\n                        properties[key] = value\n                        if key[:4] == \"name\":\n                            properties[\"title\"] = value\n                            properties[\"label\"] = value\n            else:\n                log.debug(f\"FIXME2: {key} = {value}\")\n                if key in keep:\n                    properties[key] = value\n                    continue\n                if key in self.tags:\n                    if key == \"name\" or key == \"name:en\":\n                        properties[\"title\"] = self.tags[key]\n                        properties[\"label\"] = self.tags[key]\n                    if value in self.tags[key]:\n                        properties[key] = value\n                    else:\n                        if value != \"yes\":\n                            log.warning(f\"Value {value} not in the data model!\")\n                        continue\n                else:\n                    if key in ignore:\n                        continue\n                    log.warning(f\"Tag {key} not in the data model!\")\n                    continue\n        if \"title\" not in properties:\n            properties[\"label\"] = properties[\"id\"]\n            properties[\"title\"] = properties[\"id\"]\n        newfeature = Feature(geometry=feature[\"geometry\"], properties=properties)\n        collection.append(newfeature)\n    if type(data) == str:\n        geojson.dump(FeatureCollection(collection), outfile)\n    return FeatureCollection(collection)\n</code></pre>"},{"location":"api/make_data_extract/","title":"make_data_extract.py","text":"<p>Get the categories and associated XLSFiles from the config file.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of the XLSForms included in osm-fieldwork</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def getChoices():\n    \"\"\"Get the categories and associated XLSFiles from the config file.\n\n    Returns:\n        (list): A list of the XLSForms included in osm-fieldwork\n    \"\"\"\n    data = dict()\n    if os.path.exists(f\"{data_models_path}/category.yaml\"):\n        file = open(f\"{data_models_path}/category.yaml\", \"r\").read()\n        contents = yaml.load(file, Loader=yaml.Loader)\n        for entry in contents:\n            [[k, v]] = entry.items()\n            data[k] = v[0]\n    return data\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>               Bases: <code>object</code></p> <p>Class to handle SQL queries for the categories.</p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> required <code>config</code> <code>str</code> <p>The filespec for the query config file</p> required <code>xlsfile</code> <code>str</code> <p>The filespec for the XLSForm file</p> required <p>Returns:</p> Type Description <code>MakeExtract</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def __init__(\n    self,\n    dburi: str,\n    config: str,\n    xlsfile: str,\n):\n    \"\"\"Initialize the postgres handler.\n\n    Args:\n        dburi (str): The URI string for the database connection\n        config (str): The filespec for the query config file\n        xlsfile (str): The filespec for the XLSForm file\n\n    Returns:\n        (MakeExtract): An instance of this object\n    \"\"\"\n    self.db = PostgresClient(dburi, f\"{data_models_path}/{config}.yaml\")\n\n    # Read in the XLSFile\n    if \"/\" in xlsfile:\n        file = open(xlsfile, \"rb\")\n    else:\n        file = open(f\"{xlsforms_path}/{xlsfile}\", \"rb\")\n    self.xls = BytesIO(file.read())\n    self.config = QueryConfig(config)\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/make_data_extract/#osm_fieldwork.make_data_extract.MakeExtract.getFeatures","title":"getFeatures","text":"<pre><code>getFeatures(boundary, polygon)\n</code></pre> <p>Extract features from Postgres.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>str</code> <p>The filespec for the project AOI in GeoJson format</p> required <code>filespec</code> <code>str</code> <p>The optional output file for the query</p> required <code>polygon</code> <code>bool</code> <p>Whether to have the full geometry or just centroids returns</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>The features returned from the query</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def getFeatures(\n    self,\n    boundary: FeatureCollection,\n    polygon: bool,\n):\n    \"\"\"Extract features from Postgres.\n\n    Args:\n        boundary (str): The filespec for the project AOI in GeoJson format\n        filespec (str): The optional output file for the query\n        polygon (bool): Whether to have the full geometry or just centroids returns\n\n    Returns:\n        (FeatureCollection): The features returned from the query\n    \"\"\"\n    log.info(\"Extracting features from Postgres...\")\n\n    if \"features\" in boundary:\n        poly = boundary[\"features\"][0][\"geometry\"]\n    else:\n        poly = boundary[\"geometry\"]\n    shape(poly)\n\n    collection = self.db.execQuery(boundary, None, False)\n    if not collection:\n        return None\n\n    return collection\n</code></pre>"},{"location":"api/make_data_extract/#osm_fieldwork.make_data_extract.MakeExtract.cleanFeatures","title":"cleanFeatures","text":"<pre><code>cleanFeatures(collection)\n</code></pre> <p>Filter out any data not in the data_model.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>bytes</code> <p>The input data or filespec to the input data file</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>The modifed data</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def cleanFeatures(\n    self,\n    collection: FeatureCollection,\n):\n    \"\"\"Filter out any data not in the data_model.\n\n    Args:\n        collection (bytes): The input data or filespec to the input data file\n\n    Returns:\n        (FeatureCollection): The modifed data\n\n    \"\"\"\n    log.debug(\"Cleaning features\")\n    cleaned = FilterData()\n    cleaned.parse(self.xls, self.config)\n    new = cleaned.cleanData(collection)\n    # jsonfile = open(filespec, \"w\")\n    # dump(new, jsonfile)\n    return new\n</code></pre>"},{"location":"api/odk2osm/","title":"odk2osm.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/odk2osm/#osm_fieldwork.odk2osm.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This is a program that reads in the ODK Instance file, which is in XML, and converts it to an OSM XML file so it can be viewed in an editor.</p> Source code in <code>osm_fieldwork/odk2osm.py</code> <pre><code>def main():\n    \"\"\"This is a program that reads in the ODK Instance file, which is in XML,\n    and converts it to an OSM XML file so it can be viewed in an editor.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Convert ODK XML instance file to OSM XML format\")\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-y\", \"--yaml\", help=\"Alternate YAML file\")\n    parser.add_argument(\"-x\", \"--xlsfile\", help=\"Source XLSFile\")\n    parser.add_argument(\"-i\", \"--infile\", required=True, help=\"The input file\")\n    # parser.add_argument(\"-o\",\"--outfile\", default='tmp.csv', help='The output file for JOSM')\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal\n    if args.verbose is not None:\n        logging.basicConfig(\n            level=logging.DEBUG,\n            format=(\"%(threadName)10s - %(name)s - %(levelname)s - %(message)s\"),\n            datefmt=\"%y-%m-%d %H:%M:%S\",\n            stream=sys.stdout,\n        )\n\n    toplevel = Path(args.infile)\n    odk = ODKParsers(args.yaml)\n    odk.parseXLS(args.xlsfile)\n    out = OutSupport()\n    xmlfiles = list()\n    data = list()\n    # It's a wildcard, used for XML instance files\n    if args.infile.find(\"*\") &gt;= 0:\n        log.debug(f\"Parsing multiple ODK XML files {args.infile}\")\n        toplevel = Path(args.infile[:-1])\n        for dirs in glob.glob(args.infile):\n            xml = os.listdir(dirs)\n            full = os.path.join(dirs, xml[0])\n            xmlfiles.append(full)\n        for infile in xmlfiles:\n            tmp = odk.XMLparser(infile)\n            entry = odk.createEntry(tmp[0])\n            data.append(entry)\n    elif toplevel.suffix == \".xml\":\n        # It's an instance file from ODK Collect\n        log.debug(f\"Parsing ODK XML files {args.infile}\")\n        # There is always only one XML file per infile\n        full = os.path.join(toplevel, os.path.basename(toplevel))\n        xmlfiles.append(full + \".xml\")\n        tmp = odk.XMLparser(args.infile)\n        # odki = ODKInstance(filespec=args.infile, yaml=args.yaml)\n        entry = odk.createEntry(tmp)\n        data.append(entry)\n    elif toplevel.suffix == \".csv\":\n        log.debug(f\"Parsing csv files {args.infile}\")\n        for entry in odk.CSVparser(args.infile):\n            data.append(odk.createEntry(entry))\n    elif toplevel.suffix == \".json\":\n        log.debug(f\"Parsing json files {args.infile}\")\n        for entry in odk.JSONparser(args.infile):\n            data.append(odk.createEntry(entry))\n\n    # Write the data\n    out.WriteData(toplevel.stem, data)\n</code></pre>"},{"location":"api/osmfile/","title":"osmfile.py","text":"<p>               Bases: <code>object</code></p> <p>OSM File output.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The input or output file</p> <code>None</code> <code>options</code> <code>dict</code> <p>Command line options</p> <code>None</code> <code>outdir</code> <code>str</code> <p>The output directory for the file</p> <code>'/tmp/'</code> <p>Returns:</p> Type Description <code>OsmFile</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def __init__(\n    self,\n    filespec: str = None,\n    options: dict = None,\n    outdir: str = \"/tmp/\",\n):\n    \"\"\"This class reads and writes the OSM XML formated files.\n\n    Args:\n        filespec (str): The input or output file\n        options (dict): Command line options\n        outdir (str): The output directory for the file\n\n    Returns:\n        (OsmFile): An instance of this object\n    \"\"\"\n    if options is None:\n        options = dict()\n    self.options = options\n    # Read the config file to get our OSM credentials, if we have any\n    # self.config = config.config(self.options)\n    self.version = 3\n    self.visible = \"true\"\n    self.osmid = -1\n    # Open the OSM output file\n    self.file = None\n    if filespec is not None:\n        self.file = open(filespec, \"w\")\n        # self.file = open(filespec + \".osm\", 'w')\n        logging.info(\"Opened output file: \" + filespec)\n    self.header()\n    # logging.error(\"Couldn't open %s for writing!\" % filespec)\n\n    # This is the file that contains all the filtering data\n    # self.ctable = convfile(self.options.get('convfile'))\n    # self.options['convfile'] = None\n    # These are for importing the CO addresses\n    self.full = None\n    self.addr = None\n    # decrement the ID\n    self.start = -1\n    # path = xlsforms_path.replace(\"xlsforms\", \"\")\n    self.convert = Convert()\n    self.data = list()\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.isclosed","title":"isclosed","text":"<pre><code>isclosed()\n</code></pre> <p>Is the OSM XML file open or closed ?</p> <p>Returns:</p> Type Description <code>bool</code> <p>The OSM XML file status</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def isclosed(self):\n    \"\"\"Is the OSM XML file open or closed ?\n\n    Returns:\n        (bool): The OSM XML file status\n    \"\"\"\n    return self.file.closed\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.header","title":"header","text":"<pre><code>header()\n</code></pre> <p>Write the header of the OSM XML file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def header(self):\n    \"\"\"Write the header of the OSM XML file.\"\"\"\n    if self.file is not None:\n        self.file.write(\"&lt;?xml version='1.0' encoding='UTF-8'?&gt;\\n\")\n        # self.file.write('&lt;osm version=\"0.6\" generator=\"osm-fieldowrk 0.3\" timestamp=\"2017-03-13T21:43:02Z\"&gt;\\n')\n        self.file.write('&lt;osm version=\"0.6\" generator=\"osm-fieldwork 0.3\"&gt;\\n')\n        self.file.flush()\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.footer","title":"footer","text":"<pre><code>footer()\n</code></pre> <p>Write the footer of the OSM XML file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def footer(self):\n    \"\"\"Write the footer of the OSM XML file.\"\"\"\n    # logging.debug(\"FIXME: %r\" % self.file)\n    if self.file is not None:\n        self.file.write(\"&lt;/osm&gt;\\n\")\n        self.file.flush()\n        if self.file is False:\n            self.file.close()\n    self.file = None\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.write","title":"write","text":"<pre><code>write(data=None)\n</code></pre> <p>Write the data to the OSM XML file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def write(\n    self,\n    data=None,\n):\n    \"\"\"Write the data to the OSM XML file.\"\"\"\n    if type(data) == list:\n        if data is not None:\n            for line in data:\n                self.file.write(\"%s\\n\" % line)\n    else:\n        self.file.write(\"%s\\n\" % data)\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.createWay","title":"createWay","text":"<pre><code>createWay(way, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node.</p> <p>Parameters:</p> Name Type Description Default <code>way</code> <code>dict</code> <p>The input way data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def createWay(\n    self,\n    way: dict,\n    modified: bool = False,\n):\n    \"\"\"This creates a string that is the OSM representation of a node.\n\n    Args:\n        way (dict): The input way data structure\n        modified (bool): Is this a modified feature ?\n\n    Returns:\n        (str): The OSM XML entry\n    \"\"\"\n    attrs = dict()\n    osm = \"\"\n\n    # Add default attributes\n    if modified:\n        attrs[\"action\"] = \"modify\"\n    if \"osm_way_id\" in way[\"attrs\"]:\n        attrs[\"id\"] = int(way[\"attrs\"][\"osm_way_id\"])\n    elif \"osm_id\" in way[\"attrs\"]:\n        attrs[\"id\"] = int(way[\"attrs\"][\"osm_id\"])\n    elif \"id\" in way[\"attrs\"]:\n        attrs[\"id\"] = int(way[\"attrs\"][\"id\"])\n    else:\n        attrs[\"id\"] = self.start\n        self.start -= 1\n    if \"version\" not in way[\"attrs\"]:\n        attrs[\"version\"] = 1\n    else:\n        attrs[\"version\"] = way[\"attrs\"][\"version\"]\n    attrs[\"timestamp\"] = datetime.now().strftime(\"%Y-%m-%dT%TZ\")\n    # If the resulting file is publicly accessible without authentication, The GDPR applies\n    # and the identifying fields should not be included\n    if \"uid\" in way[\"attrs\"]:\n        attrs[\"uid\"] = way[\"attrs\"][\"uid\"]\n    if \"user\" in way[\"attrs\"]:\n        attrs[\"user\"] = way[\"attrs\"][\"user\"]\n\n    # Make all the nodes first. The data in the track has 4 fields. The first two\n    # are the lat/lon, then the altitude, and finally the GPS accuracy.\n    # newrefs = list()\n    node = dict()\n    node[\"attrs\"] = dict()\n    # The geometry is an EWKT string, so there is no need to get fancy with\n    # geometries, just manipulate the string, as OSM XML it's only strings\n    # anyway.\n    # geom = way['geom'][19:][:-2]\n    # print(geom)\n    # points = geom.split(\",\")\n    # print(points)\n\n    # epdb.st()\n    # loop = 0\n    # while loop &lt; len(way['refs']):\n    #     #print(f\"{points[loop]} {way['refs'][loop]}\")\n    #     node['timestamp'] = attrs['timestamp']\n    #     if 'user' in attrs and attrs['user'] is not None:\n    #         node['attrs']['user'] = attrs['user']\n    #     if 'uid' in attrs and attrs['uid'] is not None:\n    #         node['attrs']['uid'] = attrs['uid']\n    #     node['version'] = 0\n    #     lat,lon = points[loop].split(' ')\n    #     node['attrs']['lat'] = lat\n    #     node['attrs']['lon'] = lon\n    #     node['attrs']['id'] = way['refs'][loop]\n    #     osm += self.createNode(node) + '\\n'\n    #     loop += 1\n\n    # Processs atrributes\n    line = \"\"\n    for ref, value in attrs.items():\n        line += \"%s=%r \" % (ref, str(value))\n    osm += \"  &lt;way \" + line + \"&gt;\"\n\n    if \"refs\" in way:\n        for ref in way[\"refs\"]:\n            osm += '\\n    &lt;nd ref=\"%s\"/&gt;' % ref\n    if \"tags\" in way:\n        for key, value in way[\"tags\"].items():\n            if value is None:\n                continue\n            if key == \"track\":\n                continue\n            if key not in attrs:\n                newkey = escape(key)\n                newval = escape(str(value))\n                osm += f\"\\n    &lt;tag k='{newkey}' v='{newval}'/&gt;\"\n        if modified:\n            osm += '\\n    &lt;tag k=\"note\" v=\"Do not upload this without validation!\"/&gt;'\n        osm += \"\\n\"\n    osm += \"  &lt;/way&gt;\\n\"\n\n    return osm\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.featureToNode","title":"featureToNode","text":"<pre><code>featureToNode(feature)\n</code></pre> <p>Convert a GeoJson feature into the data structures used here.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>dict</code> <p>The GeoJson feature to convert</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data structure used by this file</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def featureToNode(\n    self,\n    feature: dict,\n):\n    \"\"\"Convert a GeoJson feature into the data structures used here.\n\n    Args:\n        feature (dict): The GeoJson feature to convert\n\n    Returns:\n        (dict): The data structure used by this file\n    \"\"\"\n    osm = dict()\n    ignore = (\"label\", \"title\")\n    tags = dict()\n    attrs = dict()\n    for tag, value in feature[\"properties\"].items():\n        if tag == \"id\":\n            attrs[\"osm_id\"] = value\n        elif tag not in ignore:\n            tags[tag] = value\n    coords = feature[\"geometry\"][\"coordinates\"]\n    attrs[\"lat\"] = coords[1]\n    attrs[\"lon\"] = coords[0]\n    osm[\"attrs\"] = attrs\n    osm[\"tags\"] = tags\n    return osm\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.createNode","title":"createNode","text":"<pre><code>createNode(node, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>dict</code> <p>The input node data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def createNode(\n    self,\n    node: dict,\n    modified: bool = False,\n):\n    \"\"\"This creates a string that is the OSM representation of a node.\n\n    Args:\n        node (dict): The input node data structure\n        modified (bool): Is this a modified feature ?\n\n    Returns:\n        (str): The OSM XML entry\n    \"\"\"\n    attrs = dict()\n    # Add default attributes\n    if modified:\n        attrs[\"action\"] = \"modify\"\n\n    if \"id\" in node[\"attrs\"]:\n        attrs[\"id\"] = int(node[\"attrs\"][\"id\"])\n    else:\n        attrs[\"id\"] = self.start\n        self.start -= 1\n    if \"version\" not in node[\"attrs\"]:\n        attrs[\"version\"] = \"1\"\n    else:\n        attrs[\"version\"] = int(node[\"attrs\"][\"version\"]) + 1\n    attrs[\"lat\"] = node[\"attrs\"][\"lat\"]\n    attrs[\"lon\"] = node[\"attrs\"][\"lon\"]\n    attrs[\"timestamp\"] = datetime.now().strftime(\"%Y-%m-%dT%TZ\")\n    # If the resulting file is publicly accessible without authentication, THE GDPR applies\n    # and the identifying fields should not be included\n    if \"uid\" in node[\"attrs\"]:\n        attrs[\"uid\"] = node[\"attrs\"][\"uid\"]\n    if \"user\" in node[\"attrs\"]:\n        attrs[\"user\"] = node[\"attrs\"][\"user\"]\n\n    # Processs atrributes\n    line = \"\"\n    osm = \"\"\n    for ref, value in attrs.items():\n        line += \"%s=%r \" % (ref, str(value))\n    osm += \"  &lt;node \" + line\n\n    if \"tags\" in node:\n        osm += \"&gt;\"\n        for key, value in node[\"tags\"].items():\n            if not value:\n                continue\n            if key not in attrs:\n                newkey = escape(key)\n                newval = escape(str(value))\n                osm += f\"\\n    &lt;tag k='{newkey}' v='{newval}'/&gt;\"\n        osm += \"\\n  &lt;/node&gt;\\n\"\n    else:\n        osm += \"/&gt;\"\n\n    return osm\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.createTag","title":"createTag","text":"<pre><code>createTag(field, value)\n</code></pre> <p>Create a data structure for an OSM feature tag.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The tag name</p> required <code>value</code> <code>str</code> <p>The value for the tag</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The newly created tag pair</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def createTag(\n    self,\n    field: str,\n    value: str,\n):\n    \"\"\"Create a data structure for an OSM feature tag.\n\n    Args:\n        field (str): The tag name\n        value (str): The value for the tag\n\n    Returns:\n        (dict): The newly created tag pair\n    \"\"\"\n    newval = str(value)\n    newval = newval.replace(\"&amp;\", \"and\")\n    newval = newval.replace('\"', \"\")\n    tag = dict()\n    # logging.debug(\"OSM:makeTag(field=%r, value=%r)\" % (field, newval))\n\n    newtag = field\n    change = newval.split(\"=\")\n    if len(change) &gt; 1:\n        newtag = change[0]\n        newval = change[1]\n\n    tag[newtag] = newval\n    return tag\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.loadFile","title":"loadFile","text":"<pre><code>loadFile(osmfile)\n</code></pre> <p>Read a OSM XML file generated by osm_fieldwork.</p> <p>Parameters:</p> Name Type Description Default <code>osmfile</code> <code>str</code> <p>The OSM XML file to load</p> required <p>Returns:</p> Type Description <code>list</code> <p>The entries in the OSM XML file</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def loadFile(\n    self,\n    osmfile: str,\n):\n    \"\"\"Read a OSM XML file generated by osm_fieldwork.\n\n    Args:\n        osmfile (str): The OSM XML file to load\n\n    Returns:\n        (list): The entries in the OSM XML file\n    \"\"\"\n    size = os.path.getsize(osmfile)\n    with open(osmfile, \"r\") as file:\n        xml = file.read(size)\n        doc = xmltodict.parse(xml)\n        if \"osm\" not in doc:\n            logging.warning(\"No data in this instance\")\n            return False\n        data = doc[\"osm\"]\n        if \"node\" not in data:\n            logging.warning(\"No nodes in this instance\")\n            return False\n\n    for node in data[\"node\"]:\n        attrs = {\n            \"id\": int(node[\"@id\"]),\n            \"lat\": node[\"@lat\"][:10],\n            \"lon\": node[\"@lon\"][:10],\n        }\n        if \"@timestamp\" in node:\n            attrs[\"timestamp\"] = node[\"@timestamp\"]\n\n        tags = dict()\n        if \"tag\" in node:\n            for tag in node[\"tag\"]:\n                if type(tag) == dict:\n                    tags[tag[\"@k\"]] = tag[\"@v\"].strip()\n                    # continue\n                else:\n                    tags[node[\"tag\"][\"@k\"]] = node[\"tag\"][\"@v\"].strip()\n                # continue\n        node = {\"attrs\": attrs, \"tags\": tags}\n        self.data.append(node)\n\n    for way in data[\"way\"]:\n        attrs = {\n            \"id\": int(way[\"@id\"]),\n        }\n        refs = list()\n        if len(way[\"nd\"]) &gt; 0:\n            for ref in way[\"nd\"]:\n                refs.append(int(ref[\"@ref\"]))\n\n        if \"@timestamp\" in node:\n            attrs[\"timestamp\"] = node[\"@timestamp\"]\n\n        tags = dict()\n        if \"tag\" in way:\n            for tag in way[\"tag\"]:\n                if type(tag) == dict:\n                    tags[tag[\"@k\"]] = tag[\"@v\"].strip()\n                    # continue\n                else:\n                    if len(node[\"tags\"]) &gt; 0:\n                        tags[node[\"tags\"][\"@k\"]] = node[\"tags\"][\"@v\"].strip()\n                # continue\n        way = {\"attrs\": attrs, \"refs\": refs, \"tags\": tags}\n        self.data.append(way)\n\n    return self.data\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    for _id, item in self.data.items():\n        for k, v in item[\"attrs\"].items():\n            print(f\"{k} = {v}\")\n        for k, v in item[\"tags\"].items():\n            print(f\"\\t{k} = {v}\")\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.getFeature","title":"getFeature","text":"<pre><code>getFeature(id)\n</code></pre> <p>Get the data for a feature from the loaded OSM data file.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID to retrieve the feasture of</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The feature for this ID or None</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def getFeature(\n    self,\n    id: int,\n):\n    \"\"\"Get the data for a feature from the loaded OSM data file.\n\n    Args:\n        id (int): The ID to retrieve the feasture of\n\n    Returns:\n        (dict): The feature for this ID or None\n    \"\"\"\n    return self.data[id]\n</code></pre>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.getFields","title":"getFields","text":"<pre><code>getFields()\n</code></pre> <p>Extract all the tags used in this file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def getFields(self):\n    \"\"\"Extract all the tags used in this file.\"\"\"\n    fields = list()\n    for _id, item in self.data.items():\n        keys = list(item[\"tags\"].keys())\n        for key in keys:\n            if key not in fields:\n                fields.append(key)\n</code></pre>"},{"location":"api/parsers/","title":"OdkParsers","text":"<p>               Bases: <code>Convert</code></p> <p>A class to parse the CSV files from ODK Central.</p> Source code in <code>osm_fieldwork/parsers.py</code> <pre><code>def __init__(\n    self,\n    yaml: str = None,\n):\n    self.fields = dict()\n    self.nodesets = dict()\n    self.data = list()\n    self.osm = None\n    self.json = None\n    self.features = list()\n    xlsforms_path.replace(\"xlsforms\", \"\")\n    if yaml:\n        pass\n    else:\n        pass\n    self.config = super().__init__(yaml)\n    self.saved = dict()\n    self.defaults = dict()\n    self.entries = dict()\n    self.types = dict()\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/parsers/#osm_fieldwork.parsers.ODKParsers.CSVparser","title":"CSVparser","text":"<pre><code>CSVparser(filespec, data=None)\n</code></pre> <p>Parse the CSV file from ODK Central and convert it to a data structure.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The file to parse.</p> required <code>data</code> <code>str</code> <p>Or the data to parse.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>The list of features with tags</p> Source code in <code>osm_fieldwork/parsers.py</code> <pre><code>def CSVparser(\n    self,\n    filespec: str,\n    data: str = None,\n) -&gt; list:\n    \"\"\"Parse the CSV file from ODK Central and convert it to a data structure.\n\n    Args:\n        filespec (str): The file to parse.\n        data (str): Or the data to parse.\n\n    Returns:\n        (list): The list of features with tags\n    \"\"\"\n    all_tags = list()\n    if not data:\n        f = open(filespec, newline=\"\")\n        reader = csv.DictReader(f, delimiter=\",\")\n    else:\n        reader = csv.DictReader(data, delimiter=\",\")\n    for row in reader:\n        tags = dict()\n        # log.info(f\"ROW: {row}\")\n        for keyword, value in row.items():\n            if keyword is None or value is None:\n                continue\n            if len(value) == 0:\n                continue\n            base = basename(keyword).lower()\n            # There's many extraneous fields in the input file which we don't need.\n            if base is None or base in self.ignore or value is None:\n                continue\n            else:\n                # log.info(f\"ITEM: {keyword} = {value}\")\n                if base in self.types:\n                    if self.types[base] == \"select_multiple\":\n                        vals = self.convertMultiple(value)\n                        if len(vals) &gt; 0:\n                            tags.update(vals)\n                        continue\n                # When using geopoint warmup, once the display changes to the map\n\n                # location, there is not always a value if the accuracy is way\n                # off. In this case use the warmup value, which is where we are\n                # hopefully standing anyway.\n                if base == \"latitude\" and len(value) == 0:\n                    if \"warmup-Latitude\" in row:\n                        value = row[\"warmup-Latitude\"]\n                        if base == \"longitude\" and len(value) == 0:\n                            value = row[\"warmup-Longitude\"]\n                items = self.convertEntry(base, value)\n                # log.info(f\"ROW: {base} {value}\")\n                if len(items) &gt; 0:\n                    if base in self.saved:\n                        if str(value) == \"nan\" or len(value) == 0:\n                            # log.debug(f\"FIXME: {base} {value}\")\n                            val = self.saved[base]\n                            if val and len(value) == 0:\n                                log.warning(f'Using last saved value for \"{base}\"! Now \"{val}\"')\n                                value = val\n                        else:\n                            self.saved[base] = value\n                            log.debug(f'Updating last saved value for \"{base}\" with \"{value}\"')\n                    # Handle nested dict in list\n                    if isinstance(items, list):\n                        items = items[0]\n                    for k, v in items.items():\n                        tags[k] = v\n                else:\n                    tags[base] = value\n        # log.debug(f\"\\tFIXME1: {tags}\")\n        all_tags.append(tags)\n    return all_tags\n</code></pre>"},{"location":"api/parsers/#osm_fieldwork.parsers.ODKParsers.JSONparser","title":"JSONparser","text":"<pre><code>JSONparser(filespec=None, data=None)\n</code></pre> <p>Parse the JSON file from ODK Central and convert it to a data structure. The input is either a filespec to open, or the data itself.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The JSON or GeoJson input file to convert</p> <code>None</code> <code>data</code> <code>str</code> <p>The data to convert</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of all the features in the input file</p> Source code in <code>osm_fieldwork/parsers.py</code> <pre><code>def JSONparser(\n    self,\n    filespec: str = None,\n    data: str = None,\n) -&gt; list:\n    \"\"\"Parse the JSON file from ODK Central and convert it to a data structure.\n    The input is either a filespec to open, or the data itself.\n\n    Args:\n        filespec (str): The JSON or GeoJson input file to convert\n        data (str): The data to convert\n\n    Returns:\n        (list): A list of all the features in the input file\n    \"\"\"\n    log.debug(f\"Parsing JSON file {filespec}\")\n    total = list()\n    if not data:\n        file = open(filespec, \"r\")\n        infile = Path(filespec)\n        if infile.suffix == \".geojson\":\n            reader = geojson.load(file)\n        elif infile.suffix == \".json\":\n            reader = json.load(file)\n        else:\n            log.error(\"Need to specify a JSON or GeoJson file!\")\n            return total\n    elif isinstance(data, str):\n        reader = geojson.loads(data)\n    elif isinstance(data, list):\n        reader = data\n\n    # JSON files from Central use value as the keyword, whereas\n    # GeoJSON uses features for the same thing.\n    if \"value\" in reader:\n        data = reader[\"value\"]\n    elif \"features\" in reader:\n        data = reader[\"features\"]\n    else:\n        data = reader\n    for row in data:\n        # log.debug(f\"ROW: {row}\\n\")\n        tags = dict()\n        if \"properties\" in row:\n            row[\"properties\"]  # A GeoJson formatted file\n        else:\n            pass  # A JOSM file from ODK Central\n\n        # flatten all the groups into a sodk2geojson.pyingle data structure\n        flattened = flatdict.FlatDict(row)\n        # log.debug(f\"FLAT: {flattened}\\n\")\n        for k, v in flattened.items():\n            last = k.rfind(\":\") + 1\n            key = k[last:]\n            # a JSON file from ODK Central always uses coordinates as\n            # the keyword\n            if key is None or key in self.ignore or v is None:\n                continue\n            # log.debug(f\"Processing tag {key} = {v}\")\n            if key == \"coordinates\":\n                if isinstance(v, list):\n                    tags[\"lat\"] = v[1]\n                    tags[\"lon\"] = v[0]\n                    # poi = Point(float(lon), float(lat))\n                    # tags[\"geometry\"] = poi\n                continue\n\n            if key in self.types:\n                if self.types[key] == \"select_multiple\":\n                    # log.debug(f\"Found key '{self.types[key]}'\")\n                    if v is None:\n                        continue\n                    vals = self.convertMultiple(v)\n                    if len(vals) &gt; 0:\n                        tags.update(vals)\n                    continue\n            items = self.convertEntry(key, v)\n            if items is None or len(items) == 0:\n                continue\n\n            if type(items) == str:\n                log.debug(f\"string Item {items}\")\n            elif type(items) == list:\n                # log.debug(f\"list Item {items}\")\n                tags.update(items[0])\n            elif type(items) == dict:\n                # log.debug(f\"dict Item {items}\")\n                tags.update(items)\n        # log.debug(f\"TAGS: {tags}\")\n        if len(tags) &gt; 0:\n            total.append(tags)\n\n    # log.debug(f\"Finished parsing JSON file {filespec}\")\n    return total\n</code></pre>"},{"location":"api/parsers/#osm_fieldwork.parsers.ODKParsers.XMLparser","title":"XMLparser","text":"<pre><code>XMLparser(filespec, data=None)\n</code></pre> <p>Import an ODK XML Instance file ito a data structure. The input is either a filespec to the Instance file copied off your phone, or the XML that has been read in elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The filespec to the ODK XML Instance file</p> required <code>data</code> <code>str</code> <p>The XML data</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>All the entries in the OSM XML Instance file</p> Source code in <code>osm_fieldwork/parsers.py</code> <pre><code>def XMLparser(\n    self,\n    filespec: str,\n    data: str = None,\n) -&gt; list:\n    \"\"\"Import an ODK XML Instance file ito a data structure. The input is\n    either a filespec to the Instance file copied off your phone, or\n    the XML that has been read in elsewhere.\n\n    Args:\n        filespec (str): The filespec to the ODK XML Instance file\n        data (str): The XML data\n\n    Returns:\n        (list): All the entries in the OSM XML Instance file\n    \"\"\"\n    row = dict()\n    if filespec:\n        logging.info(\"Processing instance file: %s\" % filespec)\n        file = open(filespec, \"rb\")\n        # Instances are small, read the whole file\n        xml = file.read(os.path.getsize(filespec))\n    elif data:\n        xml = data\n    doc = xmltodict.parse(xml)\n\n    json.dumps(doc)\n    tags = dict()\n    data = doc[\"data\"]\n    flattened = flatdict.FlatDict(data)\n    # total = list()\n    # log.debug(f\"FLAT: {flattened}\")\n    pat = re.compile(\"[0-9.]* [0-9.-]* [0-9.]* [0-9.]*\")\n    for key, value in flattened.items():\n        if key[0] == \"@\" or value is None:\n            continue\n        # Get the last element deliminated by a dash\n        # for CSV &amp; JSON, or a colon for ODK XML.\n        base = basename(key)\n        log.debug(f\"FLAT: {base} = {value}\")\n        if base in self.ignore:\n            continue\n        if re.search(pat, value):\n            gps = value.split(\" \")\n            row[\"lat\"] = gps[0]\n            row[\"lon\"] = gps[1]\n            continue\n\n        if base in self.types:\n            if self.types[base] == \"select_multiple\":\n                # log.debug(f\"Found key '{self.types[base]}'\")\n                vals = self.convertMultiple(value)\n                if len(vals) &gt; 0:\n                    tags.update(vals)\n                continue\n            else:\n                item = self.convertEntry(base, value)\n                if item is None or len(item) == 0:\n                    continue\n                if len(tags) == 0:\n                    tags = item[0]\n                else:\n                    if type(item) == list:\n                        # log.debug(f\"list Item {item}\")\n                        tags.update(item[0])\n                    elif type(item) == dict:\n                        # log.debug(f\"dict Item {item}\")\n                        tags.update(item)\n    row.update(tags)\n    return [row]\n</code></pre>"},{"location":"api/sqlite/","title":"osmfile.py","text":"<p>               Bases: <code>object</code></p> <p>OSM File output.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The input or output file</p> <code>None</code> <code>options</code> <code>dict</code> <p>Command line options</p> <code>None</code> <code>outdir</code> <code>str</code> <p>The output directory for the file</p> <code>'/tmp/'</code> <p>Returns:</p> Type Description <code>OsmFile</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def __init__(\n    self,\n    filespec: str = None,\n    options: dict = None,\n    outdir: str = \"/tmp/\",\n):\n    \"\"\"This class reads and writes the OSM XML formated files.\n\n    Args:\n        filespec (str): The input or output file\n        options (dict): Command line options\n        outdir (str): The output directory for the file\n\n    Returns:\n        (OsmFile): An instance of this object\n    \"\"\"\n    if options is None:\n        options = dict()\n    self.options = options\n    # Read the config file to get our OSM credentials, if we have any\n    # self.config = config.config(self.options)\n    self.version = 3\n    self.visible = \"true\"\n    self.osmid = -1\n    # Open the OSM output file\n    self.file = None\n    if filespec is not None:\n        self.file = open(filespec, \"w\")\n        # self.file = open(filespec + \".osm\", 'w')\n        logging.info(\"Opened output file: \" + filespec)\n    self.header()\n    # logging.error(\"Couldn't open %s for writing!\" % filespec)\n\n    # This is the file that contains all the filtering data\n    # self.ctable = convfile(self.options.get('convfile'))\n    # self.options['convfile'] = None\n    # These are for importing the CO addresses\n    self.full = None\n    self.addr = None\n    # decrement the ID\n    self.start = -1\n    # path = xlsforms_path.replace(\"xlsforms\", \"\")\n    self.convert = Convert()\n    self.data = list()\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.isclosed","title":"isclosed","text":"<pre><code>isclosed()\n</code></pre> <p>Is the OSM XML file open or closed ?</p> <p>Returns:</p> Type Description <code>bool</code> <p>The OSM XML file status</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def isclosed(self):\n    \"\"\"Is the OSM XML file open or closed ?\n\n    Returns:\n        (bool): The OSM XML file status\n    \"\"\"\n    return self.file.closed\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.header","title":"header","text":"<pre><code>header()\n</code></pre> <p>Write the header of the OSM XML file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def header(self):\n    \"\"\"Write the header of the OSM XML file.\"\"\"\n    if self.file is not None:\n        self.file.write(\"&lt;?xml version='1.0' encoding='UTF-8'?&gt;\\n\")\n        # self.file.write('&lt;osm version=\"0.6\" generator=\"osm-fieldowrk 0.3\" timestamp=\"2017-03-13T21:43:02Z\"&gt;\\n')\n        self.file.write('&lt;osm version=\"0.6\" generator=\"osm-fieldwork 0.3\"&gt;\\n')\n        self.file.flush()\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.footer","title":"footer","text":"<pre><code>footer()\n</code></pre> <p>Write the footer of the OSM XML file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def footer(self):\n    \"\"\"Write the footer of the OSM XML file.\"\"\"\n    # logging.debug(\"FIXME: %r\" % self.file)\n    if self.file is not None:\n        self.file.write(\"&lt;/osm&gt;\\n\")\n        self.file.flush()\n        if self.file is False:\n            self.file.close()\n    self.file = None\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.write","title":"write","text":"<pre><code>write(data=None)\n</code></pre> <p>Write the data to the OSM XML file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def write(\n    self,\n    data=None,\n):\n    \"\"\"Write the data to the OSM XML file.\"\"\"\n    if type(data) == list:\n        if data is not None:\n            for line in data:\n                self.file.write(\"%s\\n\" % line)\n    else:\n        self.file.write(\"%s\\n\" % data)\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.createWay","title":"createWay","text":"<pre><code>createWay(way, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node.</p> <p>Parameters:</p> Name Type Description Default <code>way</code> <code>dict</code> <p>The input way data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def createWay(\n    self,\n    way: dict,\n    modified: bool = False,\n):\n    \"\"\"This creates a string that is the OSM representation of a node.\n\n    Args:\n        way (dict): The input way data structure\n        modified (bool): Is this a modified feature ?\n\n    Returns:\n        (str): The OSM XML entry\n    \"\"\"\n    attrs = dict()\n    osm = \"\"\n\n    # Add default attributes\n    if modified:\n        attrs[\"action\"] = \"modify\"\n    if \"osm_way_id\" in way[\"attrs\"]:\n        attrs[\"id\"] = int(way[\"attrs\"][\"osm_way_id\"])\n    elif \"osm_id\" in way[\"attrs\"]:\n        attrs[\"id\"] = int(way[\"attrs\"][\"osm_id\"])\n    elif \"id\" in way[\"attrs\"]:\n        attrs[\"id\"] = int(way[\"attrs\"][\"id\"])\n    else:\n        attrs[\"id\"] = self.start\n        self.start -= 1\n    if \"version\" not in way[\"attrs\"]:\n        attrs[\"version\"] = 1\n    else:\n        attrs[\"version\"] = way[\"attrs\"][\"version\"]\n    attrs[\"timestamp\"] = datetime.now().strftime(\"%Y-%m-%dT%TZ\")\n    # If the resulting file is publicly accessible without authentication, The GDPR applies\n    # and the identifying fields should not be included\n    if \"uid\" in way[\"attrs\"]:\n        attrs[\"uid\"] = way[\"attrs\"][\"uid\"]\n    if \"user\" in way[\"attrs\"]:\n        attrs[\"user\"] = way[\"attrs\"][\"user\"]\n\n    # Make all the nodes first. The data in the track has 4 fields. The first two\n    # are the lat/lon, then the altitude, and finally the GPS accuracy.\n    # newrefs = list()\n    node = dict()\n    node[\"attrs\"] = dict()\n    # The geometry is an EWKT string, so there is no need to get fancy with\n    # geometries, just manipulate the string, as OSM XML it's only strings\n    # anyway.\n    # geom = way['geom'][19:][:-2]\n    # print(geom)\n    # points = geom.split(\",\")\n    # print(points)\n\n    # epdb.st()\n    # loop = 0\n    # while loop &lt; len(way['refs']):\n    #     #print(f\"{points[loop]} {way['refs'][loop]}\")\n    #     node['timestamp'] = attrs['timestamp']\n    #     if 'user' in attrs and attrs['user'] is not None:\n    #         node['attrs']['user'] = attrs['user']\n    #     if 'uid' in attrs and attrs['uid'] is not None:\n    #         node['attrs']['uid'] = attrs['uid']\n    #     node['version'] = 0\n    #     lat,lon = points[loop].split(' ')\n    #     node['attrs']['lat'] = lat\n    #     node['attrs']['lon'] = lon\n    #     node['attrs']['id'] = way['refs'][loop]\n    #     osm += self.createNode(node) + '\\n'\n    #     loop += 1\n\n    # Processs atrributes\n    line = \"\"\n    for ref, value in attrs.items():\n        line += \"%s=%r \" % (ref, str(value))\n    osm += \"  &lt;way \" + line + \"&gt;\"\n\n    if \"refs\" in way:\n        for ref in way[\"refs\"]:\n            osm += '\\n    &lt;nd ref=\"%s\"/&gt;' % ref\n    if \"tags\" in way:\n        for key, value in way[\"tags\"].items():\n            if value is None:\n                continue\n            if key == \"track\":\n                continue\n            if key not in attrs:\n                newkey = escape(key)\n                newval = escape(str(value))\n                osm += f\"\\n    &lt;tag k='{newkey}' v='{newval}'/&gt;\"\n        if modified:\n            osm += '\\n    &lt;tag k=\"note\" v=\"Do not upload this without validation!\"/&gt;'\n        osm += \"\\n\"\n    osm += \"  &lt;/way&gt;\\n\"\n\n    return osm\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.featureToNode","title":"featureToNode","text":"<pre><code>featureToNode(feature)\n</code></pre> <p>Convert a GeoJson feature into the data structures used here.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>dict</code> <p>The GeoJson feature to convert</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data structure used by this file</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def featureToNode(\n    self,\n    feature: dict,\n):\n    \"\"\"Convert a GeoJson feature into the data structures used here.\n\n    Args:\n        feature (dict): The GeoJson feature to convert\n\n    Returns:\n        (dict): The data structure used by this file\n    \"\"\"\n    osm = dict()\n    ignore = (\"label\", \"title\")\n    tags = dict()\n    attrs = dict()\n    for tag, value in feature[\"properties\"].items():\n        if tag == \"id\":\n            attrs[\"osm_id\"] = value\n        elif tag not in ignore:\n            tags[tag] = value\n    coords = feature[\"geometry\"][\"coordinates\"]\n    attrs[\"lat\"] = coords[1]\n    attrs[\"lon\"] = coords[0]\n    osm[\"attrs\"] = attrs\n    osm[\"tags\"] = tags\n    return osm\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.createNode","title":"createNode","text":"<pre><code>createNode(node, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>dict</code> <p>The input node data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def createNode(\n    self,\n    node: dict,\n    modified: bool = False,\n):\n    \"\"\"This creates a string that is the OSM representation of a node.\n\n    Args:\n        node (dict): The input node data structure\n        modified (bool): Is this a modified feature ?\n\n    Returns:\n        (str): The OSM XML entry\n    \"\"\"\n    attrs = dict()\n    # Add default attributes\n    if modified:\n        attrs[\"action\"] = \"modify\"\n\n    if \"id\" in node[\"attrs\"]:\n        attrs[\"id\"] = int(node[\"attrs\"][\"id\"])\n    else:\n        attrs[\"id\"] = self.start\n        self.start -= 1\n    if \"version\" not in node[\"attrs\"]:\n        attrs[\"version\"] = \"1\"\n    else:\n        attrs[\"version\"] = int(node[\"attrs\"][\"version\"]) + 1\n    attrs[\"lat\"] = node[\"attrs\"][\"lat\"]\n    attrs[\"lon\"] = node[\"attrs\"][\"lon\"]\n    attrs[\"timestamp\"] = datetime.now().strftime(\"%Y-%m-%dT%TZ\")\n    # If the resulting file is publicly accessible without authentication, THE GDPR applies\n    # and the identifying fields should not be included\n    if \"uid\" in node[\"attrs\"]:\n        attrs[\"uid\"] = node[\"attrs\"][\"uid\"]\n    if \"user\" in node[\"attrs\"]:\n        attrs[\"user\"] = node[\"attrs\"][\"user\"]\n\n    # Processs atrributes\n    line = \"\"\n    osm = \"\"\n    for ref, value in attrs.items():\n        line += \"%s=%r \" % (ref, str(value))\n    osm += \"  &lt;node \" + line\n\n    if \"tags\" in node:\n        osm += \"&gt;\"\n        for key, value in node[\"tags\"].items():\n            if not value:\n                continue\n            if key not in attrs:\n                newkey = escape(key)\n                newval = escape(str(value))\n                osm += f\"\\n    &lt;tag k='{newkey}' v='{newval}'/&gt;\"\n        osm += \"\\n  &lt;/node&gt;\\n\"\n    else:\n        osm += \"/&gt;\"\n\n    return osm\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.createTag","title":"createTag","text":"<pre><code>createTag(field, value)\n</code></pre> <p>Create a data structure for an OSM feature tag.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The tag name</p> required <code>value</code> <code>str</code> <p>The value for the tag</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The newly created tag pair</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def createTag(\n    self,\n    field: str,\n    value: str,\n):\n    \"\"\"Create a data structure for an OSM feature tag.\n\n    Args:\n        field (str): The tag name\n        value (str): The value for the tag\n\n    Returns:\n        (dict): The newly created tag pair\n    \"\"\"\n    newval = str(value)\n    newval = newval.replace(\"&amp;\", \"and\")\n    newval = newval.replace('\"', \"\")\n    tag = dict()\n    # logging.debug(\"OSM:makeTag(field=%r, value=%r)\" % (field, newval))\n\n    newtag = field\n    change = newval.split(\"=\")\n    if len(change) &gt; 1:\n        newtag = change[0]\n        newval = change[1]\n\n    tag[newtag] = newval\n    return tag\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.loadFile","title":"loadFile","text":"<pre><code>loadFile(osmfile)\n</code></pre> <p>Read a OSM XML file generated by osm_fieldwork.</p> <p>Parameters:</p> Name Type Description Default <code>osmfile</code> <code>str</code> <p>The OSM XML file to load</p> required <p>Returns:</p> Type Description <code>list</code> <p>The entries in the OSM XML file</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def loadFile(\n    self,\n    osmfile: str,\n):\n    \"\"\"Read a OSM XML file generated by osm_fieldwork.\n\n    Args:\n        osmfile (str): The OSM XML file to load\n\n    Returns:\n        (list): The entries in the OSM XML file\n    \"\"\"\n    size = os.path.getsize(osmfile)\n    with open(osmfile, \"r\") as file:\n        xml = file.read(size)\n        doc = xmltodict.parse(xml)\n        if \"osm\" not in doc:\n            logging.warning(\"No data in this instance\")\n            return False\n        data = doc[\"osm\"]\n        if \"node\" not in data:\n            logging.warning(\"No nodes in this instance\")\n            return False\n\n    for node in data[\"node\"]:\n        attrs = {\n            \"id\": int(node[\"@id\"]),\n            \"lat\": node[\"@lat\"][:10],\n            \"lon\": node[\"@lon\"][:10],\n        }\n        if \"@timestamp\" in node:\n            attrs[\"timestamp\"] = node[\"@timestamp\"]\n\n        tags = dict()\n        if \"tag\" in node:\n            for tag in node[\"tag\"]:\n                if type(tag) == dict:\n                    tags[tag[\"@k\"]] = tag[\"@v\"].strip()\n                    # continue\n                else:\n                    tags[node[\"tag\"][\"@k\"]] = node[\"tag\"][\"@v\"].strip()\n                # continue\n        node = {\"attrs\": attrs, \"tags\": tags}\n        self.data.append(node)\n\n    for way in data[\"way\"]:\n        attrs = {\n            \"id\": int(way[\"@id\"]),\n        }\n        refs = list()\n        if len(way[\"nd\"]) &gt; 0:\n            for ref in way[\"nd\"]:\n                refs.append(int(ref[\"@ref\"]))\n\n        if \"@timestamp\" in node:\n            attrs[\"timestamp\"] = node[\"@timestamp\"]\n\n        tags = dict()\n        if \"tag\" in way:\n            for tag in way[\"tag\"]:\n                if type(tag) == dict:\n                    tags[tag[\"@k\"]] = tag[\"@v\"].strip()\n                    # continue\n                else:\n                    if len(node[\"tags\"]) &gt; 0:\n                        tags[node[\"tags\"][\"@k\"]] = node[\"tags\"][\"@v\"].strip()\n                # continue\n        way = {\"attrs\": attrs, \"refs\": refs, \"tags\": tags}\n        self.data.append(way)\n\n    return self.data\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    for _id, item in self.data.items():\n        for k, v in item[\"attrs\"].items():\n            print(f\"{k} = {v}\")\n        for k, v in item[\"tags\"].items():\n            print(f\"\\t{k} = {v}\")\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.getFeature","title":"getFeature","text":"<pre><code>getFeature(id)\n</code></pre> <p>Get the data for a feature from the loaded OSM data file.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID to retrieve the feasture of</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The feature for this ID or None</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def getFeature(\n    self,\n    id: int,\n):\n    \"\"\"Get the data for a feature from the loaded OSM data file.\n\n    Args:\n        id (int): The ID to retrieve the feasture of\n\n    Returns:\n        (dict): The feature for this ID or None\n    \"\"\"\n    return self.data[id]\n</code></pre>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.getFields","title":"getFields","text":"<pre><code>getFields()\n</code></pre> <p>Extract all the tags used in this file.</p> Source code in <code>osm_fieldwork/osmfile.py</code> <pre><code>def getFields(self):\n    \"\"\"Extract all the tags used in this file.\"\"\"\n    fields = list()\n    for _id, item in self.data.items():\n        keys = list(item[\"tags\"].keys())\n        for key in keys:\n            if key not in fields:\n                fields.append(key)\n</code></pre>"},{"location":"api/update_xlsform/","title":"update_xlsform.py","text":"<p>Append mandatory fields to the XLSForm for use in FMTM.</p> <p>Parameters:</p> Name Type Description Default <code>custom_form(BytesIO)</code> <p>the XLSForm data uploaded, wrapped in BytesIO.</p> required <code>form_name(str)</code> <p>the friendly form name in ODK web view.</p> required <code>additional_entities(list[str])</code> <p>add extra select_one_from_file fields to reference an additional Entity list (set of geometries). The values should be plural, so that 's' will be stripped in the field name.</p> required <code>new_geom_type</code> <code>DbGeomType</code> <p>the type of geometry required when collecting new geometry data: point, line, polygon.</p> <code>POINT</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(str, BytesIO)</code> <p>the xFormId + the update XLSForm wrapped in BytesIO.</p> Source code in <code>osm_fieldwork/update_xlsform.py</code> <pre><code>async def append_mandatory_fields(\n    custom_form: BytesIO,\n    form_name: str = f\"fmtm_{uuid4()}\",\n    additional_entities: list[str] = None,\n    new_geom_type: DbGeomType = DbGeomType.POINT,\n) -&gt; tuple[str, BytesIO]:\n    \"\"\"Append mandatory fields to the XLSForm for use in FMTM.\n\n    Args:\n        custom_form(BytesIO): the XLSForm data uploaded, wrapped in BytesIO.\n        form_name(str): the friendly form name in ODK web view.\n        additional_entities(list[str]): add extra select_one_from_file fields to\n            reference an additional Entity list (set of geometries).\n            The values should be plural, so that 's' will be stripped in the\n            field name.\n        new_geom_type (DbGeomType): the type of geometry required when collecting\n            new geometry data: point, line, polygon.\n\n    Returns:\n        tuple(str, BytesIO): the xFormId + the update XLSForm wrapped in BytesIO.\n    \"\"\"\n    log.info(\"Appending field mapping questions to XLSForm\")\n    custom_sheets = pd.read_excel(custom_form, sheet_name=None, engine=\"calamine\")\n\n    if \"survey\" not in custom_sheets:\n        msg = \"Survey sheet is required in XLSForm!\"\n        log.error(msg)\n        raise ValueError(msg)\n\n    custom_sheets = standardize_xlsform_sheets(custom_sheets)\n\n    log.debug(\"Merging survey sheet XLSForm data\")\n    survey_df = create_survey_df(new_geom_type)\n    custom_sheets[\"survey\"] = merge_dataframes(survey_df, custom_sheets.get(\"survey\"), digitisation_df)\n\n    # Ensure the 'choices' sheet exists in custom_sheets\n    if \"choices\" not in custom_sheets or custom_sheets[\"choices\"] is None:\n        custom_sheets[\"choices\"] = pd.DataFrame(columns=[\"list_name\", \"name\", \"label::english(en)\"])\n\n    log.debug(\"Merging choices sheet XLSForm data\")\n    custom_sheets[\"choices\"] = merge_dataframes(choices_df, custom_sheets.get(\"choices\"), digitisation_choices_df)\n\n    # Append or overwrite 'entities' and 'settings' sheets\n    log.debug(\"Overwriting entities and settings XLSForm sheets\")\n    custom_sheets[\"entities\"] = entities_df\n    if \"entities\" not in custom_sheets:\n        msg = \"Entities sheet is required in XLSForm!\"\n        log.error(msg)\n        raise ValueError(msg)\n    if \"settings\" not in custom_sheets:\n        msg = \"Settings sheet is required in XLSForm!\"\n        log.error(msg)\n        raise ValueError(msg)\n\n    # Extract existing form id if present, else set to random uuid\n    if \"form_id\" in custom_sheets[\"settings\"]:\n        xform_id = custom_sheets[\"settings\"][\"form_id\"]\n        log.debug(f\"Extracted existing form_id field: {xform_id}\")\n    else:\n        xform_id = str(uuid4())\n\n    current_datetime = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    log.debug(f\"Setting xFormId = {xform_id} | version = {current_datetime} | form_name = {form_name}\")\n\n    # Set the 'version' column to the current timestamp\n    custom_sheets[\"settings\"][\"version\"] = current_datetime\n    custom_sheets[\"settings\"][\"form_id\"] = xform_id\n    custom_sheets[\"settings\"][\"form_title\"] = form_name\n    if \"default_language\" not in custom_sheets[\"settings\"]:\n        custom_sheets[\"settings\"][\"default_language\"] = \"en\"\n\n    # Append select_one_from_file for additional entities\n    if additional_entities:\n        log.debug(\"Adding additional entity list reference to XLSForm\")\n        for entity_name in additional_entities:\n            custom_sheets[\"survey\"] = append_select_one_from_file_row(custom_sheets[\"survey\"], entity_name)\n\n    # Return spreadsheet wrapped as BytesIO memory object\n    output = BytesIO()\n    with pd.ExcelWriter(output, engine=\"openpyxl\") as writer:\n        for sheet_name, df in custom_sheets.items():\n            df.to_excel(writer, sheet_name=sheet_name, index=False)\n    output.seek(0)\n    return (xform_id, output)\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/yamlfile/","title":"yamlfile.py","text":"<p>               Bases: <code>object</code></p> <p>Config file in YAML format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The filespec of the YAML file to read</p> required <p>Returns:</p> Type Description <code>YamlFile</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/yamlfile.py</code> <pre><code>def __init__(\n    self,\n    data: str,\n):\n    \"\"\"This parses a yaml file into a dictionary for easy access.\n\n    Args:\n        data (str): The filespec of the YAML file to read\n\n    Returns:\n        (YamlFile): An instance of this object\n    \"\"\"\n    self.filespec = None\n    # if data == str:\n    self.filespec = data\n    self.file = open(data, \"rb\").read()\n    self.yaml = yaml.load(self.file, Loader=yaml.Loader)\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.privateData","title":"privateData","text":"<pre><code>privateData(keyword)\n</code></pre> <p>See if a keyword is in the private data category.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the private data section</p> Source code in <code>osm_fieldwork/yamlfile.py</code> <pre><code>def privateData(\n    self,\n    keyword: str,\n):\n    \"\"\"See if a keyword is in the private data category.\n\n    Args:\n        keyword (str): The keyword to search for\n\n    Returns:\n        (bool): Check to see if the keyword is in the private data section\n    \"\"\"\n    for value in self.yaml[\"private\"]:\n        if keyword.lower() in value:\n            return True\n    return False\n</code></pre>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.ignoreData","title":"ignoreData","text":"<pre><code>ignoreData(keyword)\n</code></pre> <p>See if a keyword is in the ignore data category.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the ignore data section</p> Source code in <code>osm_fieldwork/yamlfile.py</code> <pre><code>def ignoreData(\n    self,\n    keyword: str,\n):\n    \"\"\"See if a keyword is in the ignore data category.\n\n    Args:\n        keyword (str): The keyword to search for\n\n    Returns:\n        (bool): Check to see if the keyword is in the ignore data section\n    \"\"\"\n    for value in self.yaml[\"ignore\"]:\n        if keyword.lower() in value:\n            return True\n    return False\n</code></pre>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.convertData","title":"convertData","text":"<pre><code>convertData(keyword)\n</code></pre> <p>See if a keyword is in the convert data category.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the convert data section</p> Source code in <code>osm_fieldwork/yamlfile.py</code> <pre><code>def convertData(\n    self,\n    keyword: str,\n):\n    \"\"\"See if a keyword is in the convert data category.\n\n    Args:\n        keyword (str): The keyword to search for\n\n    Returns:\n        (bool): Check to see if the keyword is in the convert data section\n    \"\"\"\n    for value in self.yaml[\"convert\"]:\n        if keyword.lower() in value:\n            return True\n    return False\n</code></pre>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only.</p> Source code in <code>osm_fieldwork/yamlfile.py</code> <pre><code>def dump(self):\n    \"\"\"Dump internal data structures, for debugging purposes only.\"\"\"\n    if self.filespec:\n        print(\"YAML file: %s\" % self.filespec)\n    for key, values in self.yaml.items():\n        print(f\"Key is: {key}\")\n        for v in values:\n            if type(v) == dict:\n                for k1, v1 in v.items():\n                    if type(v1) == list:\n                        for item in v1:\n                            for i, j in item.items():\n                                print(f\"\\t{i} = {j}\")\n                    else:\n                        print(f\"\\t{k1} = {v1}\")\n                print(\"------------------\")\n            else:\n                print(f\"\\t{v}\")\n</code></pre>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.write","title":"write","text":"<pre><code>write(table)\n</code></pre> <p>Add to the YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>list</code> <p>The name of the database table</p> required <p>Returns:</p> Type Description <code>str</code> <p>The modified YAML data</p> Source code in <code>osm_fieldwork/yamlfile.py</code> <pre><code>def write(\n    self,\n    table: list,\n):\n    \"\"\"Add to the YAML file.\n\n    Args:\n          table (list): The name of the database table\n\n    Returns:\n        (str): The modified YAML data\n    \"\"\"\n    tab = \"    \"\n    yaml = [\"select:\", f'{tab}\"osm_id\": id', f\"{tab}tags:\"]\n    for item in where:\n        yaml.append(f\"{tab}{tab}- {item}\")\n    yaml.append(\"from:\")\n    for item in table:\n        yaml.append(f\"{tab}- {item}\")\n    yaml.append(\"where:\")\n    yaml.append(f\"{tab}tags:\")\n    notnull = f\"{tab}{tab}- \" + \"{\"\n    for item in where:\n        notnull += f\"{item}: NOT NULL, \"\n    notnull = f\"{notnull[:-2]}\"\n    notnull += \"}\"\n    yaml.append(f\"{notnull}\")\n    return yaml\n</code></pre>"}]}